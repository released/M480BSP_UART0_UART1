; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\rtc.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\rtc.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -D__FPU_PRESENT=1 --omf_browse=.\obj\rtc.crf ..\..\..\Library\StdDriver\src\rtc.c]
                          THUMB

                          AREA ||i.RTC_32KCalibration||, CODE, READONLY, ALIGN=2

                  RTC_32KCalibration PROC
;;;108      */
;;;109    void RTC_32KCalibration(int32_t i32FrequencyX10000)
000000  b570              PUSH     {r4-r6,lr}
;;;110    {
;;;111        uint64_t u64Compensate;
;;;112        int32_t i32RegInt,i32RegFra ;
;;;113    
;;;114        if(!(SYS->CSERVER & 0x1))
000002  f04f4180          MOV      r1,#0x40000000
000006  f8d111f4          LDR      r1,[r1,#0x1f4]
;;;115        {
;;;116            u64Compensate = (uint64_t)(0x2710000000000);
;;;117            u64Compensate = (uint64_t)(u64Compensate / (uint64_t)i32FrequencyX10000);
;;;118    
;;;119            if(u64Compensate >= (uint64_t)0x400000)
;;;120            {
;;;121                u64Compensate = (uint64_t)0x3FFFFF;
;;;122            }
;;;123    
;;;124            RTC_WaitAccessEnable();
;;;125            RTC->FREQADJ = (uint32_t)u64Compensate;
00000a  4e1b              LDR      r6,|L1.120|
00000c  07c9              LSLS     r1,r1,#31             ;114
00000e  d017              BEQ      |L1.64|
;;;126        }
;;;127        else
;;;128        {
;;;129            /* Compute Integer and Fraction for RTC register*/
;;;130            i32RegInt = (i32FrequencyX10000/10000) - 32752;
000010  f2427110          MOV      r1,#0x2710
000014  fb90f4f1          SDIV     r4,r0,r1
;;;131            i32RegFra = ((((i32FrequencyX10000%10000)) * 64) + 5000) / 10000;
000018  fb90f2f1          SDIV     r2,r0,r1
00001c  fb010012          MLS      r0,r1,r2,r0
000020  104a              ASRS     r2,r1,#1
000022  eb021080          ADD      r0,r2,r0,LSL #6
000026  fb90f5f1          SDIV     r5,r0,r1
00002a  f5a444fe          SUB      r4,r4,#0x7f00
00002e  3cf0              SUBS     r4,r4,#0xf0
;;;132    
;;;133            if(i32RegFra >= 0x40)
000030  2d40              CMP      r5,#0x40
000032  db01              BLT      |L1.56|
;;;134            {
;;;135                i32RegFra = 0x0;
000034  2500              MOVS     r5,#0
000036  1c64              ADDS     r4,r4,#1
                  |L1.56|
;;;136                i32RegInt++;
;;;137            }
;;;138    
;;;139            /* Judge Integer part is reasonable */
;;;140            if ( (i32RegInt < 0) | (i32RegInt > 31) )
000038  2c1f              CMP      r4,#0x1f
00003a  dd13              BLE      |L1.100|
00003c  2001              MOVS     r0,#1
00003e  e012              B        |L1.102|
                  |L1.64|
000040  4602              MOV      r2,r0
000042  17c3              ASRS     r3,r0,#31             ;117
000044  2000              MOVS     r0,#0                 ;117
000046  490d              LDR      r1,|L1.124|
000048  f7fffffe          BL       __aeabi_uldivmod
00004c  4604              MOV      r4,r0                 ;117
00004e  f44f0280          MOV      r2,#0x400000          ;119
000052  1a80              SUBS     r0,r0,r2              ;119
000054  f1710000          SBCS     r0,r1,#0              ;119
000058  d300              BCC      |L1.92|
00005a  1e54              SUBS     r4,r2,#1              ;119
                  |L1.92|
00005c  f7fffffe          BL       RTC_WaitAccessEnable
000060  60b4              STR      r4,[r6,#8]            ;125
                  |L1.98|
;;;141            {
;;;142                return;
;;;143            }
;;;144    
;;;145            RTC_WaitAccessEnable();
;;;146            RTC->FREQADJ = (uint32_t)((i32RegInt<<8) | i32RegFra);
;;;147        }
;;;148    
;;;149    }
000062  bd70              POP      {r4-r6,pc}
                  |L1.100|
000064  2000              MOVS     r0,#0                 ;140
                  |L1.102|
000066  ea5070d4          ORRS     r0,r0,r4,LSR #31      ;140
00006a  d1fa              BNE      |L1.98|
00006c  f7fffffe          BL       RTC_WaitAccessEnable
000070  ea452004          ORR      r0,r5,r4,LSL #8       ;146
000074  60b0              STR      r0,[r6,#8]            ;146
000076  bd70              POP      {r4-r6,pc}
;;;150    
                          ENDP

                  |L1.120|
                          DCD      0x40041000
                  |L1.124|
                          DCD      0x00027100

                          AREA ||i.RTC_Close||, CODE, READONLY, ALIGN=1

                  RTC_Close PROC
;;;95       */
;;;96     void RTC_Close(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;97     {
;;;98         CLK->APBCLK0 &= ~CLK_APBCLK0_RTCCKEN_Msk;
000004  f8d01208          LDR      r1,[r0,#0x208]
000008  f0210102          BIC      r1,r1,#2
00000c  f8c01208          STR      r1,[r0,#0x208]
;;;99     }
000010  4770              BX       lr
;;;100    
                          ENDP


                          AREA ||i.RTC_DisableInt||, CODE, READONLY, ALIGN=2

                  RTC_DisableInt PROC
;;;790      */
;;;791    void RTC_DisableInt(uint32_t u32IntFlagMask)
000000  b570              PUSH     {r4-r6,lr}
;;;792    {
000002  4605              MOV      r5,r0
;;;793        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;794        RTC->INTEN  &= ~u32IntFlagMask;
000008  4c03              LDR      r4,|L3.24|
00000a  6aa0              LDR      r0,[r4,#0x28]
00000c  43a8              BICS     r0,r0,r5
00000e  62a0              STR      r0,[r4,#0x28]
;;;795        RTC_WaitAccessEnable();
000010  f7fffffe          BL       RTC_WaitAccessEnable
;;;796        RTC->INTSTS = u32IntFlagMask;
000014  62e5              STR      r5,[r4,#0x2c]
;;;797    }
000016  bd70              POP      {r4-r6,pc}
;;;798    
                          ENDP

                  |L3.24|
                          DCD      0x40041000

                          AREA ||i.RTC_DisableSpareRegister||, CODE, READONLY, ALIGN=2

                  RTC_DisableSpareRegister PROC
;;;823      */
;;;824    void RTC_DisableSpareRegister(void)
000000  b510              PUSH     {r4,lr}
;;;825    {
;;;826        RTC_WaitAccessEnable();
000002  f7fffffe          BL       RTC_WaitAccessEnable
;;;827    
;;;828        RTC->SPRCTL &= ~RTC_SPRCTL_SPRRWEN_Msk;
000006  4803              LDR      r0,|L4.20|
000008  6bc1              LDR      r1,[r0,#0x3c]
00000a  f0210104          BIC      r1,r1,#4
00000e  63c1              STR      r1,[r0,#0x3c]
;;;829    }
000010  bd10              POP      {r4,pc}
;;;830    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40041000

                          AREA ||i.RTC_DynamicTamperConfig||, CODE, READONLY, ALIGN=2

                  RTC_DynamicTamperConfig PROC
;;;1070     */
;;;1071   void RTC_DynamicTamperConfig(uint32_t u32ChangeRate, uint32_t u32SeedReload, uint32_t u32RefPattern, uint32_t u32Seed)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1072   {
000004  4698              MOV      r8,r3
000006  4615              MOV      r5,r2
000008  460e              MOV      r6,r1
00000a  4607              MOV      r7,r0
;;;1073       uint32_t u32Reg;
;;;1074       RTC_WaitAccessEnable();
00000c  f7fffffe          BL       RTC_WaitAccessEnable
;;;1075       u32Reg = RTC->TAMPCTL;
000010  4c0c              LDR      r4,|L5.68|
000012  f8d40120          LDR      r0,[r4,#0x120]
;;;1076   
;;;1077       u32Reg &= ~(RTC_TAMPCTL_DYNSRC_Msk | RTC_TAMPCTL_SEEDRLD_Msk | RTC_TAMPCTL_DYNRATE_Msk);
;;;1078   
;;;1079       u32Reg |= (u32ChangeRate) | ((u32SeedReload & 0x1ul) << RTC_TAMPCTL_SEEDRLD_Pos) |
000016  f0060101          AND      r1,r6,#1
00001a  ea471101          ORR      r1,r7,r1,LSL #4
00001e  f0050203          AND      r2,r5,#3
000022  f02000fc          BIC      r0,r0,#0xfc           ;1077
000026  ea410582          ORR      r5,r1,r2,LSL #2
00002a  4305              ORRS     r5,r5,r0
00002c  f5047490          ADD      r4,r4,#0x120
;;;1080                 ((u32RefPattern & 0x3ul) << RTC_TAMPCTL_DYNSRC_Pos);
;;;1081   
;;;1082       RTC_WaitAccessEnable();
000030  f7fffffe          BL       RTC_WaitAccessEnable
;;;1083       RTC->TAMPSEED = u32Seed; /* need set seed value before re-load seed */
000034  f8c48008          STR      r8,[r4,#8]
;;;1084       RTC_WaitAccessEnable();
000038  f7fffffe          BL       RTC_WaitAccessEnable
;;;1085       RTC->TAMPCTL = u32Reg;
00003c  6025              STR      r5,[r4,#0]
;;;1086   }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;1087   
                          ENDP

000042  0000              DCW      0x0000
                  |L5.68|
                          DCD      0x40041000

                          AREA ||i.RTC_DynamicTamperDisable||, CODE, READONLY, ALIGN=2

                  RTC_DynamicTamperDisable PROC
;;;1006     */
;;;1007   void RTC_DynamicTamperDisable(uint32_t u32PairSel)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1008   {
;;;1009       uint32_t i;
;;;1010       uint32_t u32Reg;
;;;1011       uint32_t u32TmpReg;
;;;1012       uint32_t u32Tamper2En = 0ul, u32Tamper4En = 0ul;
000004  2500              MOVS     r5,#0
000006  4604              MOV      r4,r0                 ;1008
000008  462e              MOV      r6,r5
;;;1013   
;;;1014       RTC_WaitAccessEnable();
00000a  f7fffffe          BL       RTC_WaitAccessEnable
;;;1015       u32Reg = RTC->TAMPCTL;
00000e  4f13              LDR      r7,|L6.92|
000010  f8d71120          LDR      r1,[r7,#0x120]
;;;1016   
;;;1017       if((u32Reg & RTC_TAMPCTL_DYN1ISS_Msk) && (u32PairSel & RTC_PAIR1_SELECT))
000014  07c8              LSLS     r0,r1,#31
000016  d003              BEQ      |L6.32|
000018  07a0              LSLS     r0,r4,#30
00001a  d501              BPL      |L6.32|
;;;1018       {
;;;1019           u32Tamper2En = u32Reg & RTC_TAMPCTL_TAMP2EN_Msk;
00001c  f4013580          AND      r5,r1,#0x10000
                  |L6.32|
;;;1020       }
;;;1021   
;;;1022       if((u32Reg & RTC_TAMPCTL_DYN2ISS_Msk) && (u32PairSel & RTC_PAIR2_SELECT))
000020  0788              LSLS     r0,r1,#30
000022  d503              BPL      |L6.44|
000024  0760              LSLS     r0,r4,#29
000026  d501              BPL      |L6.44|
;;;1023       {
;;;1024           u32Tamper4En = u32Reg & RTC_TAMPCTL_TAMP4EN_Msk;
000028  f0017680          AND      r6,r1,#0x1000000
                  |L6.44|
;;;1025       }
;;;1026   
;;;1027       u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk | RTC_TAMPCTL_DYNPR0EN_Msk);
00002c  f44f4311          MOV      r3,#0x9100
;;;1028   
;;;1029       for(i = 0ul; i < MAX_PAIR_NUM; i++)
000030  2000              MOVS     r0,#0
;;;1030       {
;;;1031           if(u32PairSel & (0x1ul << i))
000032  f04f0c01          MOV      r12,#1
                  |L6.54|
000036  fa0cf200          LSL      r2,r12,r0
00003a  4222              TST      r2,r4
00003c  d003              BEQ      |L6.70|
;;;1032           {
;;;1033               u32Reg &= ~(u32TmpReg << ((i*8ul)));
00003e  00c2              LSLS     r2,r0,#3
000040  fa03f202          LSL      r2,r3,r2
000044  4391              BICS     r1,r1,r2
                  |L6.70|
000046  1c40              ADDS     r0,r0,#1
000048  2803              CMP      r0,#3                 ;1029
00004a  d3f4              BCC      |L6.54|
;;;1034           }
;;;1035       }
;;;1036   
;;;1037       u32Reg |= (u32Tamper2En | u32Tamper4En);
00004c  4335              ORRS     r5,r5,r6
00004e  430d              ORRS     r5,r5,r1
;;;1038   
;;;1039       RTC_WaitAccessEnable();
000050  f7fffffe          BL       RTC_WaitAccessEnable
;;;1040       RTC->TAMPCTL = u32Reg;
000054  f8c75120          STR      r5,[r7,#0x120]
;;;1041   }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;1042   
                          ENDP

                  |L6.92|
                          DCD      0x40041000

                          AREA ||i.RTC_DynamicTamperEnable||, CODE, READONLY, ALIGN=2

                  RTC_DynamicTamperEnable PROC
;;;941      */
;;;942    void RTC_DynamicTamperEnable(uint32_t u32PairSel, uint32_t u32DebounceEn, uint32_t u32Pair1Source, uint32_t u32Pair2Source)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;943    {
000004  461f              MOV      r7,r3
000006  4616              MOV      r6,r2
000008  468a              MOV      r10,r1
00000a  4605              MOV      r5,r0
;;;944        uint32_t i;
;;;945        uint32_t u32Reg;
;;;946        uint32_t u32TmpReg;
;;;947        uint32_t u32Tamper2Debounce, u32Tamper4Debounce;
;;;948    
;;;949        RTC_WaitAccessEnable();
00000c  f7fffffe          BL       RTC_WaitAccessEnable
;;;950        u32Reg = RTC->TAMPCTL;
000010  f8df9080          LDR      r9,|L7.148|
000014  f8d90120          LDR      r0,[r9,#0x120]
;;;951    
;;;952        u32Tamper2Debounce = u32Reg & RTC_TAMPCTL_TAMP2DBEN_Msk;
;;;953        u32Tamper4Debounce = u32Reg & RTC_TAMPCTL_TAMP4DBEN_Msk;
;;;954    
;;;955        u32Reg &= ~(RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk | RTC_TAMPCTL_TAMP2EN_Msk |
000018  491f              LDR      r1,|L7.152|
00001a  f4002880          AND      r8,r0,#0x40000        ;952
00001e  f0006c80          AND      r12,r0,#0x4000000     ;953
000022  4008              ANDS     r0,r0,r1
;;;956                    RTC_TAMPCTL_TAMP3EN_Msk | RTC_TAMPCTL_TAMP4EN_Msk | RTC_TAMPCTL_TAMP5EN_Msk);
;;;957        u32Reg &= ~(RTC_TAMPCTL_DYN1ISS_Msk | RTC_TAMPCTL_DYN2ISS_Msk);
;;;958        u32Reg |= ((u32Pair1Source & 0x1ul) << RTC_TAMPCTL_DYN1ISS_Pos) | ((u32Pair2Source & 0x1ul) << RTC_TAMPCTL_DYN2ISS_Pos);
000024  f0070101          AND      r1,r7,#1
000028  4634              MOV      r4,r6
00002a  f0200003          BIC      r0,r0,#3              ;957
00002e  f361045f          BFI      r4,r1,#1,#31
000032  4304              ORRS     r4,r4,r0
;;;959    
;;;960        if(u32DebounceEn)
000034  f1ba0f00          CMP      r10,#0
000038  d002              BEQ      |L7.64|
;;;961        {
;;;962            u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk |
00003a  f44f4255          MOV      r2,#0xd500
00003e  e001              B        |L7.68|
                  |L7.64|
;;;963                         RTC_TAMPCTL_TAMP0DBEN_Msk | RTC_TAMPCTL_TAMP1DBEN_Msk | RTC_TAMPCTL_DYNPR0EN_Msk);
;;;964        }
;;;965        else
;;;966        {
;;;967            u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk | RTC_TAMPCTL_TAMP1EN_Msk | RTC_TAMPCTL_DYNPR0EN_Msk);
000040  f44f4211          MOV      r2,#0x9100
                  |L7.68|
;;;968        }
;;;969    
;;;970        for(i = 0ul; i < MAX_PAIR_NUM; i++)
000044  2000              MOVS     r0,#0
;;;971        {
;;;972            if(u32PairSel & (0x1ul << i))
000046  f04f0a01          MOV      r10,#1
;;;973            {
;;;974                u32Reg &= ~((RTC_TAMPCTL_TAMP0DBEN_Msk | RTC_TAMPCTL_TAMP1DBEN_Msk) << (i*8ul));
00004a  f44f4b88          MOV      r11,#0x4400
                  |L7.78|
00004e  fa0af100          LSL      r1,r10,r0             ;972
000052  4229              TST      r1,r5                 ;972
000054  d006              BEQ      |L7.100|
000056  00c1              LSLS     r1,r0,#3
000058  fa0bf301          LSL      r3,r11,r1
00005c  439c              BICS     r4,r4,r3
;;;975                u32Reg |= (u32TmpReg << (i*8ul));
00005e  fa02f301          LSL      r3,r2,r1
000062  431c              ORRS     r4,r4,r3
                  |L7.100|
000064  1c40              ADDS     r0,r0,#1
000066  2803              CMP      r0,#3                 ;970
000068  d3f1              BCC      |L7.78|
;;;976            }
;;;977        }
;;;978    
;;;979        if((u32Pair1Source) && (u32PairSel & RTC_PAIR1_SELECT))
00006a  b12e              CBZ      r6,|L7.120|
00006c  07a8              LSLS     r0,r5,#30
00006e  d503              BPL      |L7.120|
;;;980        {
;;;981            u32Reg &= ~RTC_TAMPCTL_TAMP2EN_Msk;
000070  f4243480          BIC      r4,r4,#0x10000
;;;982            u32Reg |= u32Tamper2Debounce;
000074  ea440408          ORR      r4,r4,r8
                  |L7.120|
;;;983        }
;;;984    
;;;985        if((u32Pair2Source) && (u32PairSel & RTC_PAIR2_SELECT))
000078  b12f              CBZ      r7,|L7.134|
00007a  0768              LSLS     r0,r5,#29
00007c  d503              BPL      |L7.134|
;;;986        {
;;;987            u32Reg &= ~RTC_TAMPCTL_TAMP4EN_Msk;
00007e  f0247480          BIC      r4,r4,#0x1000000
;;;988            u32Reg |= u32Tamper4Debounce;
000082  ea44040c          ORR      r4,r4,r12
                  |L7.134|
;;;989        }
;;;990    
;;;991        RTC_WaitAccessEnable();
000086  f7fffffe          BL       RTC_WaitAccessEnable
;;;992        RTC->TAMPCTL = u32Reg;
00008a  f8c94120          STR      r4,[r9,#0x120]
;;;993    }
00008e  e8bd9ff0          POP      {r4-r12,pc}
;;;994    
                          ENDP

000092  0000              DCW      0x0000
                  |L7.148|
                          DCD      0x40041000
                  |L7.152|
                          DCD      0xeeeeeeff

                          AREA ||i.RTC_EnableInt||, CODE, READONLY, ALIGN=2

                  RTC_EnableInt PROC
;;;767      */
;;;768    void RTC_EnableInt(uint32_t u32IntFlagMask)
000000  b510              PUSH     {r4,lr}
;;;769    {
000002  4604              MOV      r4,r0
;;;770        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;771        RTC->INTEN |= u32IntFlagMask;
000008  4902              LDR      r1,|L8.20|
00000a  6a8a              LDR      r2,[r1,#0x28]
00000c  4322              ORRS     r2,r2,r4
00000e  628a              STR      r2,[r1,#0x28]
;;;772    }
000010  bd10              POP      {r4,pc}
;;;773    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40041000

                          AREA ||i.RTC_EnableSpareAccess||, CODE, READONLY, ALIGN=2

                  RTC_EnableSpareAccess PROC
;;;807      */
;;;808    void RTC_EnableSpareAccess(void)
000000  b510              PUSH     {r4,lr}
;;;809    {
;;;810        RTC_WaitAccessEnable();
000002  f7fffffe          BL       RTC_WaitAccessEnable
;;;811    
;;;812        RTC->SPRCTL |= RTC_SPRCTL_SPRRWEN_Msk;
000006  4803              LDR      r0,|L9.20|
000008  6bc1              LDR      r1,[r0,#0x3c]
00000a  f0410104          ORR      r1,r1,#4
00000e  63c1              STR      r1,[r0,#0x3c]
;;;813    }
000010  bd10              POP      {r4,pc}
;;;814    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40041000

                          AREA ||i.RTC_GetAlarmDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarmDateAndTime PROC
;;;263      */
;;;264    void RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  b570              PUSH     {r4-r6,lr}
;;;265    {
;;;266        uint32_t u32Tmp;
;;;267    
;;;268        sPt->u32TimeScale = RTC->CLKFMT & RTC_CLKFMT_24HEN_Msk;     /* 12/24-hour */
000002  4e3c              LDR      r6,|L10.244|
000004  4604              MOV      r4,r0                 ;265
000006  6970              LDR      r0,[r6,#0x14]
000008  f0000001          AND      r0,r0,#1
;;;269        sPt->u32DayOfWeek = RTC->WEEKDAY & RTC_WEEKDAY_WEEKDAY_Msk; /* Day of the week */
00000c  61e0              STR      r0,[r4,#0x1c]
00000e  69b0              LDR      r0,[r6,#0x18]
000010  f0000007          AND      r0,r0,#7
;;;270    
;;;271        /* Get alarm [Date digit] data */
;;;272        RTC_WaitAccessEnable();
000014  60e0              STR      r0,[r4,#0xc]
000016  f7fffffe          BL       RTC_WaitAccessEnable
;;;273        g_u32hiYear  = (RTC->CALM & RTC_CALM_TENYEAR_Msk) >> RTC_CALM_TENYEAR_Pos;
00001a  6a30              LDR      r0,[r6,#0x20]
00001c  4d36              LDR      r5,|L10.248|
00001e  f3c05003          UBFX     r0,r0,#20,#4
000022  6028              STR      r0,[r5,#0]  ; g_u32hiYear
;;;274        g_u32loYear  = (RTC->CALM & RTC_CALM_YEAR_Msk) >> RTC_CALM_YEAR_Pos;
000024  6a30              LDR      r0,[r6,#0x20]
000026  f3c04003          UBFX     r0,r0,#16,#4
00002a  6068              STR      r0,[r5,#4]  ; g_u32loYear
;;;275        g_u32hiMonth = (RTC->CALM & RTC_CALM_TENMON_Msk) >> RTC_CALM_TENMON_Pos;
00002c  6a30              LDR      r0,[r6,#0x20]
00002e  f3c03000          UBFX     r0,r0,#12,#1
000032  60a8              STR      r0,[r5,#8]  ; g_u32hiMonth
;;;276        g_u32loMonth = (RTC->CALM & RTC_CALM_MON_Msk) >> RTC_CALM_MON_Pos;
000034  6a30              LDR      r0,[r6,#0x20]
000036  f3c02003          UBFX     r0,r0,#8,#4
00003a  60e8              STR      r0,[r5,#0xc]  ; g_u32loMonth
;;;277        g_u32hiDay   = (RTC->CALM & RTC_CALM_TENDAY_Msk) >> RTC_CALM_TENDAY_Pos;
00003c  6a30              LDR      r0,[r6,#0x20]
00003e  f3c01001          UBFX     r0,r0,#4,#2
000042  6128              STR      r0,[r5,#0x10]  ; g_u32hiDay
;;;278        g_u32loDay   = (RTC->CALM & RTC_CALM_DAY_Msk) >> RTC_CALM_DAY_Pos;
000044  6a30              LDR      r0,[r6,#0x20]
000046  f000000f          AND      r0,r0,#0xf
00004a  6168              STR      r0,[r5,#0x14]  ; g_u32loDay
;;;279    
;;;280        /* Get alarm [Time digit] data */
;;;281        RTC_WaitAccessEnable();
00004c  f7fffffe          BL       RTC_WaitAccessEnable
;;;282        g_u32hiHour = (RTC->TALM & RTC_TALM_TENHR_Msk) >> RTC_TALM_TENHR_Pos;
000050  69f0              LDR      r0,[r6,#0x1c]
000052  f3c05001          UBFX     r0,r0,#20,#2
000056  61a8              STR      r0,[r5,#0x18]  ; g_u32hiHour
;;;283        g_u32loHour = (RTC->TALM & RTC_TALM_HR_Msk) >> RTC_TALM_HR_Pos;
000058  69f0              LDR      r0,[r6,#0x1c]
00005a  f3c04003          UBFX     r0,r0,#16,#4
00005e  61e8              STR      r0,[r5,#0x1c]  ; g_u32loHour
;;;284        g_u32hiMin  = (RTC->TALM & RTC_TALM_TENMIN_Msk) >> RTC_TALM_TENMIN_Pos;
000060  69f0              LDR      r0,[r6,#0x1c]
000062  f3c03002          UBFX     r0,r0,#12,#3
000066  6228              STR      r0,[r5,#0x20]  ; g_u32hiMin
;;;285        g_u32loMin  = (RTC->TALM & RTC_TALM_MIN_Msk) >> RTC_TALM_MIN_Pos;
000068  69f0              LDR      r0,[r6,#0x1c]
00006a  f3c02003          UBFX     r0,r0,#8,#4
00006e  6268              STR      r0,[r5,#0x24]  ; g_u32loMin
;;;286        g_u32hiSec  = (RTC->TALM & RTC_TALM_TENSEC_Msk) >> RTC_TALM_TENSEC_Pos;
000070  69f0              LDR      r0,[r6,#0x1c]
000072  f3c01002          UBFX     r0,r0,#4,#3
000076  62a8              STR      r0,[r5,#0x28]  ; g_u32hiSec
;;;287        g_u32loSec  = (RTC->TALM & RTC_TALM_SEC_Msk) >> RTC_TALM_SEC_Pos;
000078  69f0              LDR      r0,[r6,#0x1c]
00007a  f000000f          AND      r0,r0,#0xf
00007e  62e8              STR      r0,[r5,#0x2c]  ; g_u32loSec
;;;288    
;;;289        /* Compute to 20XX year */
;;;290        u32Tmp  = (g_u32hiYear * 10ul);
000080  6828              LDR      r0,[r5,#0]  ; g_u32hiYear
;;;291        u32Tmp += g_u32loYear;
000082  6869              LDR      r1,[r5,#4]  ; g_u32loYear
000084  eb000080          ADD      r0,r0,r0,LSL #2       ;290
000088  eb010040          ADD      r0,r1,r0,LSL #1
00008c  f50060fa          ADD      r0,r0,#0x7d0
;;;292        sPt->u32Year = u32Tmp + RTC_YEAR2000;
;;;293    
;;;294        /* Compute 0~12 month */
;;;295        u32Tmp = (g_u32hiMonth * 10ul);
000090  6020              STR      r0,[r4,#0]
000092  68a8              LDR      r0,[r5,#8]  ; g_u32hiMonth
;;;296        sPt->u32Month = u32Tmp + g_u32loMonth;
000094  68e9              LDR      r1,[r5,#0xc]  ; g_u32loMonth
000096  eb000080          ADD      r0,r0,r0,LSL #2       ;295
00009a  eb010040          ADD      r0,r1,r0,LSL #1
;;;297    
;;;298        /* Compute 0~31 day */
;;;299        u32Tmp = (g_u32hiDay * 10ul);
00009e  6060              STR      r0,[r4,#4]
0000a0  6928              LDR      r0,[r5,#0x10]  ; g_u32hiDay
;;;300        sPt->u32Day = u32Tmp + g_u32loDay;
0000a2  6969              LDR      r1,[r5,#0x14]  ; g_u32loDay
0000a4  eb000080          ADD      r0,r0,r0,LSL #2       ;299
0000a8  eb010040          ADD      r0,r1,r0,LSL #1
;;;301    
;;;302        /* Compute 12/24 hour */
;;;303        if(sPt->u32TimeScale == RTC_CLOCK_12)
0000ac  60a0              STR      r0,[r4,#8]
0000ae  69e0              LDR      r0,[r4,#0x1c]
0000b0  2800              CMP      r0,#0
;;;304        {
;;;305            u32Tmp  = (g_u32hiHour * 10ul);
;;;306            u32Tmp += g_u32loHour;
;;;307            sPt->u32Hour = u32Tmp;          /* AM: 1~12. PM: 21~32. */
;;;308    
;;;309            if(sPt->u32Hour >= 21ul)
;;;310            {
;;;311                sPt->u32AmPm  = RTC_PM;
;;;312                sPt->u32Hour -= 20ul;
;;;313            }
;;;314            else
;;;315            {
;;;316                sPt->u32AmPm = RTC_AM;
;;;317            }
;;;318    
;;;319            u32Tmp  = (g_u32hiMin * 10ul);
;;;320            u32Tmp += g_u32loMin;
;;;321            sPt->u32Minute = u32Tmp;
;;;322    
;;;323            u32Tmp  = (g_u32hiSec * 10ul);
;;;324            u32Tmp += g_u32loSec;
;;;325            sPt->u32Second = u32Tmp;
;;;326    
;;;327        }
;;;328        else
;;;329        {
;;;330            u32Tmp  = (g_u32hiHour * 10ul);
0000b2  69a8              LDR      r0,[r5,#0x18]  ; g_u32hiHour
;;;331            u32Tmp +=  g_u32loHour;
0000b4  69e9              LDR      r1,[r5,#0x1c]  ; g_u32loHour
0000b6  eb000080          ADD      r0,r0,r0,LSL #2       ;330
0000ba  ea4f0040          LSL      r0,r0,#1              ;330
0000be  4408              ADD      r0,r0,r1
0000c0  d105              BNE      |L10.206|
0000c2  6120              STR      r0,[r4,#0x10]         ;309
0000c4  2815              CMP      r0,#0x15              ;309
0000c6  d304              BCC      |L10.210|
0000c8  2102              MOVS     r1,#2                 ;311
0000ca  3814              SUBS     r0,r0,#0x14           ;311
0000cc  6221              STR      r1,[r4,#0x20]         ;311
                  |L10.206|
;;;332            sPt->u32Hour = u32Tmp;
0000ce  6120              STR      r0,[r4,#0x10]
0000d0  e001              B        |L10.214|
                  |L10.210|
0000d2  2001              MOVS     r0,#1                 ;316
0000d4  6220              STR      r0,[r4,#0x20]         ;316
                  |L10.214|
0000d6  6a28              LDR      r0,[r5,#0x20]         ;319  ; g_u32hiMin
0000d8  6a69              LDR      r1,[r5,#0x24]         ;320  ; g_u32loMin
0000da  eb000080          ADD      r0,r0,r0,LSL #2       ;319
0000de  eb010040          ADD      r0,r1,r0,LSL #1       ;320
0000e2  6160              STR      r0,[r4,#0x14]         ;323
0000e4  6aa8              LDR      r0,[r5,#0x28]         ;323  ; g_u32hiSec
0000e6  6ae9              LDR      r1,[r5,#0x2c]         ;324  ; g_u32loSec
0000e8  eb000080          ADD      r0,r0,r0,LSL #2       ;323
0000ec  eb010040          ADD      r0,r1,r0,LSL #1       ;324
0000f0  61a0              STR      r0,[r4,#0x18]         ;325
;;;333    
;;;334            u32Tmp  = (g_u32hiMin * 10ul);
;;;335            u32Tmp += g_u32loMin;
;;;336            sPt->u32Minute = u32Tmp;
;;;337    
;;;338            u32Tmp  = (g_u32hiSec * 10ul);
;;;339            u32Tmp += g_u32loSec;
;;;340            sPt->u32Second = u32Tmp;
;;;341        }
;;;342    }
0000f2  bd70              POP      {r4-r6,pc}
;;;343    
                          ENDP

                  |L10.244|
                          DCD      0x40041000
                  |L10.248|
                          DCD      ||.data||

                          AREA ||i.RTC_GetDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_GetDateAndTime PROC
;;;168      */
;;;169    void RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  4a38              LDR      r2,|L11.228|
;;;170    {
000002  b510              PUSH     {r4,lr}
;;;171        uint32_t u32Tmp;
;;;172    
;;;173        sPt->u32TimeScale = RTC->CLKFMT & RTC_CLKFMT_24HEN_Msk;     /* 12/24-hour */
000004  6951              LDR      r1,[r2,#0x14]
000006  f0110301          ANDS     r3,r1,#1
;;;174        sPt->u32DayOfWeek = RTC->WEEKDAY & RTC_WEEKDAY_WEEKDAY_Msk; /* Day of the week */
00000a  61c3              STR      r3,[r0,#0x1c]
00000c  6991              LDR      r1,[r2,#0x18]
00000e  f0010107          AND      r1,r1,#7
;;;175    
;;;176        /* Get [Date digit] data */
;;;177        g_u32hiYear  = (RTC->CAL & RTC_CAL_TENYEAR_Msk) >> RTC_CAL_TENYEAR_Pos;
000012  60c1              STR      r1,[r0,#0xc]
000014  6911              LDR      r1,[r2,#0x10]
000016  f3c15403          UBFX     r4,r1,#20,#4
00001a  4933              LDR      r1,|L11.232|
00001c  600c              STR      r4,[r1,#0]  ; g_u32hiYear
;;;178        g_u32loYear  = (RTC->CAL & RTC_CAL_YEAR_Msk) >> RTC_CAL_YEAR_Pos;
00001e  6914              LDR      r4,[r2,#0x10]
000020  f3c44403          UBFX     r4,r4,#16,#4
000024  604c              STR      r4,[r1,#4]  ; g_u32loYear
;;;179        g_u32hiMonth = (RTC->CAL & RTC_CAL_TENMON_Msk) >> RTC_CAL_TENMON_Pos;
000026  6914              LDR      r4,[r2,#0x10]
000028  f3c43400          UBFX     r4,r4,#12,#1
00002c  608c              STR      r4,[r1,#8]  ; g_u32hiMonth
;;;180        g_u32loMonth = (RTC->CAL & RTC_CAL_MON_Msk) >> RTC_CAL_MON_Pos;
00002e  6914              LDR      r4,[r2,#0x10]
000030  f3c42403          UBFX     r4,r4,#8,#4
000034  60cc              STR      r4,[r1,#0xc]  ; g_u32loMonth
;;;181        g_u32hiDay   = (RTC->CAL & RTC_CAL_TENDAY_Msk) >> RTC_CAL_TENDAY_Pos;
000036  6914              LDR      r4,[r2,#0x10]
000038  f3c41401          UBFX     r4,r4,#4,#2
00003c  610c              STR      r4,[r1,#0x10]  ; g_u32hiDay
;;;182        g_u32loDay   = (RTC->CAL & RTC_CAL_DAY_Msk) >> RTC_CAL_DAY_Pos;
00003e  6914              LDR      r4,[r2,#0x10]
000040  f004040f          AND      r4,r4,#0xf
000044  614c              STR      r4,[r1,#0x14]  ; g_u32loDay
;;;183    
;;;184        /* Get [Time digit] data */
;;;185        g_u32hiHour = (RTC->TIME & RTC_TIME_TENHR_Msk) >> RTC_TIME_TENHR_Pos;
000046  68d4              LDR      r4,[r2,#0xc]
000048  f3c45401          UBFX     r4,r4,#20,#2
00004c  618c              STR      r4,[r1,#0x18]  ; g_u32hiHour
;;;186        g_u32loHour = (RTC->TIME & RTC_TIME_HR_Msk) >> RTC_TIME_HR_Pos;
00004e  68d4              LDR      r4,[r2,#0xc]
000050  f3c44403          UBFX     r4,r4,#16,#4
000054  61cc              STR      r4,[r1,#0x1c]  ; g_u32loHour
;;;187        g_u32hiMin  = (RTC->TIME & RTC_TIME_TENMIN_Msk) >> RTC_TIME_TENMIN_Pos;
000056  68d4              LDR      r4,[r2,#0xc]
000058  f3c43402          UBFX     r4,r4,#12,#3
00005c  620c              STR      r4,[r1,#0x20]  ; g_u32hiMin
;;;188        g_u32loMin  = (RTC->TIME & RTC_TIME_MIN_Msk) >> RTC_TIME_MIN_Pos;
00005e  68d4              LDR      r4,[r2,#0xc]
000060  f3c42403          UBFX     r4,r4,#8,#4
000064  624c              STR      r4,[r1,#0x24]  ; g_u32loMin
;;;189        g_u32hiSec  = (RTC->TIME & RTC_TIME_TENSEC_Msk) >> RTC_TIME_TENSEC_Pos;
000066  68d4              LDR      r4,[r2,#0xc]
000068  f3c41402          UBFX     r4,r4,#4,#3
00006c  628c              STR      r4,[r1,#0x28]  ; g_u32hiSec
;;;190        g_u32loSec  = (RTC->TIME & RTC_TIME_SEC_Msk) >> RTC_TIME_SEC_Pos;
00006e  68d2              LDR      r2,[r2,#0xc]
000070  f002020f          AND      r2,r2,#0xf
000074  62ca              STR      r2,[r1,#0x2c]  ; g_u32loSec
;;;191    
;;;192        /* Compute to 20XX year */
;;;193        u32Tmp  = (g_u32hiYear * 10ul);
000076  680a              LDR      r2,[r1,#0]  ; g_u32hiYear
;;;194        u32Tmp += g_u32loYear;
000078  684c              LDR      r4,[r1,#4]  ; g_u32loYear
00007a  eb020282          ADD      r2,r2,r2,LSL #2       ;193
00007e  eb040242          ADD      r2,r4,r2,LSL #1
000082  f50262fa          ADD      r2,r2,#0x7d0
;;;195        sPt->u32Year = u32Tmp + RTC_YEAR2000;
;;;196    
;;;197        /* Compute 0~12 month */
;;;198        u32Tmp = (g_u32hiMonth * 10ul);
000086  6002              STR      r2,[r0,#0]
000088  688a              LDR      r2,[r1,#8]  ; g_u32hiMonth
;;;199        sPt->u32Month = u32Tmp + g_u32loMonth;
00008a  68cc              LDR      r4,[r1,#0xc]  ; g_u32loMonth
00008c  eb020282          ADD      r2,r2,r2,LSL #2       ;198
000090  eb040242          ADD      r2,r4,r2,LSL #1
;;;200    
;;;201        /* Compute 0~31 day */
;;;202        u32Tmp = (g_u32hiDay * 10ul);
000094  6042              STR      r2,[r0,#4]
000096  690a              LDR      r2,[r1,#0x10]  ; g_u32hiDay
;;;203        sPt->u32Day =  u32Tmp  + g_u32loDay;
000098  694c              LDR      r4,[r1,#0x14]  ; g_u32loDay
00009a  eb020282          ADD      r2,r2,r2,LSL #2       ;202
00009e  eb040242          ADD      r2,r4,r2,LSL #1
;;;204    
;;;205        /* Compute 12/24 hour */
;;;206        if(sPt->u32TimeScale == RTC_CLOCK_12)
;;;207        {
;;;208            u32Tmp = (g_u32hiHour * 10ul);
;;;209            u32Tmp += g_u32loHour;
;;;210            sPt->u32Hour = u32Tmp;          /* AM: 1~12. PM: 21~32. */
;;;211    
;;;212            if(sPt->u32Hour >= 21ul)
;;;213            {
;;;214                sPt->u32AmPm  = RTC_PM;
;;;215                sPt->u32Hour -= 20ul;
;;;216            }
;;;217            else
;;;218            {
;;;219                sPt->u32AmPm = RTC_AM;
;;;220            }
;;;221    
;;;222            u32Tmp  = (g_u32hiMin  * 10ul);
;;;223            u32Tmp += g_u32loMin;
;;;224            sPt->u32Minute = u32Tmp;
;;;225    
;;;226            u32Tmp  = (g_u32hiSec  * 10ul);
;;;227            u32Tmp += g_u32loSec;
;;;228            sPt->u32Second = u32Tmp;
;;;229        }
;;;230        else
;;;231        {
;;;232            u32Tmp  = (g_u32hiHour * 10ul);
0000a2  6082              STR      r2,[r0,#8]
0000a4  698a              LDR      r2,[r1,#0x18]  ; g_u32hiHour
;;;233            u32Tmp += g_u32loHour;
0000a6  69cb              LDR      r3,[r1,#0x1c]  ; g_u32loHour
0000a8  eb020282          ADD      r2,r2,r2,LSL #2       ;232
0000ac  eb030242          ADD      r2,r3,r2,LSL #1
0000b0  d105              BNE      |L11.190|
0000b2  6102              STR      r2,[r0,#0x10]         ;212
0000b4  2a15              CMP      r2,#0x15              ;212
0000b6  d304              BCC      |L11.194|
0000b8  2302              MOVS     r3,#2                 ;214
0000ba  3a14              SUBS     r2,r2,#0x14           ;214
0000bc  6203              STR      r3,[r0,#0x20]         ;214
                  |L11.190|
;;;234            sPt->u32Hour = u32Tmp;
0000be  6102              STR      r2,[r0,#0x10]
0000c0  e001              B        |L11.198|
                  |L11.194|
0000c2  2201              MOVS     r2,#1                 ;219
0000c4  6202              STR      r2,[r0,#0x20]         ;219
                  |L11.198|
0000c6  6a0a              LDR      r2,[r1,#0x20]         ;222  ; g_u32hiMin
0000c8  6a4b              LDR      r3,[r1,#0x24]         ;223  ; g_u32loMin
0000ca  eb020282          ADD      r2,r2,r2,LSL #2       ;222
0000ce  eb030242          ADD      r2,r3,r2,LSL #1       ;223
0000d2  6142              STR      r2,[r0,#0x14]         ;226
0000d4  6a8a              LDR      r2,[r1,#0x28]         ;226  ; g_u32hiSec
0000d6  6ac9              LDR      r1,[r1,#0x2c]         ;227  ; g_u32loSec
0000d8  eb020282          ADD      r2,r2,r2,LSL #2       ;226
0000dc  eb010142          ADD      r1,r1,r2,LSL #1       ;227
0000e0  6181              STR      r1,[r0,#0x18]         ;228
;;;235    
;;;236            u32Tmp  = (g_u32hiMin * 10ul);
;;;237            u32Tmp +=  g_u32loMin;
;;;238            sPt->u32Minute = u32Tmp;
;;;239    
;;;240            u32Tmp  = (g_u32hiSec * 10ul);
;;;241            u32Tmp += g_u32loSec;
;;;242            sPt->u32Second = u32Tmp;
;;;243        }
;;;244    }
0000e2  bd10              POP      {r4,pc}
;;;245    
                          ENDP

                  |L11.228|
                          DCD      0x40041000
                  |L11.232|
                          DCD      ||.data||

                          AREA ||i.RTC_GetDayOfWeek||, CODE, READONLY, ALIGN=2

                  RTC_GetDayOfWeek PROC
;;;720      */
;;;721    uint32_t RTC_GetDayOfWeek(void)
000000  4802              LDR      r0,|L12.12|
;;;722    {
;;;723        return (RTC->WEEKDAY & RTC_WEEKDAY_WEEKDAY_Msk);
000002  6980              LDR      r0,[r0,#0x18]
000004  f0000007          AND      r0,r0,#7
;;;724    }
000008  4770              BX       lr
;;;725    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      0x40041000

                          AREA ||i.RTC_Open||, CODE, READONLY, ALIGN=2

                  RTC_Open PROC
;;;64       */
;;;65     void RTC_Open(S_RTC_TIME_DATA_T *sPt)
000000  4908              LDR      r1,|L13.36|
;;;66     {
;;;67         RTC->INIT = RTC_INIT_KEY;
000002  4a07              LDR      r2,|L13.32|
000004  600a              STR      r2,[r1,#0]
;;;68     
;;;69         if(RTC->INIT != RTC_INIT_ACTIVE_Msk)
000006  680b              LDR      r3,[r1,#0]
000008  2b01              CMP      r3,#1
00000a  d003              BEQ      |L13.20|
;;;70         {
;;;71             RTC->INIT = RTC_INIT_KEY;
00000c  600a              STR      r2,[r1,#0]
                  |L13.14|
;;;72             while(RTC->INIT != RTC_INIT_ACTIVE_Msk)
00000e  680a              LDR      r2,[r1,#0]
000010  2a01              CMP      r2,#1
000012  d1fc              BNE      |L13.14|
                  |L13.20|
;;;73             {
;;;74             }
;;;75         }
;;;76     
;;;77         if(sPt == 0)
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L13.28|
;;;78         {
;;;79         }
;;;80         else
;;;81         {
;;;82             /* Set RTC date and time */
;;;83             RTC_SetDateAndTime(sPt);
000018  f7ffbffe          B.W      RTC_SetDateAndTime
                  |L13.28|
;;;84         }
;;;85     }
00001c  4770              BX       lr
;;;86     
                          ENDP

00001e  0000              DCW      0x0000
                  |L13.32|
                          DCD      0xa5eb1357
                  |L13.36|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmDate||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmDate PROC
;;;590      */
;;;591    void RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day)
000000  b570              PUSH     {r4-r6,lr}
;;;592    {
;;;593        uint32_t u32RegCALM;
;;;594    
;;;595        u32RegCALM  = ((u32Year - RTC_YEAR2000) / 10ul) << 20;
000002  230a              MOVS     r3,#0xa
000004  f5a060fa          SUB      r0,r0,#0x7d0
000008  fbb0f4f3          UDIV     r4,r0,r3
;;;596        u32RegCALM |= (((u32Year - RTC_YEAR2000) % 10ul) << 16);
00000c  fbb0f5f3          UDIV     r5,r0,r3
000010  fb030015          MLS      r0,r3,r5,r0
000014  0524              LSLS     r4,r4,#20             ;595
000016  ea444000          ORR      r0,r4,r0,LSL #16
;;;597        u32RegCALM |= ((u32Month / 10ul) << 12);
00001a  fbb1f4f3          UDIV     r4,r1,r3
00001e  ea403004          ORR      r0,r0,r4,LSL #12
;;;598        u32RegCALM |= ((u32Month % 10ul) << 8);
000022  fbb1f4f3          UDIV     r4,r1,r3
000026  fb031114          MLS      r1,r3,r4,r1
00002a  ea402001          ORR      r0,r0,r1,LSL #8
;;;599        u32RegCALM |= ((u32Day   / 10ul) << 4);
00002e  fbb2f1f3          UDIV     r1,r2,r3
000032  ea401001          ORR      r0,r0,r1,LSL #4
;;;600        u32RegCALM |= (u32Day   % 10ul);
000036  fbb2f1f3          UDIV     r1,r2,r3
00003a  fb032411          MLS      r4,r3,r1,r2
00003e  4304              ORRS     r4,r4,r0
;;;601    
;;;602        RTC_WaitAccessEnable();
000040  f7fffffe          BL       RTC_WaitAccessEnable
;;;603    
;;;604        /* Set RTC Alarm Date */
;;;605        RTC->CALM = (uint32_t)u32RegCALM;
000044  4801              LDR      r0,|L14.76|
000046  6204              STR      r4,[r0,#0x20]
;;;606    }
000048  bd70              POP      {r4-r6,pc}
;;;607    
                          ENDP

00004a  0000              DCW      0x0000
                  |L14.76|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmDateAndTime PROC
;;;444      */
;;;445    void RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  b570              PUSH     {r4-r6,lr}
;;;446    {
000002  0004              MOVS     r4,r0
000004  d050              BEQ      |L15.168|
;;;447        uint32_t u32RegCALM, u32RegTALM;
;;;448    
;;;449        if(sPt == 0)
;;;450        {
;;;451        }
;;;452        else
;;;453        {
;;;454            /*-----------------------------------------------------------------------------------------------------*/
;;;455            /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;456            /*-----------------------------------------------------------------------------------------------------*/
;;;457            RTC_WaitAccessEnable();
000006  f7fffffe          BL       RTC_WaitAccessEnable
;;;458            if(sPt->u32TimeScale == RTC_CLOCK_12)
;;;459            {
;;;460                RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00000a  4d2d              LDR      r5,|L15.192|
00000c  69e0              LDR      r0,[r4,#0x1c]         ;458
00000e  2800              CMP      r0,#0                 ;458
;;;461    
;;;462                /*-------------------------------------------------------------------------------------------------*/
;;;463                /* Important, range of 12-hour PM mode is 21 up to 32                                               */
;;;464                /*-------------------------------------------------------------------------------------------------*/
;;;465                if(sPt->u32AmPm == RTC_PM)
;;;466                {
;;;467                    sPt->u32Hour += 20ul;
;;;468                }
;;;469            }
;;;470            else
;;;471            {
;;;472                RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
000010  6968              LDR      r0,[r5,#0x14]
000012  d04a              BEQ      |L15.170|
000014  f0400001          ORR      r0,r0,#1
000018  6168              STR      r0,[r5,#0x14]
                  |L15.26|
;;;473            }
;;;474    
;;;475            /*-----------------------------------------------------------------------------------------------------*/
;;;476            /* Set RTC Alarm Date and Time                                                                         */
;;;477            /*-----------------------------------------------------------------------------------------------------*/
;;;478            u32RegCALM  = ((sPt->u32Year - RTC_YEAR2000) / 10ul) << 20;
00001a  6821              LDR      r1,[r4,#0]
00001c  200a              MOVS     r0,#0xa
00001e  f5a161fa          SUB      r1,r1,#0x7d0
000022  fbb1f2f0          UDIV     r2,r1,r0
;;;479            u32RegCALM |= (((sPt->u32Year - RTC_YEAR2000) % 10ul) << 16);
000026  fbb1f3f0          UDIV     r3,r1,r0
00002a  fb001113          MLS      r1,r0,r3,r1
00002e  0512              LSLS     r2,r2,#20             ;478
000030  ea424201          ORR      r2,r2,r1,LSL #16
;;;480            u32RegCALM |= ((sPt->u32Month  / 10ul) << 12);
000034  6861              LDR      r1,[r4,#4]
000036  fbb1f3f0          UDIV     r3,r1,r0
00003a  ea423203          ORR      r2,r2,r3,LSL #12
;;;481            u32RegCALM |= ((sPt->u32Month  % 10ul) << 8);
00003e  fbb1f3f0          UDIV     r3,r1,r0
000042  fb001113          MLS      r1,r0,r3,r1
000046  ea422201          ORR      r2,r2,r1,LSL #8
;;;482            u32RegCALM |= ((sPt->u32Day    / 10ul) << 4);
00004a  68a1              LDR      r1,[r4,#8]
00004c  fbb1f3f0          UDIV     r3,r1,r0
000050  ea421203          ORR      r2,r2,r3,LSL #4
;;;483            u32RegCALM |= (sPt->u32Day    % 10ul);
000054  fbb1f3f0          UDIV     r3,r1,r0
000058  fb001613          MLS      r6,r0,r3,r1
;;;484    
;;;485            u32RegTALM  = ((sPt->u32Hour   / 10ul) << 20);
00005c  6921              LDR      r1,[r4,#0x10]
00005e  4316              ORRS     r6,r6,r2              ;483
000060  fbb1f2f0          UDIV     r2,r1,r0
;;;486            u32RegTALM |= ((sPt->u32Hour   % 10ul) << 16);
000064  fbb1f3f0          UDIV     r3,r1,r0
000068  fb001113          MLS      r1,r0,r3,r1
00006c  0512              LSLS     r2,r2,#20             ;485
00006e  ea424201          ORR      r2,r2,r1,LSL #16
;;;487            u32RegTALM |= ((sPt->u32Minute / 10ul) << 12);
000072  6961              LDR      r1,[r4,#0x14]
000074  fbb1f3f0          UDIV     r3,r1,r0
000078  ea423203          ORR      r2,r2,r3,LSL #12
;;;488            u32RegTALM |= ((sPt->u32Minute % 10ul) << 8);
00007c  fbb1f3f0          UDIV     r3,r1,r0
000080  fb001113          MLS      r1,r0,r3,r1
000084  ea422201          ORR      r2,r2,r1,LSL #8
;;;489            u32RegTALM |= ((sPt->u32Second / 10ul) << 4);
000088  69a1              LDR      r1,[r4,#0x18]
00008a  fbb1f3f0          UDIV     r3,r1,r0
00008e  ea421203          ORR      r2,r2,r3,LSL #4
;;;490            u32RegTALM |= (sPt->u32Second % 10ul);
000092  fbb1f3f0          UDIV     r3,r1,r0
000096  fb001413          MLS      r4,r0,r3,r1
00009a  4314              ORRS     r4,r4,r2
;;;491    
;;;492            RTC_WaitAccessEnable();
00009c  f7fffffe          BL       RTC_WaitAccessEnable
;;;493            RTC->CALM = (uint32_t)u32RegCALM;
0000a0  622e              STR      r6,[r5,#0x20]
;;;494            RTC_WaitAccessEnable();
0000a2  f7fffffe          BL       RTC_WaitAccessEnable
;;;495            RTC->TALM = (uint32_t)u32RegTALM;
0000a6  61ec              STR      r4,[r5,#0x1c]
                  |L15.168|
;;;496        }
;;;497    }
0000a8  bd70              POP      {r4-r6,pc}
                  |L15.170|
0000aa  f0200001          BIC      r0,r0,#1              ;460
0000ae  6168              STR      r0,[r5,#0x14]         ;460
0000b0  6a20              LDR      r0,[r4,#0x20]         ;465
0000b2  2802              CMP      r0,#2                 ;465
0000b4  d1b1              BNE      |L15.26|
0000b6  6920              LDR      r0,[r4,#0x10]         ;467
0000b8  3014              ADDS     r0,r0,#0x14           ;467
0000ba  6120              STR      r0,[r4,#0x10]         ;467
0000bc  e7ad              B        |L15.26|
;;;498    
                          ENDP

0000be  0000              DCW      0x0000
                  |L15.192|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmDateMask||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmDateMask PROC
;;;669      */
;;;670    void RTC_SetAlarmDateMask(uint8_t u8IsTenYMsk, uint8_t u8IsYMsk, uint8_t u8IsTenMMsk, uint8_t u8IsMMsk, uint8_t u8IsTenDMsk, uint8_t u8IsDMsk)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;671    {
000004  461f              MOV      r7,r3
000006  e9dd8908          LDRD     r8,r9,[sp,#0x20]
00000a  4616              MOV      r6,r2
00000c  460d              MOV      r5,r1
00000e  4604              MOV      r4,r0
;;;672        RTC_WaitAccessEnable();
000010  f7fffffe          BL       RTC_WaitAccessEnable
;;;673        RTC->CAMSK = ((uint32_t)u8IsTenYMsk << RTC_CAMSK_MTENYEAR_Pos) |
000014  0160              LSLS     r0,r4,#5
000016  ea401005          ORR      r0,r0,r5,LSL #4
00001a  ea4000c6          ORR      r0,r0,r6,LSL #3
00001e  ea400187          ORR      r1,r0,r7,LSL #2
000022  ea410048          ORR      r0,r1,r8,LSL #1
000026  4903              LDR      r1,|L16.52|
000028  ea400009          ORR      r0,r0,r9
00002c  6388              STR      r0,[r1,#0x38]
;;;674                     ((uint32_t)u8IsYMsk    << RTC_CAMSK_MYEAR_Pos) |
;;;675                     ((uint32_t)u8IsTenMMsk << RTC_CAMSK_MTENMON_Pos) |
;;;676                     ((uint32_t)u8IsMMsk    << RTC_CAMSK_MMON_Pos) |
;;;677                     ((uint32_t)u8IsTenDMsk << RTC_CAMSK_MTENDAY_Pos) |
;;;678                     ((uint32_t)u8IsDMsk    << RTC_CAMSK_MDAY_Pos);
;;;679    }
00002e  e8bd87f0          POP      {r4-r10,pc}
;;;680    
                          ENDP

000032  0000              DCW      0x0000
                  |L16.52|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmTime||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmTime PROC
;;;620      */
;;;621    void RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm)
000000  b570              PUSH     {r4-r6,lr}
;;;622    {
000002  001d              MOVS     r5,r3
000004  9b04              LDR      r3,[sp,#0x10]
000006  d102              BNE      |L17.14|
;;;623        uint32_t u32RegTALM;
;;;624    
;;;625        /* Important, range of 12-hour PM mode is 21 up to 32 */
;;;626        if((u32TimeMode == RTC_CLOCK_12) && (u32AmPm == RTC_PM))
000008  2b02              CMP      r3,#2
00000a  d100              BNE      |L17.14|
00000c  3014              ADDS     r0,r0,#0x14
                  |L17.14|
;;;627        {
;;;628            u32Hour += 20ul;
;;;629        }
;;;630    
;;;631        u32RegTALM  = ((u32Hour   / 10ul) << 20);
00000e  240a              MOVS     r4,#0xa
000010  fbb0f3f4          UDIV     r3,r0,r4
;;;632        u32RegTALM |= ((u32Hour   % 10ul) << 16);
000014  fbb0f6f4          UDIV     r6,r0,r4
000018  fb040016          MLS      r0,r4,r6,r0
00001c  051b              LSLS     r3,r3,#20             ;631
00001e  ea434000          ORR      r0,r3,r0,LSL #16
;;;633        u32RegTALM |= ((u32Minute / 10ul) << 12);
000022  fbb1f3f4          UDIV     r3,r1,r4
000026  ea403003          ORR      r0,r0,r3,LSL #12
;;;634        u32RegTALM |= ((u32Minute % 10ul) << 8);
00002a  fbb1f3f4          UDIV     r3,r1,r4
00002e  fb041113          MLS      r1,r4,r3,r1
000032  ea402001          ORR      r0,r0,r1,LSL #8
;;;635        u32RegTALM |= ((u32Second / 10ul) << 4);
000036  fbb2f1f4          UDIV     r1,r2,r4
00003a  ea401001          ORR      r0,r0,r1,LSL #4
;;;636        u32RegTALM |= (u32Second % 10ul);
00003e  fbb2f1f4          UDIV     r1,r2,r4
000042  fb042611          MLS      r6,r4,r1,r2
000046  4306              ORRS     r6,r6,r0
;;;637    
;;;638        /*-----------------------------------------------------------------------------------------------------*/
;;;639        /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;640        /*-----------------------------------------------------------------------------------------------------*/
;;;641        RTC_WaitAccessEnable();
000048  f7fffffe          BL       RTC_WaitAccessEnable
;;;642        if(u32TimeMode == RTC_CLOCK_12)
;;;643        {
;;;644            RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00004c  4c06              LDR      r4,|L17.104|
;;;645        }
;;;646        else
;;;647        {
;;;648            RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
00004e  6960              LDR      r0,[r4,#0x14]
000050  b135              CBZ      r5,|L17.96|
000052  f0400001          ORR      r0,r0,#1
                  |L17.86|
000056  6160              STR      r0,[r4,#0x14]
;;;649        }
;;;650    
;;;651        /* Set RTC Alarm Time */
;;;652        RTC_WaitAccessEnable();
000058  f7fffffe          BL       RTC_WaitAccessEnable
;;;653        RTC->TALM = (uint32_t)u32RegTALM;
00005c  61e6              STR      r6,[r4,#0x1c]
;;;654    }
00005e  bd70              POP      {r4-r6,pc}
                  |L17.96|
000060  f0200001          BIC      r0,r0,#1              ;644
000064  e7f7              B        |L17.86|
;;;655    
                          ENDP

000066  0000              DCW      0x0000
                  |L17.104|
                          DCD      0x40041000

                          AREA ||i.RTC_SetAlarmTimeMask||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarmTimeMask PROC
;;;694      */
;;;695    void RTC_SetAlarmTimeMask(uint8_t u8IsTenHMsk, uint8_t u8IsHMsk, uint8_t u8IsTenMMsk, uint8_t u8IsMMsk, uint8_t u8IsTenSMsk, uint8_t u8IsSMsk)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;696    {
000004  461f              MOV      r7,r3
000006  e9dd8908          LDRD     r8,r9,[sp,#0x20]
00000a  4616              MOV      r6,r2
00000c  460d              MOV      r5,r1
00000e  4604              MOV      r4,r0
;;;697        RTC_WaitAccessEnable();
000010  f7fffffe          BL       RTC_WaitAccessEnable
;;;698        RTC->TAMSK = ((uint32_t)u8IsTenHMsk << RTC_TAMSK_MTENHR_Pos) |
000014  0160              LSLS     r0,r4,#5
000016  ea401005          ORR      r0,r0,r5,LSL #4
00001a  ea4000c6          ORR      r0,r0,r6,LSL #3
00001e  ea400187          ORR      r1,r0,r7,LSL #2
000022  ea410048          ORR      r0,r1,r8,LSL #1
000026  4903              LDR      r1,|L18.52|
000028  ea400009          ORR      r0,r0,r9
00002c  6348              STR      r0,[r1,#0x34]
;;;699                     ((uint32_t)u8IsHMsk    << RTC_TAMSK_MHR_Pos) |
;;;700                     ((uint32_t)u8IsTenMMsk << RTC_TAMSK_MTENMIN_Pos) |
;;;701                     ((uint32_t)u8IsMMsk    << RTC_TAMSK_MMIN_Pos) |
;;;702                     ((uint32_t)u8IsTenSMsk << RTC_TAMSK_MTENSEC_Pos) |
;;;703                     ((uint32_t)u8IsSMsk    << RTC_TAMSK_MSEC_Pos);
;;;704    }
00002e  e8bd87f0          POP      {r4-r10,pc}
;;;705    
                          ENDP

000032  0000              DCW      0x0000
                  |L18.52|
                          DCD      0x40041000

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;512      */
;;;513    void RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek)
000000  b570              PUSH     {r4-r6,lr}
;;;514    {
;;;515        uint32_t u32RegCAL;
;;;516    
;;;517        u32RegCAL  = ((u32Year - RTC_YEAR2000) / 10ul) << 20;
000002  240a              MOVS     r4,#0xa
000004  f5a060fa          SUB      r0,r0,#0x7d0
000008  461d              MOV      r5,r3                 ;514
00000a  fbb0f3f4          UDIV     r3,r0,r4
;;;518        u32RegCAL |= (((u32Year - RTC_YEAR2000) % 10ul) << 16);
00000e  fbb0f6f4          UDIV     r6,r0,r4
000012  fb040016          MLS      r0,r4,r6,r0
000016  051b              LSLS     r3,r3,#20             ;517
000018  ea434000          ORR      r0,r3,r0,LSL #16
;;;519        u32RegCAL |= ((u32Month / 10ul) << 12);
00001c  fbb1f3f4          UDIV     r3,r1,r4
000020  ea403003          ORR      r0,r0,r3,LSL #12
;;;520        u32RegCAL |= ((u32Month % 10ul) << 8);
000024  fbb1f3f4          UDIV     r3,r1,r4
000028  fb041113          MLS      r1,r4,r3,r1
00002c  ea402001          ORR      r0,r0,r1,LSL #8
;;;521        u32RegCAL |= ((u32Day   / 10ul) << 4);
000030  fbb2f1f4          UDIV     r1,r2,r4
000034  ea401001          ORR      r0,r0,r1,LSL #4
;;;522        u32RegCAL |= (u32Day   % 10ul);
000038  fbb2f1f4          UDIV     r1,r2,r4
00003c  fb042411          MLS      r4,r4,r1,r2
000040  4304              ORRS     r4,r4,r0
;;;523    
;;;524        /* Set Day of the Week */
;;;525        RTC_WaitAccessEnable();
000042  f7fffffe          BL       RTC_WaitAccessEnable
;;;526        RTC->WEEKDAY = u32DayOfWeek & RTC_WEEKDAY_WEEKDAY_Msk;
000046  f0050007          AND      r0,r5,#7
00004a  4d03              LDR      r5,|L19.88|
00004c  61a8              STR      r0,[r5,#0x18]
;;;527    
;;;528        /* Set RTC Calender Loading */
;;;529        RTC_WaitAccessEnable();
00004e  f7fffffe          BL       RTC_WaitAccessEnable
;;;530        RTC->CAL = (uint32_t)u32RegCAL;
000052  612c              STR      r4,[r5,#0x10]
;;;531    }
000054  bd70              POP      {r4-r6,pc}
;;;532    
                          ENDP

000056  0000              DCW      0x0000
                  |L19.88|
                          DCD      0x40041000

                          AREA ||i.RTC_SetDateAndTime||, CODE, READONLY, ALIGN=2

                  RTC_SetDateAndTime PROC
;;;363      */
;;;364    void RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt)
000000  b570              PUSH     {r4-r6,lr}
;;;365    {
000002  0004              MOVS     r4,r0
000004  d054              BEQ      |L20.176|
;;;366        uint32_t u32RegCAL, u32RegTIME;
;;;367    
;;;368        if(sPt == 0ul)
;;;369        {
;;;370        }
;;;371        else
;;;372        {
;;;373            /*-----------------------------------------------------------------------------------------------------*/
;;;374            /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;375            /*-----------------------------------------------------------------------------------------------------*/
;;;376            RTC_WaitAccessEnable();
000006  f7fffffe          BL       RTC_WaitAccessEnable
;;;377            if(sPt->u32TimeScale == RTC_CLOCK_12)
;;;378            {
;;;379                RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00000a  4d2f              LDR      r5,|L20.200|
00000c  69e0              LDR      r0,[r4,#0x1c]         ;377
00000e  2800              CMP      r0,#0                 ;377
;;;380    
;;;381                /*-------------------------------------------------------------------------------------------------*/
;;;382                /* Important, range of 12-hour PM mode is 21 up to 32                                               */
;;;383                /*-------------------------------------------------------------------------------------------------*/
;;;384                if(sPt->u32AmPm == RTC_PM)
;;;385                {
;;;386                    sPt->u32Hour += 20ul;
;;;387                }
;;;388            }
;;;389            else
;;;390            {
;;;391                RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
000010  6968              LDR      r0,[r5,#0x14]
000012  d04e              BEQ      |L20.178|
000014  f0400001          ORR      r0,r0,#1
000018  6168              STR      r0,[r5,#0x14]
                  |L20.26|
;;;392            }
;;;393    
;;;394            /* Set Day of the Week */
;;;395            RTC_WaitAccessEnable();
00001a  f7fffffe          BL       RTC_WaitAccessEnable
;;;396            RTC->WEEKDAY = sPt->u32DayOfWeek;
00001e  68e0              LDR      r0,[r4,#0xc]
000020  61a8              STR      r0,[r5,#0x18]
;;;397    
;;;398            /*-----------------------------------------------------------------------------------------------------*/
;;;399            /* Set RTC Current Date and Time                                                                       */
;;;400            /*-----------------------------------------------------------------------------------------------------*/
;;;401            u32RegCAL  = ((sPt->u32Year - RTC_YEAR2000) / 10ul) << 20;
000022  6821              LDR      r1,[r4,#0]
000024  200a              MOVS     r0,#0xa
000026  f5a161fa          SUB      r1,r1,#0x7d0
00002a  fbb1f2f0          UDIV     r2,r1,r0
;;;402            u32RegCAL |= (((sPt->u32Year - RTC_YEAR2000) % 10ul) << 16);
00002e  fbb1f3f0          UDIV     r3,r1,r0
000032  fb001113          MLS      r1,r0,r3,r1
000036  0512              LSLS     r2,r2,#20             ;401
000038  ea424201          ORR      r2,r2,r1,LSL #16
;;;403            u32RegCAL |= ((sPt->u32Month  / 10ul) << 12);
00003c  6861              LDR      r1,[r4,#4]
00003e  fbb1f3f0          UDIV     r3,r1,r0
000042  ea423203          ORR      r2,r2,r3,LSL #12
;;;404            u32RegCAL |= ((sPt->u32Month  % 10ul) << 8);
000046  fbb1f3f0          UDIV     r3,r1,r0
00004a  fb001113          MLS      r1,r0,r3,r1
00004e  ea422201          ORR      r2,r2,r1,LSL #8
;;;405            u32RegCAL |= ((sPt->u32Day    / 10ul) << 4);
000052  68a1              LDR      r1,[r4,#8]
000054  fbb1f3f0          UDIV     r3,r1,r0
000058  ea421203          ORR      r2,r2,r3,LSL #4
;;;406            u32RegCAL |= (sPt->u32Day     % 10ul);
00005c  fbb1f3f0          UDIV     r3,r1,r0
000060  fb001613          MLS      r6,r0,r3,r1
;;;407    
;;;408            u32RegTIME  = ((sPt->u32Hour   / 10ul) << 20);
000064  6921              LDR      r1,[r4,#0x10]
000066  4316              ORRS     r6,r6,r2              ;406
000068  fbb1f2f0          UDIV     r2,r1,r0
;;;409            u32RegTIME |= ((sPt->u32Hour   % 10ul) << 16);
00006c  fbb1f3f0          UDIV     r3,r1,r0
000070  fb001113          MLS      r1,r0,r3,r1
000074  0512              LSLS     r2,r2,#20             ;408
000076  ea424201          ORR      r2,r2,r1,LSL #16
;;;410            u32RegTIME |= ((sPt->u32Minute / 10ul) << 12);
00007a  6961              LDR      r1,[r4,#0x14]
00007c  fbb1f3f0          UDIV     r3,r1,r0
000080  ea423203          ORR      r2,r2,r3,LSL #12
;;;411            u32RegTIME |= ((sPt->u32Minute % 10ul) << 8);
000084  fbb1f3f0          UDIV     r3,r1,r0
000088  fb001113          MLS      r1,r0,r3,r1
00008c  ea422201          ORR      r2,r2,r1,LSL #8
;;;412            u32RegTIME |= ((sPt->u32Second / 10ul) << 4);
000090  69a1              LDR      r1,[r4,#0x18]
000092  fbb1f3f0          UDIV     r3,r1,r0
000096  ea421203          ORR      r2,r2,r3,LSL #4
;;;413            u32RegTIME |= (sPt->u32Second % 10ul);
00009a  fbb1f3f0          UDIV     r3,r1,r0
00009e  fb001413          MLS      r4,r0,r3,r1
0000a2  4314              ORRS     r4,r4,r2
;;;414    
;;;415            /*-----------------------------------------------------------------------------------------------------*/
;;;416            /* Set RTC Calender and Time Loading                                                                   */
;;;417            /*-----------------------------------------------------------------------------------------------------*/
;;;418            RTC_WaitAccessEnable();
0000a4  f7fffffe          BL       RTC_WaitAccessEnable
;;;419            RTC->CAL  = (uint32_t)u32RegCAL;
0000a8  612e              STR      r6,[r5,#0x10]
;;;420            RTC_WaitAccessEnable();
0000aa  f7fffffe          BL       RTC_WaitAccessEnable
;;;421            RTC->TIME = (uint32_t)u32RegTIME;
0000ae  60ec              STR      r4,[r5,#0xc]
                  |L20.176|
;;;422        }
;;;423    }
0000b0  bd70              POP      {r4-r6,pc}
                  |L20.178|
0000b2  f0200001          BIC      r0,r0,#1              ;379
0000b6  6168              STR      r0,[r5,#0x14]         ;379
0000b8  6a20              LDR      r0,[r4,#0x20]         ;384
0000ba  2802              CMP      r0,#2                 ;384
0000bc  d1ad              BNE      |L20.26|
0000be  6920              LDR      r0,[r4,#0x10]         ;386
0000c0  3014              ADDS     r0,r0,#0x14           ;386
0000c2  6120              STR      r0,[r4,#0x10]         ;386
0000c4  e7a9              B        |L20.26|
;;;424    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L20.200|
                          DCD      0x40041000

                          AREA ||i.RTC_SetTickPeriod||, CODE, READONLY, ALIGN=2

                  RTC_SetTickPeriod PROC
;;;743      */
;;;744    void RTC_SetTickPeriod(uint32_t u32TickSelection)
000000  b510              PUSH     {r4,lr}
;;;745    {
000002  4604              MOV      r4,r0
;;;746        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;747    
;;;748        RTC->TICK = (RTC->TICK & ~RTC_TICK_TICK_Msk) | u32TickSelection;
000008  4903              LDR      r1,|L21.24|
00000a  6b08              LDR      r0,[r1,#0x30]
00000c  f0200207          BIC      r2,r0,#7
000010  4322              ORRS     r2,r2,r4
000012  630a              STR      r2,[r1,#0x30]
;;;749    }
000014  bd10              POP      {r4,pc}
;;;750    
                          ENDP

000016  0000              DCW      0x0000
                  |L21.24|
                          DCD      0x40041000

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;545      */
;;;546    void RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm)
000000  b570              PUSH     {r4-r6,lr}
;;;547    {
000002  001d              MOVS     r5,r3
000004  9b04              LDR      r3,[sp,#0x10]
000006  d102              BNE      |L22.14|
;;;548        uint32_t u32RegTIME;
;;;549    
;;;550        /* Important, range of 12-hour PM mode is 21 up to 32 */
;;;551        if((u32TimeMode == RTC_CLOCK_12) && (u32AmPm == RTC_PM))
000008  2b02              CMP      r3,#2
00000a  d100              BNE      |L22.14|
00000c  3014              ADDS     r0,r0,#0x14
                  |L22.14|
;;;552        {
;;;553            u32Hour += 20ul;
;;;554        }
;;;555    
;;;556        u32RegTIME  = ((u32Hour   / 10ul) << 20);
00000e  240a              MOVS     r4,#0xa
000010  fbb0f3f4          UDIV     r3,r0,r4
;;;557        u32RegTIME |= ((u32Hour   % 10ul) << 16);
000014  fbb0f6f4          UDIV     r6,r0,r4
000018  fb040016          MLS      r0,r4,r6,r0
00001c  051b              LSLS     r3,r3,#20             ;556
00001e  ea434000          ORR      r0,r3,r0,LSL #16
;;;558        u32RegTIME |= ((u32Minute / 10ul) << 12);
000022  fbb1f3f4          UDIV     r3,r1,r4
000026  ea403003          ORR      r0,r0,r3,LSL #12
;;;559        u32RegTIME |= ((u32Minute % 10ul) << 8);
00002a  fbb1f3f4          UDIV     r3,r1,r4
00002e  fb041113          MLS      r1,r4,r3,r1
000032  ea402001          ORR      r0,r0,r1,LSL #8
;;;560        u32RegTIME |= ((u32Second / 10ul) << 4);
000036  fbb2f1f4          UDIV     r1,r2,r4
00003a  ea401001          ORR      r0,r0,r1,LSL #4
;;;561        u32RegTIME |= (u32Second % 10ul);
00003e  fbb2f1f4          UDIV     r1,r2,r4
000042  fb042611          MLS      r6,r4,r1,r2
000046  4306              ORRS     r6,r6,r0
;;;562    
;;;563        /*-----------------------------------------------------------------------------------------------------*/
;;;564        /* Set RTC 24/12 hour setting and Day of the Week                                                      */
;;;565        /*-----------------------------------------------------------------------------------------------------*/
;;;566        RTC_WaitAccessEnable();
000048  f7fffffe          BL       RTC_WaitAccessEnable
;;;567        if(u32TimeMode == RTC_CLOCK_12)
;;;568        {
;;;569            RTC->CLKFMT &= ~RTC_CLKFMT_24HEN_Msk;
00004c  4c06              LDR      r4,|L22.104|
;;;570        }
;;;571        else
;;;572        {
;;;573            RTC->CLKFMT |= RTC_CLKFMT_24HEN_Msk;
00004e  6960              LDR      r0,[r4,#0x14]
000050  b135              CBZ      r5,|L22.96|
000052  f0400001          ORR      r0,r0,#1
                  |L22.86|
000056  6160              STR      r0,[r4,#0x14]
;;;574        }
;;;575    
;;;576        RTC_WaitAccessEnable();
000058  f7fffffe          BL       RTC_WaitAccessEnable
;;;577        RTC->TIME = (uint32_t)u32RegTIME;
00005c  60e6              STR      r6,[r4,#0xc]
;;;578    }
00005e  bd70              POP      {r4-r6,pc}
                  |L22.96|
000060  f0200001          BIC      r0,r0,#1              ;569
000064  e7f7              B        |L22.86|
;;;579    
                          ENDP

000066  0000              DCW      0x0000
                  |L22.104|
                          DCD      0x40041000

                          AREA ||i.RTC_StaticTamperDisable||, CODE, READONLY, ALIGN=2

                  RTC_StaticTamperDisable PROC
;;;894      */
;;;895    void RTC_StaticTamperDisable(uint32_t u32TamperSelect)
000000  b570              PUSH     {r4-r6,lr}
;;;896    {
000002  4605              MOV      r5,r0
;;;897        uint32_t i;
;;;898        uint32_t u32Reg;
;;;899        uint32_t u32TmpReg;
;;;900    
;;;901        RTC_WaitAccessEnable();
000004  f7fffffe          BL       RTC_WaitAccessEnable
;;;902        u32Reg = RTC->TAMPCTL;
000008  4e0a              LDR      r6,|L23.52|
00000a  f8d64120          LDR      r4,[r6,#0x120]
;;;903    
;;;904        u32TmpReg = (RTC_TAMPCTL_TAMP0EN_Msk);
00000e  15b0              ASRS     r0,r6,#22
;;;905    
;;;906        for(i = 0ul; i < MAX_TAMPER_PIN_NUM; i++)
000010  2100              MOVS     r1,#0
;;;907        {
;;;908            if(u32TamperSelect & (0x1ul << i))
000012  2301              MOVS     r3,#1
                  |L23.20|
000014  fa03f201          LSL      r2,r3,r1
000018  422a              TST      r2,r5
00001a  d003              BEQ      |L23.36|
;;;909            {
;;;910                u32Reg &= ~(u32TmpReg << (i*4ul));
00001c  008a              LSLS     r2,r1,#2
00001e  fa00f202          LSL      r2,r0,r2
000022  4394              BICS     r4,r4,r2
                  |L23.36|
000024  1c49              ADDS     r1,r1,#1
000026  2906              CMP      r1,#6                 ;906
000028  d3f4              BCC      |L23.20|
;;;911            }
;;;912        }
;;;913    
;;;914        RTC_WaitAccessEnable();
00002a  f7fffffe          BL       RTC_WaitAccessEnable
;;;915        RTC->TAMPCTL = u32Reg;
00002e  f8c64120          STR      r4,[r6,#0x120]
;;;916    }
000032  bd70              POP      {r4-r6,pc}
;;;917    
                          ENDP

                  |L23.52|
                          DCD      0x40041000

                          AREA ||i.RTC_StaticTamperEnable||, CODE, READONLY, ALIGN=2

                  RTC_StaticTamperEnable PROC
;;;853      */
;;;854    void RTC_StaticTamperEnable(uint32_t u32TamperSelect, uint32_t u32DetecLevel, uint32_t u32DebounceEn)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;855    {
000004  4690              MOV      r8,r2
000006  460f              MOV      r7,r1
000008  4605              MOV      r5,r0
;;;856        uint32_t i;
;;;857        uint32_t u32Reg;
;;;858        uint32_t u32TmpReg;
;;;859    
;;;860        RTC_WaitAccessEnable();
00000a  f7fffffe          BL       RTC_WaitAccessEnable
;;;861        u32Reg = RTC->TAMPCTL;
00000e  4e11              LDR      r6,|L24.84|
000010  f8d64120          LDR      r4,[r6,#0x120]
;;;862    
;;;863        u32TmpReg = ( RTC_TAMPCTL_TAMP0EN_Msk | (u32DetecLevel << RTC_TAMPCTL_TAMP0LV_Pos) |
000014  0279              LSLS     r1,r7,#9
000016  ea412088          ORR      r0,r1,r8,LSL #10
;;;864                      (u32DebounceEn << RTC_TAMPCTL_TAMP0DBEN_Pos) );
;;;865    
;;;866        for(i = 0ul; i < MAX_TAMPER_PIN_NUM; i++)
00001a  2100              MOVS     r1,#0
00001c  f4407280          ORR      r2,r0,#0x100          ;863
;;;867        {
;;;868            if(u32TamperSelect & (0x1ul << i))
000020  2301              MOVS     r3,#1
;;;869            {
;;;870                u32Reg &= ~((RTC_TAMPCTL_TAMP0EN_Msk|RTC_TAMPCTL_TAMP0LV_Msk|RTC_TAMPCTL_TAMP0DBEN_Msk) << (i*4ul));
000022  f44f67e0          MOV      r7,#0x700
                  |L24.38|
000026  fa03f001          LSL      r0,r3,r1              ;868
00002a  4228              TST      r0,r5                 ;868
00002c  d008              BEQ      |L24.64|
00002e  0088              LSLS     r0,r1,#2
000030  fa07fc00          LSL      r12,r7,r0
000034  ea24040c          BIC      r4,r4,r12
;;;871                u32Reg |= (u32TmpReg << (i*4ul));
000038  fa02fc00          LSL      r12,r2,r0
00003c  ea4c0404          ORR      r4,r12,r4
                  |L24.64|
000040  1c49              ADDS     r1,r1,#1
000042  2906              CMP      r1,#6                 ;866
000044  d3ef              BCC      |L24.38|
;;;872            }
;;;873        }
;;;874    
;;;875        RTC_WaitAccessEnable();
000046  f7fffffe          BL       RTC_WaitAccessEnable
;;;876        RTC->TAMPCTL = u32Reg;
00004a  f8c64120          STR      r4,[r6,#0x120]
;;;877    
;;;878    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;879    
                          ENDP

000052  0000              DCW      0x0000
                  |L24.84|
                          DCD      0x40041000

                          AREA ||i.RTC_WaitAccessEnable||, CODE, READONLY, ALIGN=2

                  RTC_WaitAccessEnable PROC
;;;285      */
;;;286    __STATIC_INLINE void RTC_WaitAccessEnable(void)
000000  4808              LDR      r0,|L25.36|
                  |L25.2|
;;;287    {
;;;288        while((RTC->RWEN & RTC_RWEN_RTCBUSY_Msk) == RTC_RWEN_RTCBUSY_Msk)
000002  6841              LDR      r1,[r0,#4]
000004  01c9              LSLS     r1,r1,#7
000006  d4fc              BMI      |L25.2|
;;;289        {
;;;290        }
;;;291    
;;;292        if(!(SYS->CSERVER & 0x1))
000008  f04f4180          MOV      r1,#0x40000000
00000c  f8d111f4          LDR      r1,[r1,#0x1f4]
000010  07c9              LSLS     r1,r1,#31
000012  d102              BNE      |L25.26|
;;;293        {
;;;294            /* To wait RWENF bit is cleared and enable RWENF bit (Access Enable bit) again */
;;;295            RTC->RWEN = RTC_WRITE_KEY;
000014  f64a1265          MOV      r2,#0xa965
000018  6042              STR      r2,[r0,#4]
                  |L25.26|
;;;296        }
;;;297    
;;;298        /* To wait RWENF bit is set and user can access the protected-register of RTC from now on */
;;;299        while((RTC->RWEN & RTC_RWEN_RWENF_Msk) == (uint32_t)0x0)
00001a  6841              LDR      r1,[r0,#4]
00001c  03c9              LSLS     r1,r1,#15
00001e  d5fc              BPL      |L25.26|
;;;300        {
;;;301        }
;;;302    }
000020  4770              BX       lr
;;;303    
                          ENDP

000022  0000              DCW      0x0000
                  |L25.36|
                          DCD      0x40041000

                          AREA ||.data||, DATA, ALIGN=2

                  g_u32hiYear
                          DCD      0x00000000
                  g_u32loYear
                          DCD      0x00000000
                  g_u32hiMonth
                          DCD      0x00000000
                  g_u32loMonth
                          DCD      0x00000000
                  g_u32hiDay
                          DCD      0x00000000
                  g_u32loDay
                          DCD      0x00000000
                  g_u32hiHour
                          DCD      0x00000000
                  g_u32loHour
                          DCD      0x00000000
                  g_u32hiMin
                          DCD      0x00000000
                  g_u32loMin
                          DCD      0x00000000
                  g_u32hiSec
                          DCD      0x00000000
                  g_u32loSec
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_RTC_Open____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_rtc_c_RTC_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_RTC_Open____REVSH|
#line 402
|__asm___5_rtc_c_RTC_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_RTC_Open____RRX|
#line 587
|__asm___5_rtc_c_RTC_Open____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
