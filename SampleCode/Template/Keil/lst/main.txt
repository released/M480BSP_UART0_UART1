; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -D__FPU_PRESENT=1 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;100    
;;;101    void GPIO_Init(void)
000000  b510              PUSH     {r4,lr}
;;;102    {
;;;103        GPIO_SetMode(PH, BIT0, GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L1.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;104        GPIO_SetMode(PH, BIT1, GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;105        GPIO_SetMode(PH, BIT2, GPIO_MODE_OUTPUT);	
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;106    }
;;;107    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x400041c0

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;286    
;;;287    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;288    {
;;;289    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L2.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;290    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;291    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;292    	
;;;293    }
;;;294    
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.TIMER0_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_Init PROC
;;;92     
;;;93     void TIMER0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;94     {
;;;95         TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L4.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;96         TIMER_EnableInt(TIMER0);
;;;97         NVIC_EnableIRQ(TMR0_IRQn);	
00001a  2020              MOVS     r0,#0x20
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;98         TIMER_Start(TIMER0);
;;;99     }
000028  bd10              POP      {r4,pc}
;;;100    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x40050000

                          AREA ||i.TMR0_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;68     
;;;69     void TMR0_IRQHandler(void)
000000  480b              LDR      r0,|L5.48|
000002  6881              LDR      r1,[r0,#8]
000004  f3c10100          UBFX     r1,r1,#0,#1
;;;70     {
000008  2900              CMP      r1,#0
00000a  d00f              BEQ      |L5.44|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;71     //	static uint16_t cnt_gpio = 0;
;;;72     
;;;73     //	static uint32_t LOG = 0;
;;;74     	static uint16_t CNT = 0;
;;;75     
;;;76     //	uint8_t buffer[16] = {0};
;;;77     
;;;78         if(TIMER_GetIntFlag(TIMER0) == 1)
;;;79         {
;;;80             /* Clear Timer0 time-out interrupt flag */
;;;81             TIMER_ClearIntFlag(TIMER0);
;;;82     
;;;83     		if (CNT++ >= 1000)
000010  4908              LDR      r1,|L5.52|
000012  8808              LDRH     r0,[r1,#0]  ; CNT
000014  1c42              ADDS     r2,r0,#1
000016  800a              STRH     r2,[r1,#0]
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d306              BCC      |L5.44|
;;;84     		{
;;;85     			CNT = 0;
00001e  2000              MOVS     r0,#0
000020  8008              STRH     r0,[r1,#0]
;;;86     //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;87     
;;;88     			LED_G ^= 1;	
000022  4805              LDR      r0,|L5.56|
000024  6801              LDR      r1,[r0,#0]
000026  f0810101          EOR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
                  |L5.44|
;;;89     		}
;;;90         }
;;;91     }
00002c  4770              BX       lr
;;;92     
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      0x40050000
                  |L5.52|
                          DCD      ||area_number.15||
                  |L5.56|
                          DCD      0x400049c8

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_IRQHandler PROC
;;;191    
;;;192    void UART0_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;193    {
;;;194    	uint8_t i;
;;;195    	static uint16_t u16UART_RX_Buffer_Index = 0;
;;;196    
;;;197        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk))    
000002  4d25              LDR      r5,|L6.152|
000004  69e8              LDR      r0,[r5,#0x1c]
;;;198        {
;;;199            /* UART receive data available flag */
;;;200            
;;;201            /* Record RDA interrupt trigger times */
;;;202            uart0Dev.RDA_Trigger_Cnt++;
000006  4c25              LDR      r4,|L6.156|
;;;203            
;;;204            /* Move the data from Rx FIFO to sw buffer (RAM). */
;;;205            /* Every time leave 1 byte data in FIFO for Rx timeout */
;;;206            for(i = 0 ; i < (FIFO_THRESHOLD - 1) ; i++)
;;;207            {
;;;208                uart0Dev.RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
000008  4a25              LDR      r2,|L6.160|
00000a  05c0              LSLS     r0,r0,#23             ;197
00000c  f04f0300          MOV      r3,#0                 ;197
000010  d513              BPL      |L6.58|
000012  f8940102          LDRB     r0,[r4,#0x102]        ;202  ; uart0Dev
000016  1c40              ADDS     r0,r0,#1              ;202
000018  f8840102          STRB     r0,[r4,#0x102]        ;202
00001c  2100              MOVS     r1,#0                 ;206
                  |L6.30|
00001e  682e              LDR      r6,[r5,#0]
000020  8890              LDRH     r0,[r2,#4]  ; u16UART_RX_Buffer_Index
000022  5426              STRB     r6,[r4,r0]
000024  1c40              ADDS     r0,r0,#1
;;;209                u16UART_RX_Buffer_Index ++;
000026  b280              UXTH     r0,r0
000028  8090              STRH     r0,[r2,#4]
;;;210    
;;;211                if (u16UART_RX_Buffer_Index >= RX_BUFFER_SIZE) 
00002a  28ff              CMP      r0,#0xff
00002c  d900              BLS      |L6.48|
;;;212                    u16UART_RX_Buffer_Index = 0;
00002e  8093              STRH     r3,[r2,#4]
                  |L6.48|
000030  1c49              ADDS     r1,r1,#1
000032  b2c9              UXTB     r1,r1                 ;206
000034  2903              CMP      r1,#3                 ;206
000036  d3f2              BCC      |L6.30|
                  |L6.56|
;;;213            }
;;;214        }
;;;215        else if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RXTOINT_Msk)) 
;;;216        {
;;;217            /* When Rx timeout flag is set to 1, it means there is no data needs to be transmitted. */
;;;218    
;;;219            /* Record Timeout times */
;;;220            uart0Dev.RXTO_Trigger_Cnt++;
;;;221    
;;;222            /* Move the last data from Rx FIFO to sw buffer. */
;;;223            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;224            {
;;;225                uart0Dev.RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
;;;226                u16UART_RX_Buffer_Index ++;
;;;227            }
;;;228    
;;;229            /* Clear UART RX parameter */
;;;230            UART_DISABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;231            u16UART_RX_Buffer_Index = 0;
;;;232    
;;;233    //		set_flag(flag_UART0_Received_Data , ENABLE);
;;;234    
;;;235            printf("\nUART0 Rx Received Data : %s\n",uart0Dev.RX_Buffer);
;;;236            printf("UART0 Rx RDA (Fifofull) interrupt times : %d\n",uart0Dev.RDA_Trigger_Cnt);
;;;237            printf("UART0 Rx RXTO (Timeout) interrupt times : %d\n",uart0Dev.RXTO_Trigger_Cnt);
;;;238    
;;;239            /* Reset UART interrupt parameter */
;;;240            UART_EnableInt(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;241    		memset(&uart0Dev, 0x00, sizeof(UART_BUF_t));
;;;242    
;;;243        }
;;;244    	
;;;245    }
000038  bd70              POP      {r4-r6,pc}
                  |L6.58|
00003a  69e8              LDR      r0,[r5,#0x1c]         ;215
00003c  04c0              LSLS     r0,r0,#19             ;215
00003e  d5fb              BPL      |L6.56|
000040  f8940103          LDRB     r0,[r4,#0x103]        ;220  ; uart0Dev
000044  1c40              ADDS     r0,r0,#1              ;220
000046  f8840103          STRB     r0,[r4,#0x103]        ;220
00004a  e004              B        |L6.86|
                  |L6.76|
00004c  6828              LDR      r0,[r5,#0]            ;225
00004e  8891              LDRH     r1,[r2,#4]            ;225  ; u16UART_RX_Buffer_Index
000050  5460              STRB     r0,[r4,r1]            ;225
000052  1c49              ADDS     r1,r1,#1              ;225
000054  8091              STRH     r1,[r2,#4]            ;226
                  |L6.86|
000056  69a8              LDR      r0,[r5,#0x18]         ;223
000058  0440              LSLS     r0,r0,#17             ;223
00005a  d5f7              BPL      |L6.76|
00005c  6868              LDR      r0,[r5,#4]            ;230
00005e  f0200011          BIC      r0,r0,#0x11           ;230
000062  6068              STR      r0,[r5,#4]            ;230
000064  8093              STRH     r3,[r2,#4]            ;231
000066  490d              LDR      r1,|L6.156|
000068  a00e              ADR      r0,|L6.164|
00006a  f7fffffe          BL       __2printf
00006e  f8941102          LDRB     r1,[r4,#0x102]        ;236  ; uart0Dev
000072  a014              ADR      r0,|L6.196|
000074  f7fffffe          BL       __2printf
000078  f8941103          LDRB     r1,[r4,#0x103]        ;237  ; uart0Dev
00007c  a01d              ADR      r0,|L6.244|
00007e  f7fffffe          BL       __2printf
000082  2111              MOVS     r1,#0x11              ;240
000084  4628              MOV      r0,r5                 ;240
000086  f7fffffe          BL       UART_EnableInt
00008a  e8bd4070          POP      {r4-r6,lr}            ;241
00008e  f44f7182          MOV      r1,#0x104             ;241
000092  4802              LDR      r0,|L6.156|
000094  f7ffbffe          B.W      __aeabi_memclr
;;;246    
                          ENDP

                  |L6.152|
                          DCD      0x40070000
                  |L6.156|
                          DCD      ||.bss||
                  |L6.160|
                          DCD      ||area_number.15||
                  |L6.164|
0000a4  0a554152          DCB      "\nUART0 Rx Received Data : %s\n",0
0000a8  54302052
0000ac  78205265
0000b0  63656976
0000b4  65642044
0000b8  61746120
0000bc  3a202573
0000c0  0a00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L6.196|
0000c4  55415254          DCB      "UART0 Rx RDA (Fifofull) interrupt times : %d\n",0
0000c8  30205278
0000cc  20524441
0000d0  20284669
0000d4  666f6675
0000d8  6c6c2920
0000dc  696e7465
0000e0  72727570
0000e4  74207469
0000e8  6d657320
0000ec  3a202564
0000f0  0a00    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L6.244|
0000f4  55415254          DCB      "UART0 Rx RXTO (Timeout) interrupt times : %d\n",0
0000f8  30205278
0000fc  20525854
000100  4f202854
000104  696d656f
000108  75742920
00010c  696e7465
000110  72727570
000114  74207469
000118  6d657320
00011c  3a202564
000120  0a00    
000122  00                DCB      0
000123  00                DCB      0

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;251    
;;;252    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;253    {
;;;254        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;255        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000002  f04f4080          MOV      r0,#0x40000000
000006  6bc1              LDR      r1,[r0,#0x3c]
000008  f421017f          BIC      r1,r1,#0xff0000
00000c  63c1              STR      r1,[r0,#0x3c]
;;;256        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
00000e  6bc1              LDR      r1,[r0,#0x3c]
000010  f44101cc          ORR      r1,r1,#0x660000
000014  63c1              STR      r1,[r0,#0x3c]
;;;257    
;;;258        SYS_ResetModule(UART0_RST);
000016  481e              LDR      r0,|L7.144|
000018  f7fffffe          BL       SYS_ResetModule
;;;259    
;;;260        /* Configure UART0 and set UART0 baud rate */
;;;261        UART_Open(UART0, 115200);
00001c  4c1d              LDR      r4,|L7.148|
00001e  f44f31e1          MOV      r1,#0x1c200
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       UART_Open
;;;262    
;;;263    	/* Set UART receive time-out */
;;;264    	UART_SetTimeoutCnt(UART0, RX_TIMEOUT_CNT);
000028  213c              MOVS     r1,#0x3c
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       UART_SetTimeoutCnt
;;;265    
;;;266    	/* Set UART FIFO RX interrupt trigger level to 4-bytes*/
;;;267        UART0->FIFO = ((UART0->FIFO & (~UART_FIFO_RFITL_Msk)) | UART_FIFO_RFITL_4BYTES);
000030  68a0              LDR      r0,[r4,#8]
000032  f02000f0          BIC      r0,r0,#0xf0
000036  f0400010          ORR      r0,r0,#0x10
00003a  60a0              STR      r0,[r4,#8]
;;;268    
;;;269    	/* Enable UART Interrupt - */
;;;270    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00003c  6860              LDR      r0,[r4,#4]
00003e  f6400111          MOV      r1,#0x811
000042  4308              ORRS     r0,r0,r1
000044  6060              STR      r0,[r4,#4]
;;;271    	
;;;272    	NVIC_EnableIRQ(UART0_IRQn);
000046  2024              MOVS     r0,#0x24
000048  f7fffffe          BL       NVIC_EnableIRQ
;;;273    	
;;;274    	memset(&uart0Dev, 0x00, sizeof(UART_BUF_t));
00004c  f44f7182          MOV      r1,#0x104
000050  4811              LDR      r0,|L7.152|
000052  f7fffffe          BL       __aeabi_memclr
                  |L7.86|
;;;275    
;;;276    	UART_WAIT_TX_EMPTY(UART0);
000056  69a0              LDR      r0,[r4,#0x18]
000058  00c0              LSLS     r0,r0,#3
00005a  d5fc              BPL      |L7.86|
;;;277    	
;;;278    //	set_flag(flag_UART0_Received_Data , DISABLE);
;;;279    
;;;280    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00005c  f7fffffe          BL       CLK_GetCPUFreq
000060  4601              MOV      r1,r0
000062  a00e              ADR      r0,|L7.156|
000064  f7fffffe          BL       __2printf
;;;281    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());	
000068  f7fffffe          BL       CLK_GetHCLKFreq
00006c  4601              MOV      r1,r0
00006e  a012              ADR      r0,|L7.184|
000070  f7fffffe          BL       __2printf
;;;282    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000074  f7fffffe          BL       CLK_GetPCLK0Freq
000078  4601              MOV      r1,r0
00007a  a015              ADR      r0,|L7.208|
00007c  f7fffffe          BL       __2printf
;;;283    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000080  f7fffffe          BL       CLK_GetPCLK1Freq
000084  4601              MOV      r1,r0
000086  e8bd4010          POP      {r4,lr}
00008a  a018              ADR      r0,|L7.236|
00008c  f7ffbffe          B.W      __2printf
;;;284    
;;;285    }
;;;286    
                          ENDP

                  |L7.144|
                          DCD      0x04000010
                  |L7.148|
                          DCD      0x40070000
                  |L7.152|
                          DCD      ||.bss||
                  |L7.156|
00009c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
0000a0  4b5f4765
0000a4  74435055
0000a8  46726571
0000ac  203a2025
0000b0  38640d0a
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L7.184|
0000b8  434c4b5f          DCB      "CLK_GetHCLKFreq : %8d\r\n",0
0000bc  47657448
0000c0  434c4b46
0000c4  72657120
0000c8  3a202538
0000cc  640d0a00
                  |L7.208|
0000d0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d4  47657450
0000d8  434c4b30
0000dc  46726571
0000e0  203a2025
0000e4  38640d0a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L7.236|
0000ec  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f0  47657450
0000f4  434c4b31
0000f8  46726571
0000fc  203a2025
000100  38640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.UART1_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART1_IRQHandler PROC
;;;108    
;;;109    void UART1_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;110    {
;;;111    	uint8_t i;
;;;112    	static uint16_t u16UART_RX_Buffer_Index = 0;
;;;113    
;;;114        if(UART_GET_INT_FLAG(UART1, UART_INTSTS_RDAINT_Msk))    
000002  4d25              LDR      r5,|L8.152|
000004  69e8              LDR      r0,[r5,#0x1c]
;;;115        {
;;;116            /* UART receive data available flag */
;;;117            
;;;118            /* Record RDA interrupt trigger times */
;;;119            uart1Dev.RDA_Trigger_Cnt++;
000006  4c25              LDR      r4,|L8.156|
;;;120            
;;;121            /* Move the data from Rx FIFO to sw buffer (RAM). */
;;;122            /* Every time leave 1 byte data in FIFO for Rx timeout */
;;;123            for(i = 0 ; i < (FIFO_THRESHOLD - 1) ; i++)
;;;124            {
;;;125                uart1Dev.RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART1);
000008  4a25              LDR      r2,|L8.160|
00000a  05c0              LSLS     r0,r0,#23             ;114
00000c  f04f0300          MOV      r3,#0                 ;114
000010  d513              BPL      |L8.58|
000012  f8940102          LDRB     r0,[r4,#0x102]        ;119  ; uart1Dev
000016  1c40              ADDS     r0,r0,#1              ;119
000018  f8840102          STRB     r0,[r4,#0x102]        ;119
00001c  2100              MOVS     r1,#0                 ;123
                  |L8.30|
00001e  682e              LDR      r6,[r5,#0]
000020  8850              LDRH     r0,[r2,#2]  ; u16UART_RX_Buffer_Index
000022  5426              STRB     r6,[r4,r0]
000024  1c40              ADDS     r0,r0,#1
;;;126                u16UART_RX_Buffer_Index ++;
000026  b280              UXTH     r0,r0
000028  8050              STRH     r0,[r2,#2]
;;;127    
;;;128                if (u16UART_RX_Buffer_Index >= RX_BUFFER_SIZE) 
00002a  28ff              CMP      r0,#0xff
00002c  d900              BLS      |L8.48|
;;;129                    u16UART_RX_Buffer_Index = 0;
00002e  8053              STRH     r3,[r2,#2]
                  |L8.48|
000030  1c49              ADDS     r1,r1,#1
000032  b2c9              UXTB     r1,r1                 ;123
000034  2903              CMP      r1,#3                 ;123
000036  d3f2              BCC      |L8.30|
                  |L8.56|
;;;130            }
;;;131        }
;;;132        else if(UART_GET_INT_FLAG(UART1, UART_INTSTS_RXTOINT_Msk)) 
;;;133        {
;;;134            /* When Rx timeout flag is set to 1, it means there is no data needs to be transmitted. */
;;;135    
;;;136            /* Record Timeout times */
;;;137            uart1Dev.RXTO_Trigger_Cnt++;
;;;138    
;;;139            /* Move the last data from Rx FIFO to sw buffer. */
;;;140            while(UART_GET_RX_EMPTY(UART1) == 0)
;;;141            {
;;;142                uart1Dev.RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART1);
;;;143                u16UART_RX_Buffer_Index ++;
;;;144            }
;;;145    
;;;146            /* Clear UART RX parameter */
;;;147            UART_DISABLE_INT(UART1, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;148            u16UART_RX_Buffer_Index = 0;
;;;149    
;;;150    //		set_flag(flag_UART1_Received_Data , ENABLE);
;;;151    
;;;152            printf("\nUART1 Rx Received Data : %s\n",uart1Dev.RX_Buffer);
;;;153            printf("UART1 Rx RDA (Fifofull) interrupt times : %d\n",uart1Dev.RDA_Trigger_Cnt);
;;;154            printf("UART1 Rx RXTO (Timeout) interrupt times : %d\n",uart1Dev.RXTO_Trigger_Cnt);
;;;155    
;;;156            /* Reset UART interrupt parameter */
;;;157            UART_EnableInt(UART1, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;158    		memset(&uart1Dev, 0x00, sizeof(UART_BUF_t));
;;;159    
;;;160        }
;;;161    	
;;;162    }
000038  bd70              POP      {r4-r6,pc}
                  |L8.58|
00003a  69e8              LDR      r0,[r5,#0x1c]         ;132
00003c  04c0              LSLS     r0,r0,#19             ;132
00003e  d5fb              BPL      |L8.56|
000040  f8940103          LDRB     r0,[r4,#0x103]        ;137  ; uart1Dev
000044  1c40              ADDS     r0,r0,#1              ;137
000046  f8840103          STRB     r0,[r4,#0x103]        ;137
00004a  e004              B        |L8.86|
                  |L8.76|
00004c  6828              LDR      r0,[r5,#0]            ;142
00004e  8851              LDRH     r1,[r2,#2]            ;142  ; u16UART_RX_Buffer_Index
000050  5460              STRB     r0,[r4,r1]            ;142
000052  1c49              ADDS     r1,r1,#1              ;142
000054  8051              STRH     r1,[r2,#2]            ;143
                  |L8.86|
000056  69a8              LDR      r0,[r5,#0x18]         ;140
000058  0440              LSLS     r0,r0,#17             ;140
00005a  d5f7              BPL      |L8.76|
00005c  6868              LDR      r0,[r5,#4]            ;147
00005e  f0200011          BIC      r0,r0,#0x11           ;147
000062  6068              STR      r0,[r5,#4]            ;147
000064  8053              STRH     r3,[r2,#2]            ;148
000066  490d              LDR      r1,|L8.156|
000068  a00e              ADR      r0,|L8.164|
00006a  f7fffffe          BL       __2printf
00006e  f8941102          LDRB     r1,[r4,#0x102]        ;153  ; uart1Dev
000072  a014              ADR      r0,|L8.196|
000074  f7fffffe          BL       __2printf
000078  f8941103          LDRB     r1,[r4,#0x103]        ;154  ; uart1Dev
00007c  a01d              ADR      r0,|L8.244|
00007e  f7fffffe          BL       __2printf
000082  2111              MOVS     r1,#0x11              ;157
000084  4628              MOV      r0,r5                 ;157
000086  f7fffffe          BL       UART_EnableInt
00008a  e8bd4070          POP      {r4-r6,lr}            ;158
00008e  f44f7182          MOV      r1,#0x104             ;158
000092  4802              LDR      r0,|L8.156|
000094  f7ffbffe          B.W      __aeabi_memclr
;;;163    
                          ENDP

                  |L8.152|
                          DCD      0x40071000
                  |L8.156|
                          DCD      ||.bss||+0x104
                  |L8.160|
                          DCD      ||area_number.15||
                  |L8.164|
0000a4  0a554152          DCB      "\nUART1 Rx Received Data : %s\n",0
0000a8  54312052
0000ac  78205265
0000b0  63656976
0000b4  65642044
0000b8  61746120
0000bc  3a202573
0000c0  0a00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L8.196|
0000c4  55415254          DCB      "UART1 Rx RDA (Fifofull) interrupt times : %d\n",0
0000c8  31205278
0000cc  20524441
0000d0  20284669
0000d4  666f6675
0000d8  6c6c2920
0000dc  696e7465
0000e0  72727570
0000e4  74207469
0000e8  6d657320
0000ec  3a202564
0000f0  0a00    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L8.244|
0000f4  55415254          DCB      "UART1 Rx RXTO (Timeout) interrupt times : %d\n",0
0000f8  31205278
0000fc  20525854
000100  4f202854
000104  696d656f
000108  75742920
00010c  696e7465
000110  72727570
000114  74207469
000118  6d657320
00011c  3a202564
000120  0a00    
000122  00                DCB      0
000123  00                DCB      0

                          AREA ||i.UART1_Init||, CODE, READONLY, ALIGN=2

                  UART1_Init PROC
;;;164    
;;;165    void UART1_Init(void)	//PB2 , PB3
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167        SYS->GPB_MFPL &= ~(SYS_GPB_MFPL_PB2MFP_Msk | SYS_GPB_MFPL_PB3MFP_Msk);
000002  f04f4080          MOV      r0,#0x40000000
000006  6b81              LDR      r1,[r0,#0x38]
000008  f421417f          BIC      r1,r1,#0xff00
00000c  6381              STR      r1,[r0,#0x38]
;;;168        SYS->GPB_MFPL |= (SYS_GPB_MFPL_PB2MFP_UART1_RXD | SYS_GPB_MFPL_PB3MFP_UART1_TXD);
00000e  6b81              LDR      r1,[r0,#0x38]
000010  f44141cc          ORR      r1,r1,#0x6600
000014  6381              STR      r1,[r0,#0x38]
;;;169    
;;;170        SYS_ResetModule(UART1_RST);
000016  4812              LDR      r0,|L9.96|
000018  f7fffffe          BL       SYS_ResetModule
;;;171    
;;;172        /* Configure UART0 and set UART0 baud rate */
;;;173        UART_Open(UART1, 115200);
00001c  4c11              LDR      r4,|L9.100|
00001e  f44f31e1          MOV      r1,#0x1c200
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       UART_Open
;;;174    
;;;175    	/* Set UART receive time-out */
;;;176    	UART_SetTimeoutCnt(UART1, RX_TIMEOUT_CNT);
000028  213c              MOVS     r1,#0x3c
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       UART_SetTimeoutCnt
;;;177    
;;;178        UART1->FIFO = ((UART1->FIFO & (~UART_FIFO_RFITL_Msk)) | UART_FIFO_RFITL_4BYTES);
000030  68a0              LDR      r0,[r4,#8]
000032  f02000f0          BIC      r0,r0,#0xf0
000036  f0400010          ORR      r0,r0,#0x10
00003a  60a0              STR      r0,[r4,#8]
;;;179    
;;;180    	/* Enable UART Interrupt - */
;;;181    	UART_ENABLE_INT(UART1, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);	
00003c  6860              LDR      r0,[r4,#4]
00003e  f6400111          MOV      r1,#0x811
000042  4308              ORRS     r0,r0,r1
000044  6060              STR      r0,[r4,#4]
;;;182    	NVIC_EnableIRQ(UART1_IRQn);
000046  2025              MOVS     r0,#0x25
000048  f7fffffe          BL       NVIC_EnableIRQ
;;;183    
;;;184    	memset(&uart1Dev, 0x00, sizeof(UART_BUF_t));
00004c  f44f7182          MOV      r1,#0x104
000050  4805              LDR      r0,|L9.104|
000052  f7fffffe          BL       __aeabi_memclr
                  |L9.86|
;;;185    	
;;;186    	UART_WAIT_TX_EMPTY(UART1);
000056  69a0              LDR      r0,[r4,#0x18]
000058  00c0              LSLS     r0,r0,#3
00005a  d5fc              BPL      |L9.86|
;;;187    
;;;188    //	set_flag(flag_UART1_Received_Data , DISABLE);
;;;189    	
;;;190    }
00005c  bd10              POP      {r4,pc}
;;;191    
                          ENDP

00005e  0000              DCW      0x0000
                  |L9.96|
                          DCD      0x04000011
                  |L9.100|
                          DCD      0x40071000
                  |L9.104|
                          DCD      ||.bss||+0x104

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;324    
;;;325    int main()
000000  f7fffffe          BL       SYS_Init
;;;326    {
;;;327        SYS_Init();
;;;328    	
;;;329        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;330        UART1_Init();
000008  f7fffffe          BL       UART1_Init
;;;331    	
;;;332    	GPIO_Init();
00000c  f7fffffe          BL       GPIO_Init
;;;333    	
;;;334    	TIMER0_Init();
000010  f7fffffe          BL       TIMER0_Init
;;;335    	
;;;336        /* Got no where to go, just loop forever */
;;;337        while(1)
;;;338        {
;;;339    		LED_Y ^= 1;
000014  4802              LDR      r0,|L10.32|
                  |L10.22|
000016  6801              LDR      r1,[r0,#0]
000018  f0810101          EOR      r1,r1,#1
00001c  6001              STR      r1,[r0,#0]
00001e  e7fa              B        |L10.22|
;;;340        }
;;;341    
;;;342    }
;;;343    
                          ENDP

                  |L10.32|
                          DCD      0x400049c4

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  uart0Dev
                          %        260
                  uart1Dev
                          %        260

                          AREA ||.data||, DATA, ALIGN=2

                  BitFlag
                          DCD      0x00000000

                          AREA ||area_number.15||, DATA, ALIGN=1

                          EXPORTAS ||area_number.15||, ||.data||
                  ||CNT||
000000  0000              DCW      0x0000
                  u16UART_RX_Buffer_Index
000002  0000              DCW      0x0000
                  |symbol_number.37|
000004  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____RRX|
#line 587
|__asm___6_main_c_BitFlag____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
