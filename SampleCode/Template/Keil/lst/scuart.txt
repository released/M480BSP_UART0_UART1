; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\scuart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\scuart.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -D__FPU_PRESENT=1 --omf_browse=.\obj\scuart.crf ..\..\..\Library\StdDriver\src\scuart.c]
                          THUMB

                          AREA ||i.SCUART_Close||, CODE, READONLY, ALIGN=1

                  SCUART_Close PROC
;;;29       */
;;;30     void SCUART_Close(SC_T* sc)
000000  2100              MOVS     r1,#0
;;;31     {
;;;32         sc->INTEN = 0UL;
000002  6181              STR      r1,[r0,#0x18]
;;;33         sc->UARTCTL = 0UL;
000004  6341              STR      r1,[r0,#0x34]
;;;34         sc->CTL = 0UL;
000006  6041              STR      r1,[r0,#4]
;;;35     
;;;36     }
000008  4770              BX       lr
;;;37     /** @cond HIDDEN_SYMBOLS */
                          ENDP


                          AREA ||i.SCUART_GetClock||, CODE, READONLY, ALIGN=2

                  SCUART_GetClock PROC
;;;42       */
;;;43     static uint32_t SCUART_GetClock(SC_T *sc)
000000  b570              PUSH     {r4-r6,lr}
;;;44     {
;;;45         uint32_t u32ClkSrc, u32Num, u32Clk;
;;;46     
;;;47         if(sc == SC0)
000002  4916              LDR      r1,|L2.92|
000004  4288              CMP      r0,r1
000006  d101              BNE      |L2.12|
;;;48         {
;;;49             u32Num = 0UL;
000008  2400              MOVS     r4,#0
00000a  e005              B        |L2.24|
                  |L2.12|
;;;50         }
;;;51         else if(sc == SC1)
00000c  4914              LDR      r1,|L2.96|
00000e  4288              CMP      r0,r1
000010  d101              BNE      |L2.22|
;;;52         {
;;;53             u32Num = 1UL;
000012  2401              MOVS     r4,#1
000014  e000              B        |L2.24|
                  |L2.22|
;;;54         }
;;;55         else
;;;56         {
;;;57             u32Num = 2UL;
000016  2402              MOVS     r4,#2
                  |L2.24|
;;;58         }
;;;59     
;;;60         u32ClkSrc = (CLK->CLKSEL3 >> (2UL * u32Num)) & CLK_CLKSEL3_SC0SEL_Msk;
000018  f04f4580          MOV      r5,#0x40000000
00001c  f8d5021c          LDR      r0,[r5,#0x21c]
000020  0061              LSLS     r1,r4,#1
000022  40c8              LSRS     r0,r0,r1
000024  f0100103          ANDS     r1,r0,#3
;;;61     
;;;62         /* Get smartcard module clock */
;;;63         if(u32ClkSrc == 0UL)
;;;64         {
;;;65             u32Clk = __HXT;
000028  480e              LDR      r0,|L2.100|
00002a  d00b              BEQ      |L2.68|
;;;66         }
;;;67         else if(u32ClkSrc == 1UL)
00002c  2901              CMP      r1,#1
00002e  d002              BEQ      |L2.54|
;;;68         {
;;;69             u32Clk = CLK_GetPLLClockFreq();
;;;70         }
;;;71         else if(u32ClkSrc == 2UL)
000030  2902              CMP      r1,#2
000032  d003              BEQ      |L2.60|
000034  e006              B        |L2.68|
                  |L2.54|
000036  f7fffffe          BL       CLK_GetPLLClockFreq
00003a  e003              B        |L2.68|
                  |L2.60|
;;;72         {
;;;73             if(u32Num == 1UL)
00003c  2c01              CMP      r4,#1
00003e  d00a              BEQ      |L2.86|
;;;74             {
;;;75                 u32Clk = CLK_GetPCLK1Freq();
;;;76             }
;;;77             else
;;;78             {
;;;79                 u32Clk = CLK_GetPCLK0Freq();
000040  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L2.68|
;;;80             }
;;;81         }
;;;82         else
;;;83         {
;;;84             u32Clk = __HIRC;
;;;85         }
;;;86     
;;;87         u32Clk /= (((CLK->CLKDIV1 >> (8UL * u32Num)) & CLK_CLKDIV1_SC0DIV_Msk) + 1UL);
000044  f8d51224          LDR      r1,[r5,#0x224]
000048  00e2              LSLS     r2,r4,#3
00004a  40d1              LSRS     r1,r1,r2
00004c  b2c9              UXTB     r1,r1
00004e  1c49              ADDS     r1,r1,#1
000050  fbb0f0f1          UDIV     r0,r0,r1
;;;88     
;;;89     
;;;90         return u32Clk;
;;;91     }
000054  bd70              POP      {r4-r6,pc}
                  |L2.86|
000056  f7fffffe          BL       CLK_GetPCLK1Freq
00005a  e7f3              B        |L2.68|
;;;92     
                          ENDP

                  |L2.92|
                          DCD      0x40090000
                  |L2.96|
                          DCD      0x40091000
                  |L2.100|
                          DCD      0x00b71b00

                          AREA ||i.SCUART_Open||, CODE, READONLY, ALIGN=1

                  SCUART_Open PROC
;;;107      */
;;;108    uint32_t SCUART_Open(SC_T* sc, uint32_t u32baudrate)
000000  b570              PUSH     {r4-r6,lr}
;;;109    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;110        uint32_t u32Clk = SCUART_GetClock(sc), u32Div;
000006  f7fffffe          BL       SCUART_GetClock
;;;111    
;;;112        /* Calculate divider for target baudrate */
;;;113        u32Div = (u32Clk + (u32baudrate >> 1) - 1UL) / u32baudrate - 1UL;
00000a  eb000155          ADD      r1,r0,r5,LSR #1
00000e  1e49              SUBS     r1,r1,#1
000010  fbb1f1f5          UDIV     r1,r1,r5
;;;114    
;;;115        /* Enable smartcard interface and stop bit = 1 */
;;;116        sc->CTL = SC_CTL_SCEN_Msk | SC_CTL_NSB_Msk;
000014  f2480201          MOV      r2,#0x8001
000018  6062              STR      r2,[r4,#4]
;;;117        /* Enable UART mode, disable parity and 8 bit per character */
;;;118        sc->UARTCTL = SCUART_CHAR_LEN_8 | SCUART_PARITY_NONE | SC_UARTCTL_UARTEN_Msk;
00001a  2241              MOVS     r2,#0x41
00001c  6362              STR      r2,[r4,#0x34]
00001e  1e49              SUBS     r1,r1,#1
;;;119        sc->ETUCTL = u32Div;
000020  6161              STR      r1,[r4,#0x14]
000022  1c49              ADDS     r1,r1,#1
;;;120    
;;;121        return(u32Clk / (u32Div + 1UL));
000024  fbb0f0f1          UDIV     r0,r0,r1
;;;122    }
000028  bd70              POP      {r4-r6,pc}
;;;123    
                          ENDP


                          AREA ||i.SCUART_Read||, CODE, READONLY, ALIGN=1

                  SCUART_Read PROC
;;;131      */
;;;132    uint32_t SCUART_Read(SC_T* sc, uint8_t pu8RxBuf[], uint32_t u32ReadBytes)
000000  b510              PUSH     {r4,lr}
;;;133    {
000002  4603              MOV      r3,r0
;;;134        uint32_t u32Count;
;;;135    
;;;136        for(u32Count = 0UL; u32Count < u32ReadBytes; u32Count++)
000004  2000              MOVS     r0,#0
000006  e005              B        |L4.20|
                  |L4.8|
;;;137        {
;;;138            if(SCUART_GET_RX_EMPTY(sc))   /* no data available */
000008  6a1c              LDR      r4,[r3,#0x20]
00000a  07a4              LSLS     r4,r4,#30
00000c  d404              BMI      |L4.24|
;;;139            {
;;;140                break;
;;;141            }
;;;142            pu8RxBuf[u32Count] = (uint8_t)SCUART_READ(sc);    /* get data from FIFO */
00000e  681c              LDR      r4,[r3,#0]
000010  540c              STRB     r4,[r1,r0]
000012  1c40              ADDS     r0,r0,#1
                  |L4.20|
000014  4290              CMP      r0,r2                 ;136
000016  d3f7              BCC      |L4.8|
                  |L4.24|
;;;143        }
;;;144    
;;;145        return u32Count;
;;;146    }
000018  bd10              POP      {r4,pc}
;;;147    
                          ENDP


                          AREA ||i.SCUART_SetLineConfig||, CODE, READONLY, ALIGN=1

                  SCUART_SetLineConfig PROC
;;;170      */
;;;171    uint32_t SCUART_SetLineConfig(SC_T* sc, uint32_t u32Baudrate, uint32_t u32DataWidth, uint32_t u32Parity, uint32_t  u32StopBits)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;172    {
000004  461d              MOV      r5,r3
000006  4616              MOV      r6,r2
000008  460f              MOV      r7,r1
00000a  4604              MOV      r4,r0
;;;173    
;;;174        uint32_t u32Clk = SCUART_GetClock(sc), u32Div;
00000c  f8dd8018          LDR      r8,[sp,#0x18]
000010  f7fffffe          BL       SCUART_GetClock
;;;175    
;;;176        if(u32Baudrate == 0UL)    /* keep original baudrate setting */
000014  b197              CBZ      r7,|L5.60|
;;;177        {
;;;178            u32Div = sc->ETUCTL & SC_ETUCTL_ETURDIV_Msk;
;;;179        }
;;;180        else
;;;181        {
;;;182            /* Calculate divider for target baudrate */
;;;183            u32Div = (u32Clk + (u32Baudrate >> 1) - 1UL)/ u32Baudrate - 1UL;
000016  eb000157          ADD      r1,r0,r7,LSR #1
00001a  1e49              SUBS     r1,r1,#1
00001c  fbb1f1f7          UDIV     r1,r1,r7
000020  1e49              SUBS     r1,r1,#1
;;;184            sc->ETUCTL = u32Div;
000022  6161              STR      r1,[r4,#0x14]
                  |L5.36|
;;;185        }
;;;186        /* Set stop bit */
;;;187        sc->CTL = u32StopBits | SC_CTL_SCEN_Msk;
000024  f0480201          ORR      r2,r8,#1
000028  6062              STR      r2,[r4,#4]
;;;188        /* Set character width and parity */
;;;189        sc->UARTCTL = u32Parity | u32DataWidth | SC_UARTCTL_UARTEN_Msk;
00002a  4335              ORRS     r5,r5,r6
00002c  f0450201          ORR      r2,r5,#1
000030  6362              STR      r2,[r4,#0x34]
000032  1c49              ADDS     r1,r1,#1
;;;190    
;;;191        return(u32Clk / (u32Div + 1UL));
000034  fbb0f0f1          UDIV     r0,r0,r1
;;;192    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L5.60|
00003c  6961              LDR      r1,[r4,#0x14]         ;178
00003e  f3c1010b          UBFX     r1,r1,#0,#12          ;178
000042  e7ef              B        |L5.36|
;;;193    
                          ENDP


                          AREA ||i.SCUART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  SCUART_SetTimeoutCnt PROC
;;;203      */
;;;204    void SCUART_SetTimeoutCnt(SC_T* sc, uint32_t u32TOC)
000000  6101              STR      r1,[r0,#0x10]
;;;205    {
;;;206        sc->RXTOUT= u32TOC;
;;;207    }
000002  4770              BX       lr
;;;208    
                          ENDP


                          AREA ||i.SCUART_Write||, CODE, READONLY, ALIGN=1

                  SCUART_Write PROC
;;;217      */
;;;218    void SCUART_Write(SC_T* sc,uint8_t pu8TxBuf[], uint32_t u32WriteBytes)
000000  b510              PUSH     {r4,lr}
;;;219    {
;;;220        uint32_t u32Count;
;;;221    
;;;222        for(u32Count = 0UL; u32Count != u32WriteBytes; u32Count++)
000002  2300              MOVS     r3,#0
000004  e005              B        |L7.18|
                  |L7.6|
;;;223        {
;;;224            /* Wait 'til FIFO not full */
;;;225            while(SCUART_GET_TX_FULL(sc))
000006  6a04              LDR      r4,[r0,#0x20]
000008  0564              LSLS     r4,r4,#21
00000a  d4fc              BMI      |L7.6|
;;;226            {
;;;227                ;
;;;228            }
;;;229            /* Write 1 byte to FIFO */
;;;230            sc->DAT = pu8TxBuf[u32Count];
00000c  5ccc              LDRB     r4,[r1,r3]
00000e  6004              STR      r4,[r0,#0]
000010  1c5b              ADDS     r3,r3,#1
                  |L7.18|
000012  4293              CMP      r3,r2                 ;222
000014  d1f7              BNE      |L7.6|
;;;231        }
;;;232    }
000016  bd10              POP      {r4,pc}
;;;233    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\scuart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_scuart_c_c0edb1d5____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_scuart_c_c0edb1d5____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_scuart_c_c0edb1d5____REVSH|
#line 402
|__asm___8_scuart_c_c0edb1d5____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_scuart_c_c0edb1d5____RRX|
#line 587
|__asm___8_scuart_c_c0edb1d5____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
