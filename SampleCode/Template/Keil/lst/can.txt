; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\can.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\can.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -D__FPU_PRESENT=1 --omf_browse=.\obj\can.crf ..\..\..\Library\StdDriver\src\can.c]
                          THUMB

                          AREA ||i.CAN_BasicReceiveMsg||, CODE, READONLY, ALIGN=1

                  CAN_BasicReceiveMsg PROC
;;;468      */
;;;469    int32_t CAN_BasicReceiveMsg(CAN_T *tCAN, STR_CANMSG_T* pCanMsg)
000000  b510              PUSH     {r4,lr}
;;;470    {
;;;471        int32_t rev = 1l;
;;;472    
;;;473        if((tCAN->IF[1].MCON & CAN_IF_MCON_NEWDAT_Msk) == 0ul)
000002  f8d03098          LDR      r3,[r0,#0x98]
000006  2201              MOVS     r2,#1                 ;471
000008  041b              LSLS     r3,r3,#16
00000a  d401              BMI      |L1.16|
;;;474        {
;;;475            /* In basic mode, receive data always save in IF2 */
;;;476            rev = 0; /* return FALSE */
00000c  2200              MOVS     r2,#0
00000e  e03a              B        |L1.134|
                  |L1.16|
;;;477        }
;;;478        else
;;;479        {
;;;480    
;;;481            tCAN->STATUS &= (~CAN_STATUS_RXOK_Msk);
000010  6843              LDR      r3,[r0,#4]
000012  f0230310          BIC      r3,r3,#0x10
000016  6043              STR      r3,[r0,#4]
;;;482    
;;;483            tCAN->IF[1].CMASK = CAN_IF_CMASK_ARB_Msk
000018  2333              MOVS     r3,#0x33
00001a  f8c03084          STR      r3,[r0,#0x84]
;;;484                                | CAN_IF_CMASK_CONTROL_Msk
;;;485                                | CAN_IF_CMASK_DATAA_Msk
;;;486                                | CAN_IF_CMASK_DATAB_Msk;
;;;487    
;;;488            if((tCAN->IF[1].ARB2 & CAN_IF_ARB2_XTD_Msk) == 0ul)
00001e  f8d03094          LDR      r3,[r0,#0x94]
000022  045b              LSLS     r3,r3,#17
000024  d406              BMI      |L1.52|
;;;489            {
;;;490                /* standard ID*/
;;;491                pCanMsg->IdType = CAN_STD_ID;
000026  2300              MOVS     r3,#0
;;;492                pCanMsg->Id = (tCAN->IF[1].ARB2 >> 2) & 0x07FFul;
000028  600b              STR      r3,[r1,#0]
00002a  f8d03094          LDR      r3,[r0,#0x94]
00002e  f3c3038a          UBFX     r3,r3,#2,#11
000032  e009              B        |L1.72|
                  |L1.52|
;;;493    
;;;494            }
;;;495            else
;;;496            {
;;;497                /* extended ID*/
;;;498                pCanMsg->IdType = CAN_EXT_ID;
000034  2301              MOVS     r3,#1
;;;499                pCanMsg->Id  = (tCAN->IF[1].ARB2 & 0x1FFFul) << 16;
000036  600b              STR      r3,[r1,#0]
000038  f8d03094          LDR      r3,[r0,#0x94]
00003c  04db              LSLS     r3,r3,#19
00003e  08db              LSRS     r3,r3,#3
;;;500                pCanMsg->Id |= (uint32_t)tCAN->IF[1].ARB1;
000040  608b              STR      r3,[r1,#8]
000042  f8d04090          LDR      r4,[r0,#0x90]
000046  4323              ORRS     r3,r3,r4
                  |L1.72|
;;;501            }
;;;502    
;;;503            pCanMsg->FrameType = (((tCAN->IF[1].ARB2 & CAN_IF_ARB2_DIR_Msk) >> CAN_IF_ARB2_DIR_Pos)) ? 0ul : 1ul;
000048  608b              STR      r3,[r1,#8]
00004a  f8503f94          LDR      r3,[r0,#0x94]!
00004e  f3433340          SBFX     r3,r3,#13,#1
000052  1c5b              ADDS     r3,r3,#1
;;;504    
;;;505            pCanMsg->DLC     = (uint8_t)(tCAN->IF[1].MCON & CAN_IF_MCON_DLC_Msk);
000054  604b              STR      r3,[r1,#4]
000056  6843              LDR      r3,[r0,#4]
000058  f003030f          AND      r3,r3,#0xf
00005c  730b              STRB     r3,[r1,#0xc]
;;;506            pCanMsg->Data[0] = (uint8_t)(tCAN->IF[1].DAT_A1 & CAN_IF_DAT_A1_DATA0_Msk);
00005e  6883              LDR      r3,[r0,#8]
000060  734b              STRB     r3,[r1,#0xd]
;;;507            pCanMsg->Data[1] = (uint8_t)((tCAN->IF[1].DAT_A1 & CAN_IF_DAT_A1_DATA1_Msk) >> CAN_IF_DAT_A1_DATA1_Pos);
000062  6883              LDR      r3,[r0,#8]
000064  0a1b              LSRS     r3,r3,#8
000066  738b              STRB     r3,[r1,#0xe]
;;;508            pCanMsg->Data[2] = (uint8_t)(tCAN->IF[1].DAT_A2 & CAN_IF_DAT_A2_DATA2_Msk);
000068  68c3              LDR      r3,[r0,#0xc]
00006a  73cb              STRB     r3,[r1,#0xf]
;;;509            pCanMsg->Data[3] = (uint8_t)((tCAN->IF[1].DAT_A2 & CAN_IF_DAT_A2_DATA3_Msk) >> CAN_IF_DAT_A2_DATA3_Pos);
00006c  68c3              LDR      r3,[r0,#0xc]
00006e  0a1b              LSRS     r3,r3,#8
000070  740b              STRB     r3,[r1,#0x10]
;;;510            pCanMsg->Data[4] = (uint8_t)(tCAN->IF[1].DAT_B1 & CAN_IF_DAT_B1_DATA4_Msk);
000072  6903              LDR      r3,[r0,#0x10]
000074  744b              STRB     r3,[r1,#0x11]
;;;511            pCanMsg->Data[5] = (uint8_t)((tCAN->IF[1].DAT_B1 & CAN_IF_DAT_B1_DATA5_Msk) >> CAN_IF_DAT_B1_DATA5_Pos);
000076  6903              LDR      r3,[r0,#0x10]
000078  0a1b              LSRS     r3,r3,#8
00007a  748b              STRB     r3,[r1,#0x12]
;;;512            pCanMsg->Data[6] = (uint8_t)(tCAN->IF[1].DAT_B2 & CAN_IF_DAT_B2_DATA6_Msk);
00007c  6943              LDR      r3,[r0,#0x14]
00007e  74cb              STRB     r3,[r1,#0x13]
;;;513            pCanMsg->Data[7] = (uint8_t)((tCAN->IF[1].DAT_B2 & CAN_IF_DAT_B2_DATA7_Msk) >> CAN_IF_DAT_B2_DATA7_Pos);
000080  6940              LDR      r0,[r0,#0x14]
000082  0a00              LSRS     r0,r0,#8
000084  7508              STRB     r0,[r1,#0x14]
                  |L1.134|
;;;514        }
;;;515    
;;;516        return rev;
000086  4610              MOV      r0,r2
;;;517    }
000088  bd10              POP      {r4,pc}
;;;518    
                          ENDP


                          AREA ||i.CAN_BasicSendMsg||, CODE, READONLY, ALIGN=2

                  CAN_BasicSendMsg PROC
;;;383      */
;;;384    int32_t CAN_BasicSendMsg(CAN_T *tCAN, STR_CANMSG_T* pCanMsg)
000000  b510              PUSH     {r4,lr}
;;;385    {
;;;386        uint32_t i = 0ul;
;;;387        int32_t rev = 1l;
000002  2201              MOVS     r2,#1
                  |L2.4|
;;;388    
;;;389        while(tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk)
000004  6a03              LDR      r3,[r0,#0x20]
000006  041b              LSLS     r3,r3,#16
000008  d4fc              BMI      |L2.4|
;;;390        {
;;;391        }
;;;392    
;;;393        tCAN->STATUS &= (~CAN_STATUS_TXOK_Msk);
00000a  6843              LDR      r3,[r0,#4]
00000c  f0230308          BIC      r3,r3,#8
000010  6043              STR      r3,[r0,#4]
;;;394    
;;;395        if(pCanMsg->IdType == CAN_STD_ID)
000012  680b              LDR      r3,[r1,#0]
000014  b17b              CBZ      r3,|L2.54|
;;;396        {
;;;397            /* standard ID*/
;;;398            tCAN->IF[0].ARB1 = 0ul;
;;;399            tCAN->IF[0].ARB2 = (((pCanMsg->Id) & 0x7FFul) << 2ul) ;
;;;400        }
;;;401        else
;;;402        {
;;;403            /* extended ID*/
;;;404            tCAN->IF[0].ARB1 = (pCanMsg->Id) & 0xFFFFul;
000016  890b              LDRH     r3,[r1,#8]
000018  b29b              UXTH     r3,r3
00001a  6303              STR      r3,[r0,#0x30]
;;;405            tCAN->IF[0].ARB2 = ((pCanMsg->Id) & 0x1FFF0000ul) >> 16ul  | CAN_IF_ARB2_XTD_Msk;
00001c  688b              LDR      r3,[r1,#8]
00001e  f3c3430c          UBFX     r3,r3,#16,#13
000022  f4434380          ORR      r3,r3,#0x4000
                  |L2.38|
000026  6343              STR      r3,[r0,#0x34]
;;;406    
;;;407        }
;;;408    
;;;409        if(pCanMsg->FrameType)
000028  684b              LDR      r3,[r1,#4]
00002a  2b00              CMP      r3,#0
;;;410        {
;;;411            tCAN->IF[0].ARB2 |= CAN_IF_ARB2_DIR_Msk;
;;;412        }
;;;413        else
;;;414        {
;;;415            tCAN->IF[0].ARB2 &= (~CAN_IF_ARB2_DIR_Msk);
00002c  6b43              LDR      r3,[r0,#0x34]
00002e  d008              BEQ      |L2.66|
000030  f4435300          ORR      r3,r3,#0x2000         ;411
000034  e007              B        |L2.70|
                  |L2.54|
000036  2300              MOVS     r3,#0                 ;398
000038  6303              STR      r3,[r0,#0x30]         ;398
00003a  890b              LDRH     r3,[r1,#8]            ;399
00003c  055b              LSLS     r3,r3,#21             ;399
00003e  0cdb              LSRS     r3,r3,#19             ;399
000040  e7f1              B        |L2.38|
                  |L2.66|
000042  f4235300          BIC      r3,r3,#0x2000
                  |L2.70|
000046  6343              STR      r3,[r0,#0x34]
;;;416        }
;;;417    
;;;418        tCAN->IF[0].MCON = (tCAN->IF[0].MCON & (~CAN_IF_MCON_DLC_Msk)) | pCanMsg->DLC;
000048  6b83              LDR      r3,[r0,#0x38]
00004a  7b0c              LDRB     r4,[r1,#0xc]
00004c  f023030f          BIC      r3,r3,#0xf
000050  4323              ORRS     r3,r3,r4
000052  6383              STR      r3,[r0,#0x38]
;;;419        tCAN->IF[0].DAT_A1 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[1] << 8) | pCanMsg->Data[0]);
000054  f8313f0d          LDRH     r3,[r1,#0xd]!
000058  63c3              STR      r3,[r0,#0x3c]
;;;420        tCAN->IF[0].DAT_A2 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[3] << 8) | pCanMsg->Data[2]);
00005a  884b              LDRH     r3,[r1,#2]
00005c  6403              STR      r3,[r0,#0x40]
;;;421        tCAN->IF[0].DAT_B1 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[5] << 8) | pCanMsg->Data[4]);
00005e  888b              LDRH     r3,[r1,#4]
000060  6443              STR      r3,[r0,#0x44]
;;;422        tCAN->IF[0].DAT_B2 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[7] << 8) | pCanMsg->Data[6]);
000062  88c9              LDRH     r1,[r1,#6]
000064  6481              STR      r1,[r0,#0x48]
;;;423    
;;;424        /* request transmission*/
;;;425        tCAN->IF[0].CREQ &= (~CAN_IF_CREQ_BUSY_Msk);
000066  6a01              LDR      r1,[r0,#0x20]
000068  f4214100          BIC      r1,r1,#0x8000
00006c  6201              STR      r1,[r0,#0x20]
;;;426        if(tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk)
00006e  6a01              LDR      r1,[r0,#0x20]
000070  0409              LSLS     r1,r1,#16
000072  d40d              BMI      |L2.144|
;;;427        {
;;;428            /* Cannot clear busy for sending ...*/
;;;429            rev = 0l; /* return FALSE */
;;;430        }
;;;431        else
;;;432        {
;;;433            tCAN->IF[0].CREQ |= CAN_IF_CREQ_BUSY_Msk;  /* sending */
000074  6a01              LDR      r1,[r0,#0x20]
000076  f4414100          ORR      r1,r1,#0x8000
00007a  6201              STR      r1,[r0,#0x20]
;;;434    
;;;435            for(i = 0ul; i < 0xFFFFFul; i++)
00007c  4b06              LDR      r3,|L2.152|
00007e  2100              MOVS     r1,#0
                  |L2.128|
;;;436            {
;;;437                if((tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0ul)
000080  6a04              LDR      r4,[r0,#0x20]
000082  0424              LSLS     r4,r4,#16
000084  d502              BPL      |L2.140|
000086  1c49              ADDS     r1,r1,#1
000088  4299              CMP      r1,r3                 ;435
00008a  d3f9              BCC      |L2.128|
                  |L2.140|
;;;438                {
;;;439                    break;
;;;440                }
;;;441                else
;;;442                {
;;;443                }
;;;444            }
;;;445    
;;;446            if(i >= 0xFFFFFul)
00008c  4299              CMP      r1,r3
00008e  d300              BCC      |L2.146|
                  |L2.144|
;;;447            {
;;;448                /* Cannot send out... */
;;;449                rev = 0l; /* return FALSE */
000090  2200              MOVS     r2,#0
                  |L2.146|
;;;450            }
;;;451            else
;;;452            {
;;;453            }
;;;454        }
;;;455    
;;;456        return rev;
000092  4610              MOV      r0,r2
;;;457    }
000094  bd10              POP      {r4,pc}
;;;458    
                          ENDP

000096  0000              DCW      0x0000
                  |L2.152|
                          DCD      0x000fffff

                          AREA ||i.CAN_CLR_INT_PENDING_BIT||, CODE, READONLY, ALIGN=1

                  CAN_CLR_INT_PENDING_BIT PROC
;;;1264     */
;;;1265   void CAN_CLR_INT_PENDING_BIT(CAN_T *tCAN, uint8_t u32MsgNum)
000000  b570              PUSH     {r4-r6,lr}
;;;1266   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;1267       uint32_t u32MsgIfNum;
;;;1268   
;;;1269       if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
000006  f7fffffe          BL       LockIF_TL
00000a  4601              MOV      r1,r0
00000c  2802              CMP      r0,#2
00000e  d100              BNE      |L3.18|
;;;1270       {
;;;1271           u32MsgIfNum = 0ul;
000010  2100              MOVS     r1,#0
                  |L3.18|
;;;1272       }
;;;1273       else
;;;1274       {
;;;1275       }
;;;1276   
;;;1277       tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_CLRINTPND_Msk | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
000012  eb010041          ADD      r0,r1,r1,LSL #1
000016  eb051040          ADD      r0,r5,r0,LSL #5
00001a  220c              MOVS     r2,#0xc
00001c  6242              STR      r2,[r0,#0x24]
00001e  1c64              ADDS     r4,r4,#1
;;;1278       tCAN->IF[u32MsgIfNum].CREQ = 1ul + u32MsgNum;
000020  6204              STR      r4,[r0,#0x20]
;;;1279   
;;;1280       ReleaseIF(tCAN, u32MsgIfNum);
000022  4628              MOV      r0,r5
000024  e8bd4070          POP      {r4-r6,lr}
000028  f7ffbffe          B.W      ReleaseIF
;;;1281   }
;;;1282   
                          ENDP


                          AREA ||i.CAN_Close||, CODE, READONLY, ALIGN=1

                  CAN_Close PROC
;;;878      */
;;;879    void CAN_Close(CAN_T *tCAN)
000000  6801              LDR      r1,[r0,#0]
000002  f021010e          BIC      r1,r1,#0xe
000006  6001              STR      r1,[r0,#0]
;;;880    {
;;;881        CAN_DisableInt(tCAN, (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk));
;;;882    }
000008  4770              BX       lr
;;;883    
                          ENDP


                          AREA ||i.CAN_DisableInt||, CODE, READONLY, ALIGN=1

                  CAN_DisableInt PROC
;;;1050     */
;;;1051   void CAN_DisableInt(CAN_T *tCAN, uint32_t u32Mask)
000000  6802              LDR      r2,[r0,#0]
;;;1052   {
;;;1053       tCAN->CON = tCAN->CON & ~((u32Mask & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk)));
000002  f001010e          AND      r1,r1,#0xe
000006  438a              BICS     r2,r2,r1
000008  6002              STR      r2,[r0,#0]
;;;1054   }
00000a  4770              BX       lr
;;;1055   
                          ENDP


                          AREA ||i.CAN_EnableInt||, CODE, READONLY, ALIGN=1

                  CAN_EnableInt PROC
;;;1034     */
;;;1035   void CAN_EnableInt(CAN_T *tCAN, uint32_t u32Mask)
000000  6802              LDR      r2,[r0,#0]
;;;1036   {
;;;1037       tCAN->CON = (tCAN->CON & ~(CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk)) |
000002  f001010e          AND      r1,r1,#0xe
000006  f022020e          BIC      r2,r2,#0xe
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;1038                   (u32Mask & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk));
;;;1039   }
00000e  4770              BX       lr
;;;1040   
                          ENDP


                          AREA ||i.CAN_EnterInitMode||, CODE, READONLY, ALIGN=1

                  CAN_EnterInitMode PROC
;;;246      */
;;;247    void CAN_EnterInitMode(CAN_T *tCAN, uint8_t u8Mask)
000000  f0410141          ORR      r1,r1,#0x41
;;;248    {
;;;249        tCAN->CON = u8Mask | (CAN_CON_INIT_Msk | CAN_CON_CCE_Msk);
000004  6001              STR      r1,[r0,#0]
;;;250    }
000006  4770              BX       lr
;;;251    
                          ENDP


                          AREA ||i.CAN_EnterTestMode||, CODE, READONLY, ALIGN=1

                  CAN_EnterTestMode PROC
;;;339      */
;;;340    void CAN_EnterTestMode(CAN_T *tCAN, uint8_t u8TestMask)
000000  6802              LDR      r2,[r0,#0]
;;;341    {
;;;342        tCAN->CON |= CAN_CON_TEST_Msk;
000002  f0420280          ORR      r2,r2,#0x80
000006  6002              STR      r2,[r0,#0]
;;;343        tCAN->TEST = u8TestMask;
000008  6141              STR      r1,[r0,#0x14]
;;;344    }
00000a  4770              BX       lr
;;;345    
                          ENDP


                          AREA ||i.CAN_GetCANBitRate||, CODE, READONLY, ALIGN=2

                  CAN_GetCANBitRate PROC
;;;314      */
;;;315    uint32_t CAN_GetCANBitRate(CAN_T *tCAN)
000000  68c1              LDR      r1,[r0,#0xc]
;;;316    {
;;;317        uint32_t u32Tseg1, u32Tseg2;
;;;318        uint32_t u32Bpr;
;;;319    
;;;320        u32Tseg1 = (tCAN->BTIME & CAN_BTIME_TSEG1_Msk) >> CAN_BTIME_TSEG1_Pos;
000002  f3c12203          UBFX     r2,r1,#8,#4
;;;321        u32Tseg2 = (tCAN->BTIME & CAN_BTIME_TSEG2_Msk) >> CAN_BTIME_TSEG2_Pos;
000006  68c1              LDR      r1,[r0,#0xc]
;;;322        u32Bpr   = (tCAN->BTIME & CAN_BTIME_BRP_Msk) | (tCAN->BRPE << 6ul);
000008  6983              LDR      r3,[r0,#0x18]
00000a  f3c13102          UBFX     r1,r1,#12,#3          ;321
00000e  68c0              LDR      r0,[r0,#0xc]
000010  f363109f          BFI      r0,r3,#6,#26
;;;323    
;;;324        return (SystemCoreClock / (u32Bpr + 1ul) / (u32Tseg1 + u32Tseg2 + 3ul));
000014  4b04              LDR      r3,|L9.40|
000016  1c40              ADDS     r0,r0,#1
000018  681b              LDR      r3,[r3,#0]  ; SystemCoreClock
00001a  fbb3f3f0          UDIV     r3,r3,r0
00001e  1850              ADDS     r0,r2,r1
000020  1cc0              ADDS     r0,r0,#3
000022  fbb3f0f0          UDIV     r0,r3,r0
;;;325    }
000026  4770              BX       lr
;;;326    
                          ENDP

                  |L9.40|
                          DCD      SystemCoreClock

                          AREA ||i.CAN_IsNewDataReceived||, CODE, READONLY, ALIGN=1

                  CAN_IsNewDataReceived PROC
;;;367      */
;;;368    uint32_t CAN_IsNewDataReceived(CAN_T *tCAN, uint8_t u8MsgObj)
000000  2201              MOVS     r2,#1
;;;369    {
;;;370        return (u8MsgObj < 16ul ? tCAN->NDAT1 & (1ul << u8MsgObj) : tCAN->NDAT2 & (1ul << (u8MsgObj - 16ul)));
000002  2910              CMP      r1,#0x10
000004  d202              BCS      |L10.12|
000006  f8d00120          LDR      r0,[r0,#0x120]
00000a  e002              B        |L10.18|
                  |L10.12|
00000c  f8d00124          LDR      r0,[r0,#0x124]
000010  3910              SUBS     r1,r1,#0x10
                  |L10.18|
000012  408a              LSLS     r2,r2,r1
000014  4010              ANDS     r0,r0,r2
;;;371    }
000016  4770              BX       lr
;;;372    
                          ENDP


                          AREA ||i.CAN_LeaveInitMode||, CODE, READONLY, ALIGN=1

                  CAN_LeaveInitMode PROC
;;;259      */
;;;260    void CAN_LeaveInitMode(CAN_T *tCAN)
000000  6801              LDR      r1,[r0,#0]
;;;261    {
;;;262        tCAN->CON &= (~(CAN_CON_INIT_Msk | CAN_CON_CCE_Msk));
000002  f0210141          BIC      r1,r1,#0x41
000006  6001              STR      r1,[r0,#0]
                  |L11.8|
;;;263        while(tCAN->CON & CAN_CON_INIT_Msk)
000008  6801              LDR      r1,[r0,#0]
00000a  07c9              LSLS     r1,r1,#31
00000c  d1fc              BNE      |L11.8|
;;;264        {
;;;265            /* Check INIT bit is released */
;;;266        }
;;;267    }
00000e  4770              BX       lr
;;;268    
                          ENDP


                          AREA ||i.CAN_LeaveTestMode||, CODE, READONLY, ALIGN=1

                  CAN_LeaveTestMode PROC
;;;352      */
;;;353    void CAN_LeaveTestMode(CAN_T *tCAN)
000000  6801              LDR      r1,[r0,#0]
;;;354    {
;;;355        tCAN->CON |= CAN_CON_TEST_Msk;
000002  f0410180          ORR      r1,r1,#0x80
000006  6001              STR      r1,[r0,#0]
;;;356        tCAN->TEST &= ~(CAN_TEST_LBACK_Msk | CAN_TEST_SILENT_Msk | CAN_TEST_BASIC_Msk);
000008  6941              LDR      r1,[r0,#0x14]
00000a  f021011c          BIC      r1,r1,#0x1c
00000e  6141              STR      r1,[r0,#0x14]
;;;357        tCAN->CON &= (~CAN_CON_TEST_Msk);
000010  6801              LDR      r1,[r0,#0]
000012  f0210180          BIC      r1,r1,#0x80
000016  6001              STR      r1,[r0,#0]
;;;358    }
000018  4770              BX       lr
;;;359    
                          ENDP


                          AREA ||i.CAN_Open||, CODE, READONLY, ALIGN=1

                  CAN_Open PROC
;;;896      */
;;;897    uint32_t CAN_Open(CAN_T *tCAN, uint32_t u32BaudRate, uint32_t u32Mode)
000000  b570              PUSH     {r4-r6,lr}
;;;898    {
000002  4615              MOV      r5,r2
000004  4604              MOV      r4,r0
;;;899        uint32_t u32CurrentBitRate;
;;;900    
;;;901        u32CurrentBitRate = CAN_SetBaudRate(tCAN, u32BaudRate);
000006  f7fffffe          BL       CAN_SetBaudRate
;;;902    
;;;903        if(u32Mode == CAN_BASIC_MODE)
00000a  2d01              CMP      r5,#1
00000c  d105              BNE      |L13.26|
00000e  6822              LDR      r2,[r4,#0]
;;;904        {
;;;905            CAN_EnterTestMode(tCAN, (uint8_t)CAN_TEST_BASIC_Msk);
000010  2104              MOVS     r1,#4
000012  f0420280          ORR      r2,r2,#0x80
000016  6022              STR      r2,[r4,#0]
000018  6161              STR      r1,[r4,#0x14]
                  |L13.26|
;;;906        }
;;;907        else
;;;908        {
;;;909        }
;;;910    
;;;911        return u32CurrentBitRate;
;;;912    }
00001a  bd70              POP      {r4-r6,pc}
;;;913    
                          ENDP


                          AREA ||i.CAN_ReadMsgObj||, CODE, READONLY, ALIGN=1

                  CAN_ReadMsgObj PROC
;;;669      */
;;;670    int32_t CAN_ReadMsgObj(CAN_T *tCAN, uint8_t u8MsgObj, uint8_t u8Release, STR_CANMSG_T* pCanMsg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;671    {
000004  461c              MOV      r4,r3
000006  4617              MOV      r7,r2
000008  4688              MOV      r8,r1
00000a  4606              MOV      r6,r0
;;;672        int32_t rev = 1l;
00000c  2501              MOVS     r5,#1
;;;673        uint32_t u32MsgIfNum;
;;;674    
;;;675        if(!CAN_IsNewDataReceived(tCAN, u8MsgObj))
00000e  f7fffffe          BL       CAN_IsNewDataReceived
000012  b160              CBZ      r0,|L14.46|
;;;676        {
;;;677            rev = 0; /* return FALSE */
;;;678        }
;;;679        else
;;;680        {
;;;681            /* Get and lock a free interface */
;;;682            if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       LockIF_TL
00001a  4601              MOV      r1,r0
00001c  2802              CMP      r0,#2
00001e  d006              BEQ      |L14.46|
;;;683            {
;;;684                rev = 0; /* return FALSE */
;;;685            }
;;;686            else
;;;687            {
;;;688                tCAN->STATUS &= (~CAN_STATUS_RXOK_Msk);
000020  6870              LDR      r0,[r6,#4]
000022  f0200010          BIC      r0,r0,#0x10
000026  6070              STR      r0,[r6,#4]
;;;689    
;;;690                /* read the message contents*/
;;;691                tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_MASK_Msk
000028  b11f              CBZ      r7,|L14.50|
;;;692                                              | CAN_IF_CMASK_ARB_Msk
;;;693                                              | CAN_IF_CMASK_CONTROL_Msk
;;;694                                              | CAN_IF_CMASK_CLRINTPND_Msk
;;;695                                              | (u8Release ? CAN_IF_CMASK_TXRQSTNEWDAT_Msk : 0ul)
00002a  2004              MOVS     r0,#4
00002c  e002              B        |L14.52|
                  |L14.46|
00002e  2500              MOVS     r5,#0                 ;684
000030  e03a              B        |L14.168|
                  |L14.50|
000032  2000              MOVS     r0,#0
                  |L14.52|
000034  f040027b          ORR      r2,r0,#0x7b
000038  eb010041          ADD      r0,r1,r1,LSL #1
00003c  eb061040          ADD      r0,r6,r0,LSL #5
000040  6242              STR      r2,[r0,#0x24]
;;;696                                              | CAN_IF_CMASK_DATAA_Msk
;;;697                                              | CAN_IF_CMASK_DATAB_Msk;
;;;698    
;;;699                tCAN->IF[u32MsgIfNum].CREQ = 1ul + u8MsgObj;
000042  f1080201          ADD      r2,r8,#1
000046  6202              STR      r2,[r0,#0x20]
                  |L14.72|
;;;700    
;;;701                while(tCAN->IF[u32MsgIfNum].CREQ & CAN_IF_CREQ_BUSY_Msk)
000048  6a02              LDR      r2,[r0,#0x20]
00004a  0412              LSLS     r2,r2,#16
00004c  d4fc              BMI      |L14.72|
;;;702                {
;;;703                    /*Wait*/
;;;704                }
;;;705    
;;;706                if((tCAN->IF[u32MsgIfNum].ARB2 & CAN_IF_ARB2_XTD_Msk) == 0ul)
00004e  6b42              LDR      r2,[r0,#0x34]
000050  0452              LSLS     r2,r2,#17
000052  d405              BMI      |L14.96|
;;;707                {
;;;708                    /* standard ID*/
;;;709                    pCanMsg->IdType = CAN_STD_ID;
000054  2200              MOVS     r2,#0
;;;710                    pCanMsg->Id     = (tCAN->IF[u32MsgIfNum].ARB2 & CAN_IF_ARB2_ID_Msk) >> 2ul;
000056  6022              STR      r2,[r4,#0]
000058  6b42              LDR      r2,[r0,#0x34]
00005a  f3c2028a          UBFX     r2,r2,#2,#11
00005e  e007              B        |L14.112|
                  |L14.96|
;;;711                }
;;;712                else
;;;713                {
;;;714                    /* extended ID*/
;;;715                    pCanMsg->IdType = CAN_EXT_ID;
000060  2201              MOVS     r2,#1
;;;716                    pCanMsg->Id  = (((tCAN->IF[u32MsgIfNum].ARB2) & 0x1FFFul) << 16) | tCAN->IF[u32MsgIfNum].ARB1;
000062  6022              STR      r2,[r4,#0]
000064  6b02              LDR      r2,[r0,#0x30]
000066  6b43              LDR      r3,[r0,#0x34]
000068  f3c3030c          UBFX     r3,r3,#0,#13
00006c  ea424203          ORR      r2,r2,r3,LSL #16
                  |L14.112|
;;;717                }
;;;718    
;;;719                pCanMsg->DLC     = (uint8_t)(tCAN->IF[u32MsgIfNum].MCON & CAN_IF_MCON_DLC_Msk);
000070  60a2              STR      r2,[r4,#8]
000072  6b82              LDR      r2,[r0,#0x38]
000074  f002020f          AND      r2,r2,#0xf
000078  7322              STRB     r2,[r4,#0xc]
;;;720                pCanMsg->Data[0] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_A1 & CAN_IF_DAT_A1_DATA0_Msk);
00007a  6bc2              LDR      r2,[r0,#0x3c]
00007c  7362              STRB     r2,[r4,#0xd]
;;;721                pCanMsg->Data[1] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_A1 & CAN_IF_DAT_A1_DATA1_Msk) >> CAN_IF_DAT_A1_DATA1_Pos);
00007e  6bc2              LDR      r2,[r0,#0x3c]
000080  0a12              LSRS     r2,r2,#8
000082  73a2              STRB     r2,[r4,#0xe]
;;;722                pCanMsg->Data[2] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_A2 & CAN_IF_DAT_A2_DATA2_Msk);
000084  6c02              LDR      r2,[r0,#0x40]
000086  73e2              STRB     r2,[r4,#0xf]
;;;723                pCanMsg->Data[3] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_A2 & CAN_IF_DAT_A2_DATA3_Msk) >> CAN_IF_DAT_A2_DATA3_Pos);
000088  6c02              LDR      r2,[r0,#0x40]
00008a  0a12              LSRS     r2,r2,#8
00008c  7422              STRB     r2,[r4,#0x10]
;;;724                pCanMsg->Data[4] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_B1 & CAN_IF_DAT_B1_DATA4_Msk);
00008e  6c42              LDR      r2,[r0,#0x44]
000090  7462              STRB     r2,[r4,#0x11]
;;;725                pCanMsg->Data[5] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_B1 & CAN_IF_DAT_B1_DATA5_Msk) >> CAN_IF_DAT_B1_DATA5_Pos);
000092  6c42              LDR      r2,[r0,#0x44]
000094  0a12              LSRS     r2,r2,#8
000096  74a2              STRB     r2,[r4,#0x12]
;;;726                pCanMsg->Data[6] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_B2 & CAN_IF_DAT_B2_DATA6_Msk);
000098  6c82              LDR      r2,[r0,#0x48]
00009a  74e2              STRB     r2,[r4,#0x13]
;;;727                pCanMsg->Data[7] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_B2 & CAN_IF_DAT_B2_DATA7_Msk) >> CAN_IF_DAT_B2_DATA7_Pos);
00009c  6c80              LDR      r0,[r0,#0x48]
00009e  0a00              LSRS     r0,r0,#8
0000a0  7520              STRB     r0,[r4,#0x14]
;;;728    
;;;729                ReleaseIF(tCAN, u32MsgIfNum);
0000a2  4630              MOV      r0,r6
0000a4  f7fffffe          BL       ReleaseIF
                  |L14.168|
;;;730            }
;;;731        }
;;;732    
;;;733        return rev;
0000a8  4628              MOV      r0,r5
;;;734    }
0000aa  e8bd81f0          POP      {r4-r8,pc}
;;;735    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;1236     */
;;;1237   int32_t CAN_Receive(CAN_T *tCAN, uint32_t u32MsgNum, STR_CANMSG_T* pCanMsg)
000000  b430              PUSH     {r4,r5}
;;;1238   {
000002  460c              MOV      r4,r1
;;;1239       int32_t rev = (int32_t)TRUE;
;;;1240       uint32_t u32Tmp;
;;;1241   
;;;1242       u32Tmp = (tCAN->TEST & CAN_TEST_BASIC_Msk);
000004  6941              LDR      r1,[r0,#0x14]
;;;1243   
;;;1244       if((tCAN->CON & CAN_CON_TEST_Msk) && u32Tmp)
000006  6803              LDR      r3,[r0,#0]
000008  f0010104          AND      r1,r1,#4              ;1242
00000c  061b              LSLS     r3,r3,#24
00000e  d504              BPL      |L15.26|
000010  b119              CBZ      r1,|L15.26|
;;;1245       {
;;;1246           rev = CAN_BasicReceiveMsg(tCAN, pCanMsg);
000012  bc30              POP      {r4,r5}
000014  4611              MOV      r1,r2
000016  f7ffbffe          B.W      CAN_BasicReceiveMsg
                  |L15.26|
;;;1247       }
;;;1248       else
;;;1249       {
;;;1250           rev = CAN_ReadMsgObj(tCAN, (uint8_t)u32MsgNum, (uint8_t)TRUE, pCanMsg);
00001a  b2e1              UXTB     r1,r4
00001c  4613              MOV      r3,r2
00001e  bc30              POP      {r4,r5}
000020  2201              MOVS     r2,#1
000022  f7ffbffe          B.W      CAN_ReadMsgObj
;;;1251       }
;;;1252   
;;;1253       return rev;
;;;1254   }
;;;1255   
                          ENDP


                          AREA ||i.CAN_SetBaudRate||, CODE, READONLY, ALIGN=2

                  CAN_SetBaudRate PROC
;;;746      */
;;;747    uint32_t CAN_SetBaudRate(CAN_T *tCAN, uint32_t u32BaudRate)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;748    {
000004  b089              SUB      sp,sp,#0x24
000006  4680              MOV      r8,r0
;;;749        long rate;
;;;750        long best_error = 1000000000, error = 0;
000008  485c              LDR      r0,|L16.380|
;;;751        int best_tseg = 0, best_brp = 0, brp = 0;
00000a  9007              STR      r0,[sp,#0x1c]
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;752        int tsegall, tseg = 0, tseg1 = 0, tseg2 = 0;
000010  9004              STR      r0,[sp,#0x10]
000012  9002              STR      r0,[sp,#8]
;;;753        int spt_error = 1000, spt = 0, sampl_pt;
000014  9003              STR      r0,[sp,#0xc]
000016  460e              MOV      r6,r1                 ;748
000018  f44f707a          MOV      r0,#0x3e8
00001c  2401              MOVS     r4,#1
00001e  2141              MOVS     r1,#0x41
000020  9006              STR      r0,[sp,#0x18]
000022  2500              MOVS     r5,#0
;;;754        uint64_t clock_freq = (uint64_t)0, u64PCLK_DIV = (uint64_t)1;
;;;755        uint32_t sjw = (uint32_t)1;
000024  4627              MOV      r7,r4
000026  f8c81000          STR      r1,[r8,#0]
;;;756    
;;;757        CAN_EnterInitMode(tCAN, (uint8_t)0);
;;;758    
;;;759        SystemCoreClockUpdate();
00002a  f7fffffe          BL       SystemCoreClockUpdate
;;;760        if((tCAN == CAN0) || (tCAN == CAN2))
00002e  4a54              LDR      r2,|L16.384|
000030  f04f0901          MOV      r9,#1                 ;755
;;;761        {
;;;762            u64PCLK_DIV = (uint64_t)(CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk);
000034  0350              LSLS     r0,r2,#13
000036  4590              CMP      r8,r2                 ;760
000038  d002              BEQ      |L16.64|
00003a  4a52              LDR      r2,|L16.388|
00003c  4590              CMP      r8,r2                 ;760
00003e  d104              BNE      |L16.74|
                  |L16.64|
000040  f8d00234          LDR      r0,[r0,#0x234]
000044  f0000007          AND      r0,r0,#7
;;;763            u64PCLK_DIV = (uint64_t)(1 << u64PCLK_DIV);
000048  e006              B        |L16.88|
                  |L16.74|
;;;764        }
;;;765        else if(tCAN == CAN1)
00004a  4a4f              LDR      r2,|L16.392|
00004c  4590              CMP      r8,r2
00004e  d106              BNE      |L16.94|
;;;766        {
;;;767            u64PCLK_DIV = (uint64_t)((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) >> CLK_PCLKDIV_APB1DIV_Pos);
000050  f8d00234          LDR      r0,[r0,#0x234]
000054  f3c01002          UBFX     r0,r0,#4,#3
                  |L16.88|
;;;768            u64PCLK_DIV = (uint64_t)(1 << u64PCLK_DIV);
000058  fa09f400          LSL      r4,r9,r0
00005c  17e5              ASRS     r5,r4,#31
                  |L16.94|
;;;769        }
;;;770    
;;;771        clock_freq = SystemCoreClock / u64PCLK_DIV;
00005e  484b              LDR      r0,|L16.396|
000060  4622              MOV      r2,r4
000062  462b              MOV      r3,r5
000064  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000066  2100              MOVS     r1,#0
000068  f7fffffe          BL       __aeabi_uldivmod
00006c  4682              MOV      r10,r0
;;;772    
;;;773        if(u32BaudRate >= (uint32_t)1000000)
00006e  4848              LDR      r0,|L16.400|
000070  468b              MOV      r11,r1                ;771
000072  4286              CMP      r6,r0
000074  d301              BCC      |L16.122|
;;;774        {
;;;775            u32BaudRate = (uint32_t)1000000;
000076  4606              MOV      r6,r0
000078  e002              B        |L16.128|
                  |L16.122|
;;;776        }
;;;777    
;;;778        /* Use CIA recommended sample points */
;;;779        if (u32BaudRate > (uint32_t)800000)
00007a  4846              LDR      r0,|L16.404|
00007c  4286              CMP      r6,r0
00007e  d902              BLS      |L16.134|
                  |L16.128|
;;;780        {
;;;781            sampl_pt = (int)750;
000080  f24020ee          MOV      r0,#0x2ee
000084  e007              B        |L16.150|
                  |L16.134|
;;;782        }
;;;783        else if (u32BaudRate > (uint32_t)500000)
000086  4844              LDR      r0,|L16.408|
000088  4286              CMP      r6,r0
00008a  d902              BLS      |L16.146|
;;;784        {
;;;785            sampl_pt = (int)800;
00008c  f44f7048          MOV      r0,#0x320
000090  e001              B        |L16.150|
                  |L16.146|
;;;786        }
;;;787        else
;;;788        {
;;;789            sampl_pt = (int)875;
000092  f240306b          MOV      r0,#0x36b
                  |L16.150|
;;;790        }
;;;791    
;;;792        /* tseg even = round down, odd = round up */
;;;793        for (tseg = (TSEG1_MAX + TSEG2_MAX) * 2ul + 1ul; tseg >= (TSEG1_MIN + TSEG2_MIN) * 2ul; tseg--)
000096  2431              MOVS     r4,#0x31
000098  9001              STR      r0,[sp,#4]
                  |L16.154|
;;;794        {
;;;795            tsegall = 1ul + tseg / 2ul;
00009a  2001              MOVS     r0,#1
00009c  eb000954          ADD      r9,r0,r4,LSR #1
;;;796            /* Compute all possible tseg choices (tseg=tseg1+tseg2) */
;;;797            brp = clock_freq / (tsegall * u32BaudRate) + tseg % 2;
0000a0  fb09f206          MUL      r2,r9,r6
0000a4  2300              MOVS     r3,#0
0000a6  4650              MOV      r0,r10
0000a8  4659              MOV      r1,r11
0000aa  f7fffffe          BL       __aeabi_uldivmod
0000ae  eb0471d4          ADD      r1,r4,r4,LSR #31
0000b2  9105              STR      r1,[sp,#0x14]
0000b4  f0210101          BIC      r1,r1,#1
0000b8  1a61              SUBS     r1,r4,r1
0000ba  1845              ADDS     r5,r0,r1
;;;798            /* chose brp step which is possible in system */
;;;799            brp = (brp / BRP_INC) * BRP_INC;
;;;800    
;;;801            if ((brp < BRP_MIN) || (brp > BRP_MAX))
0000bc  f1a50001          SUB      r0,r5,#1
0000c0  f5b06f80          CMP      r0,#0x400
0000c4  d222              BCS      |L16.268|
;;;802            {
;;;803                continue;
;;;804            }
;;;805            rate = clock_freq / (brp * tsegall);
0000c6  fb05f209          MUL      r2,r5,r9
0000ca  17d3              ASRS     r3,r2,#31
0000cc  4650              MOV      r0,r10
0000ce  4659              MOV      r1,r11
0000d0  f7fffffe          BL       __aeabi_uldivmod
;;;806    
;;;807            error = u32BaudRate - rate;
0000d4  1a30              SUBS     r0,r6,r0
;;;808    
;;;809            /* tseg brp biterror */
;;;810            if (error < 0)
0000d6  d500              BPL      |L16.218|
;;;811            {
;;;812                error = -error;
0000d8  4240              RSBS     r0,r0,#0
                  |L16.218|
;;;813            }
;;;814            if (error > best_error)
0000da  9907              LDR      r1,[sp,#0x1c]
0000dc  4288              CMP      r0,r1
0000de  dc15              BGT      |L16.268|
;;;815            {
;;;816                continue;
;;;817            }
;;;818            best_error = error;
;;;819            if (error == 0)
0000e0  9007              STR      r0,[sp,#0x1c]
0000e2  b970              CBNZ     r0,|L16.258|
;;;820            {
;;;821                spt = can_update_spt(sampl_pt, tseg / 2, &tseg1, &tseg2);
0000e4  9805              LDR      r0,[sp,#0x14]
0000e6  ab03              ADD      r3,sp,#0xc
0000e8  1041              ASRS     r1,r0,#1
0000ea  aa02              ADD      r2,sp,#8
0000ec  9801              LDR      r0,[sp,#4]
0000ee  f7fffffe          BL       can_update_spt
;;;822                error = sampl_pt - spt;
0000f2  9901              LDR      r1,[sp,#4]
0000f4  1a08              SUBS     r0,r1,r0
;;;823                if (error < 0)
0000f6  d500              BPL      |L16.250|
;;;824                {
;;;825                    error = -error;
0000f8  4240              RSBS     r0,r0,#0
                  |L16.250|
;;;826                }
;;;827                if (error > spt_error)
0000fa  9906              LDR      r1,[sp,#0x18]
0000fc  4288              CMP      r0,r1
0000fe  dc05              BGT      |L16.268|
;;;828                {
;;;829                    continue;
;;;830                }
;;;831                spt_error = error;
000100  9006              STR      r0,[sp,#0x18]
                  |L16.258|
;;;832            }
;;;833            best_tseg = tseg / 2;
000102  9905              LDR      r1,[sp,#0x14]
;;;834            best_brp = brp;
;;;835    
;;;836            if (error == 0)
000104  9504              STR      r5,[sp,#0x10]
000106  1049              ASRS     r1,r1,#1              ;833
000108  9100              STR      r1,[sp,#0]
00010a  b110              CBZ      r0,|L16.274|
                  |L16.268|
00010c  1e64              SUBS     r4,r4,#1
00010e  2c06              CMP      r4,#6                 ;793
000110  d2c3              BCS      |L16.154|
                  |L16.274|
;;;837            {
;;;838                break;
;;;839            }
;;;840        }
;;;841    
;;;842        spt = can_update_spt(sampl_pt, best_tseg, &tseg1, &tseg2);
000112  e9dd1000          LDRD     r1,r0,[sp,#0]
000116  ab03              ADD      r3,sp,#0xc
000118  aa02              ADD      r2,sp,#8
00011a  f7fffffe          BL       can_update_spt
;;;843    
;;;844        /* check for sjw user settings */
;;;845        /* bt->sjw is at least 1 -> sanitize upper bound to sjw_max */
;;;846        if (sjw > SJW_MAX)
00011e  2f04              CMP      r7,#4
000120  d900              BLS      |L16.292|
;;;847        {
;;;848            sjw = SJW_MAX;
000122  2704              MOVS     r7,#4
                  |L16.292|
;;;849        }
;;;850        /* bt->sjw must not be higher than tseg2 */
;;;851        if (tseg2 < sjw)
000124  9c03              LDR      r4,[sp,#0xc]
000126  42bc              CMP      r4,r7
000128  d200              BCS      |L16.300|
;;;852        {
;;;853            sjw = tseg2;
00012a  4627              MOV      r7,r4
                  |L16.300|
;;;854        }
;;;855    
;;;856        /* real bit-rate */
;;;857        u32BaudRate = clock_freq / (best_brp * (tseg1 + tseg2 + 1));
00012c  9d02              LDR      r5,[sp,#8]
00012e  9804              LDR      r0,[sp,#0x10]
000130  192a              ADDS     r2,r5,r4
000132  1c52              ADDS     r2,r2,#1
000134  4342              MULS     r2,r0,r2
000136  17d3              ASRS     r3,r2,#31
000138  4650              MOV      r0,r10
00013a  4659              MOV      r1,r11
00013c  f7fffffe          BL       __aeabi_uldivmod
000140  4602              MOV      r2,r0
;;;858    
;;;859        tCAN->BTIME = ((uint32_t)(tseg2 - 1ul) << CAN_BTIME_TSEG2_Pos) | ((uint32_t)(tseg1 - 1ul) << CAN_BTIME_TSEG1_Pos) |
000142  0320              LSLS     r0,r4,#12
000144  f06f01ff          MVN      r1,#0xff
000148  eb012105          ADD      r1,r1,r5,LSL #8
00014c  f5a05080          SUB      r0,r0,#0x1000
000150  4308              ORRS     r0,r0,r1
000152  9904              LDR      r1,[sp,#0x10]
000154  1e49              SUBS     r1,r1,#1
000156  f001033f          AND      r3,r1,#0x3f
00015a  4318              ORRS     r0,r0,r3
00015c  ea401387          ORR      r3,r0,r7,LSL #6
000160  4640              MOV      r0,r8
000162  f8c8300c          STR      r3,[r8,#0xc]
;;;860                      ((uint32_t)(best_brp - 1ul) & CAN_BTIME_BRP_Msk) | (sjw << CAN_BTIME_SJW_Pos);
;;;861        tCAN->BRPE  = ((uint32_t)(best_brp - 1ul) >> 6) & 0x0Ful;
000166  f3c11183          UBFX     r1,r1,#6,#4
00016a  f8c81018          STR      r1,[r8,#0x18]
;;;862    
;;;863        /* printf("\n bitrate = %d \n", CAN_GetCANBitRate(tCAN)); */
;;;864    
;;;865        CAN_LeaveInitMode(tCAN);
00016e  f7fffffe          BL       CAN_LeaveInitMode
;;;866    
;;;867        return u32BaudRate;
;;;868    }
000172  b009              ADD      sp,sp,#0x24
000174  4610              MOV      r0,r2                 ;867
000176  e8bd8ff0          POP      {r4-r11,pc}
;;;869    
                          ENDP

00017a  0000              DCW      0x0000
                  |L16.380|
                          DCD      0x3b9aca00
                  |L16.384|
                          DCD      0x400a0000
                  |L16.388|
                          DCD      0x400a2000
                  |L16.392|
                          DCD      0x400a1000
                  |L16.396|
                          DCD      SystemCoreClock
                  |L16.400|
                          DCD      0x000f4240
                  |L16.404|
                          DCD      0x000c3500
                  |L16.408|
                          DCD      0x0007a120

                          AREA ||i.CAN_SetMultiRxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetMultiRxMsg PROC
;;;1146     */
;;;1147   int32_t CAN_SetMultiRxMsg(CAN_T *tCAN, uint32_t u32MsgNum, uint32_t u32MsgCount, uint32_t u32IDType, uint32_t u32ID)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1148   {
;;;1149       int32_t  rev = (int32_t)TRUE;
000004  f04f0a01          MOV      r10,#1
000008  b081              SUB      sp,sp,#4              ;1148
00000a  469b              MOV      r11,r3                ;1148
00000c  460e              MOV      r6,r1                 ;1148
;;;1150       uint32_t i = 0ul;
;;;1151       uint32_t u32TimeOutCount;
;;;1152       uint32_t u32EOB_Flag = 0ul;
00000e  f04f0800          MOV      r8,#0
;;;1153   
;;;1154       for(i = 1ul; i < u32MsgCount; i++)
000012  4654              MOV      r4,r10
;;;1155       {
;;;1156           u32TimeOutCount = 0ul;
;;;1157   
;;;1158           u32MsgNum += (i - 1ul);
;;;1159   
;;;1160           if(i == u32MsgCount)
;;;1161           {
;;;1162               u32EOB_Flag = 1ul;
;;;1163           }
;;;1164           else
;;;1165           {
;;;1166           }
;;;1167   
;;;1168           while(CAN_SetRxMsgObj(tCAN, (uint8_t)u32MsgNum, (uint8_t)u32IDType, u32ID, (uint8_t)u32EOB_Flag) == (int32_t)FALSE)
;;;1169           {
;;;1170               if(++u32TimeOutCount >= RETRY_COUNTS)
000014  f04f5980          MOV      r9,#0x10000000
000018  e013              B        |L17.66|
                  |L17.26|
00001a  4426              ADD      r6,r6,r4              ;1158
00001c  f04f0500          MOV      r5,#0                 ;1156
000020  f1a60601          SUB      r6,r6,#1              ;1158
000024  d101              BNE      |L17.42|
000026  f04f0801          MOV      r8,#1                 ;1162
                  |L17.42|
00002a  f00807ff          AND      r7,r8,#0xff           ;1168
                  |L17.46|
00002e  f00b02ff          AND      r2,r11,#0xff          ;1168
000032  b2f1              UXTB     r1,r6                 ;1168
000034  9700              STR      r7,[sp,#0]            ;1168
000036  9b0e              LDR      r3,[sp,#0x38]         ;1168
000038  9801              LDR      r0,[sp,#4]            ;1168
00003a  f7fffffe          BL       CAN_SetRxMsgObj
00003e  b138              CBZ      r0,|L17.80|
                  |L17.64|
000040  1c64              ADDS     r4,r4,#1              ;1168
                  |L17.66|
000042  9803              LDR      r0,[sp,#0xc]          ;1154
000044  4284              CMP      r4,r0                 ;1154
000046  d3e8              BCC      |L17.26|
;;;1171               {
;;;1172                   rev = (int32_t)FALSE;
;;;1173                   break;
;;;1174               }
;;;1175               else
;;;1176               {
;;;1177               }
;;;1178           }
;;;1179       }
;;;1180   
;;;1181       return rev;
;;;1182   }
000048  b005              ADD      sp,sp,#0x14
00004a  4650              MOV      r0,r10                ;1181
00004c  e8bd8ff0          POP      {r4-r11,pc}
                  |L17.80|
000050  f1050501          ADD      r5,r5,#1
000054  454d              CMP      r5,r9                 ;1170
000056  d3ea              BCC      |L17.46|
000058  f04f0a00          MOV      r10,#0                ;1172
00005c  e7f0              B        |L17.64|
;;;1183   
                          ENDP


                          AREA ||i.CAN_SetRxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsg PROC
;;;1072     */
;;;1073   int32_t CAN_SetRxMsg(CAN_T *tCAN, uint32_t u32MsgNum, uint32_t u32IDType, uint32_t u32ID)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1074   {
;;;1075       int32_t rev = (int32_t)TRUE;
000004  2501              MOVS     r5,#1
000006  469a              MOV      r10,r3                ;1074
000008  4616              MOV      r6,r2                 ;1074
00000a  460f              MOV      r7,r1                 ;1074
00000c  4683              MOV      r11,r0                ;1074
;;;1076       uint32_t u32TimeOutCount = 0ul;
00000e  2400              MOVS     r4,#0
;;;1077   
;;;1078       while(CAN_SetRxMsgObj(tCAN, (uint8_t)u32MsgNum, (uint8_t)u32IDType, u32ID, (uint8_t)TRUE) == (int32_t)FALSE)
;;;1079       {
;;;1080           if(++u32TimeOutCount >= RETRY_COUNTS)
000010  f04f5980          MOV      r9,#0x10000000
000014  46a8              MOV      r8,r5                 ;1075
000016  e004              B        |L18.34|
                  |L18.24|
000018  1c64              ADDS     r4,r4,#1              ;1074
00001a  454c              CMP      r4,r9
00001c  d301              BCC      |L18.34|
;;;1081           {
;;;1082               rev = (int32_t)(FALSE); /* return FALSE */
00001e  2500              MOVS     r5,#0
;;;1083               break;
000020  e009              B        |L18.54|
                  |L18.34|
000022  b2f2              UXTB     r2,r6                 ;1078
000024  b2f9              UXTB     r1,r7                 ;1078
000026  4653              MOV      r3,r10                ;1078
000028  4658              MOV      r0,r11                ;1078
00002a  f8cd8000          STR      r8,[sp,#0]            ;1078
00002e  f7fffffe          BL       CAN_SetRxMsgObj
000032  2800              CMP      r0,#0                 ;1078
000034  d0f0              BEQ      |L18.24|
                  |L18.54|
;;;1084           }
;;;1085           else
;;;1086           {
;;;1087           }
;;;1088       }
;;;1089   
;;;1090       return rev;
000036  4628              MOV      r0,r5
;;;1091   }
000038  e8bd8ff8          POP      {r3-r11,pc}
;;;1092   
                          ENDP


                          AREA ||i.CAN_SetRxMsgAndMsk||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsgAndMsk PROC
;;;1109     */
;;;1110   int32_t CAN_SetRxMsgAndMsk(CAN_T *tCAN, uint32_t u32MsgNum, uint32_t u32IDType, uint32_t u32ID, uint32_t u32IDMask)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1111   {
000004  b083              SUB      sp,sp,#0xc
;;;1112       int32_t  rev = (int32_t)TRUE;
000006  2501              MOVS     r5,#1
000008  469b              MOV      r11,r3                ;1111
00000a  4616              MOV      r6,r2                 ;1111
00000c  460f              MOV      r7,r1                 ;1111
;;;1113       uint32_t u32TimeOutCount = 0ul;
00000e  2400              MOVS     r4,#0
;;;1114   
;;;1115       while(CAN_SetRxMsgObjAndMsk(tCAN, (uint8_t)u32MsgNum, (uint8_t)u32IDType, u32ID, u32IDMask, (uint8_t)TRUE) == (int32_t)FALSE)
;;;1116       {
;;;1117           if(++u32TimeOutCount >= RETRY_COUNTS)
000010  f04f5a80          MOV      r10,#0x10000000
000014  46a9              MOV      r9,r5                 ;1112
000016  f8dd8040          LDR      r8,[sp,#0x40]         ;1111
00001a  e004              B        |L19.38|
                  |L19.28|
00001c  1c64              ADDS     r4,r4,#1              ;1111
00001e  4554              CMP      r4,r10
000020  d301              BCC      |L19.38|
;;;1118           {
;;;1119               rev = (int32_t)FALSE;
000022  2500              MOVS     r5,#0
;;;1120               break;
000024  e009              B        |L19.58|
                  |L19.38|
000026  b2f2              UXTB     r2,r6                 ;1115
000028  b2f9              UXTB     r1,r7                 ;1115
00002a  465b              MOV      r3,r11                ;1115
00002c  e9cd8900          STRD     r8,r9,[sp,#0]         ;1115
000030  9803              LDR      r0,[sp,#0xc]          ;1115
000032  f7fffffe          BL       CAN_SetRxMsgObjAndMsk
000036  2800              CMP      r0,#0                 ;1115
000038  d0f0              BEQ      |L19.28|
                  |L19.58|
;;;1121           }
;;;1122           else
;;;1123           {
;;;1124           }
;;;1125       }
;;;1126   
;;;1127       return rev;
;;;1128   }
00003a  b007              ADD      sp,sp,#0x1c
00003c  4628              MOV      r0,r5                 ;1127
00003e  e8bd8ff0          POP      {r4-r11,pc}
;;;1129   
                          ENDP


                          AREA ||i.CAN_SetRxMsgObj||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsgObj PROC
;;;606      */
;;;607    int32_t CAN_SetRxMsgObj(CAN_T *tCAN, uint8_t u8MsgObj, uint8_t u8idType, uint32_t u32id, uint8_t u8singleOrFifoLast)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;608    {
000004  461c              MOV      r4,r3
000006  4617              MOV      r7,r2
000008  460e              MOV      r6,r1
00000a  4680              MOV      r8,r0
;;;609        int32_t rev = 1l;
00000c  2501              MOVS     r5,#1
;;;610        uint32_t u32MsgIfNum;
;;;611    
;;;612        /* Get and lock a free interface */
;;;613        if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
00000e  f8dd9020          LDR      r9,[sp,#0x20]
000012  f7fffffe          BL       LockIF_TL
000016  4601              MOV      r1,r0
000018  2802              CMP      r0,#2
00001a  d018              BEQ      |L20.78|
;;;614        {
;;;615            rev = 0; /* return FALSE */
;;;616        }
;;;617        else
;;;618        {
;;;619            /* Command Setting */
;;;620            tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_MASK_Msk | CAN_IF_CMASK_ARB_Msk |
00001c  eb010341          ADD      r3,r1,r1,LSL #1
000020  eb081043          ADD      r0,r8,r3,LSL #5
000024  22f3              MOVS     r2,#0xf3
000026  6242              STR      r2,[r0,#0x24]
000028  2200              MOVS     r2,#0
;;;621                                          CAN_IF_CMASK_CONTROL_Msk | CAN_IF_CMASK_DATAA_Msk | CAN_IF_CMASK_DATAB_Msk;
;;;622    
;;;623            if(u8idType == CAN_STD_ID)    /* According STD/EXT ID format,Configure Mask and Arbitration register */
00002a  b197              CBZ      r7,|L20.82|
;;;624            {
;;;625                tCAN->IF[u32MsgIfNum].ARB1 = 0ul;
;;;626                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | (u32id & 0x7FFul) << 2;
;;;627            }
;;;628            else
;;;629            {
;;;630                tCAN->IF[u32MsgIfNum].ARB1 = u32id & 0xFFFFul;
00002c  b2a3              UXTH     r3,r4
00002e  6303              STR      r3,[r0,#0x30]
;;;631                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | CAN_IF_ARB2_XTD_Msk | (u32id & 0x1FFF0000ul) >> 16;
000030  f3c4430c          UBFX     r3,r4,#16,#13
000034  f4434340          ORR      r3,r3,#0xc000
                  |L20.56|
000038  6343              STR      r3,[r0,#0x34]
;;;632            }
;;;633    
;;;634            /* tCAN->IF[u8MsgIfNum].MCON |= CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk; */
;;;635            tCAN->IF[u32MsgIfNum].MCON = CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk;
00003a  f44f53a0          MOV      r3,#0x1400
00003e  6383              STR      r3,[r0,#0x38]
;;;636            if(u8singleOrFifoLast)
;;;637            {
;;;638                tCAN->IF[u32MsgIfNum].MCON |= CAN_IF_MCON_EOB_Msk;
;;;639            }
;;;640            else
;;;641            {
;;;642                tCAN->IF[u32MsgIfNum].MCON &= (~CAN_IF_MCON_EOB_Msk);
000040  6b83              LDR      r3,[r0,#0x38]
000042  f1b90f00          CMP      r9,#0                 ;636
000046  d00c              BEQ      |L20.98|
000048  f0430380          ORR      r3,r3,#0x80           ;638
00004c  e00b              B        |L20.102|
                  |L20.78|
00004e  2500              MOVS     r5,#0                 ;615
000050  e013              B        |L20.122|
                  |L20.82|
000052  6302              STR      r2,[r0,#0x30]         ;625
000054  f3c4030a          UBFX     r3,r4,#0,#11          ;626
000058  f44f4400          MOV      r4,#0x8000            ;626
00005c  ea440383          ORR      r3,r4,r3,LSL #2       ;626
000060  e7ea              B        |L20.56|
                  |L20.98|
000062  f0230380          BIC      r3,r3,#0x80
                  |L20.102|
000066  6383              STR      r3,[r0,#0x38]
;;;643            }
;;;644    
;;;645            tCAN->IF[u32MsgIfNum].DAT_A1  = 0ul;
000068  63c2              STR      r2,[r0,#0x3c]
;;;646            tCAN->IF[u32MsgIfNum].DAT_A2  = 0ul;
00006a  6402              STR      r2,[r0,#0x40]
;;;647            tCAN->IF[u32MsgIfNum].DAT_B1  = 0ul;
00006c  6442              STR      r2,[r0,#0x44]
;;;648            tCAN->IF[u32MsgIfNum].DAT_B2  = 0ul;
00006e  6482              STR      r2,[r0,#0x48]
000070  1c76              ADDS     r6,r6,#1
;;;649    
;;;650            tCAN->IF[u32MsgIfNum].CREQ = 1ul + u8MsgObj;
000072  6206              STR      r6,[r0,#0x20]
;;;651            ReleaseIF(tCAN, u32MsgIfNum);
000074  4640              MOV      r0,r8
000076  f7fffffe          BL       ReleaseIF
                  |L20.122|
;;;652        }
;;;653    
;;;654        return rev;
00007a  4628              MOV      r0,r5
;;;655    }
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;656    
                          ENDP


                          AREA ||i.CAN_SetRxMsgObjAndMsk||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsgObjAndMsk PROC
;;;536      */
;;;537    int32_t CAN_SetRxMsgObjAndMsk(CAN_T *tCAN, uint8_t u8MsgObj, uint8_t u8idType, uint32_t u32id, uint32_t u32idmask, uint8_t u8singleOrFifoLast)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;538    {
000004  461c              MOV      r4,r3
000006  e9dd6a08          LDRD     r6,r10,[sp,#0x20]
00000a  4690              MOV      r8,r2
00000c  460f              MOV      r7,r1
00000e  4681              MOV      r9,r0
;;;539        int32_t rev = 1l;
000010  2501              MOVS     r5,#1
;;;540        uint32_t u32MsgIfNum;
;;;541    
;;;542        /* Get and lock a free interface */
;;;543        if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
000012  f7fffffe          BL       LockIF_TL
000016  4601              MOV      r1,r0
000018  2802              CMP      r0,#2
00001a  d01e              BEQ      |L21.90|
;;;544        {
;;;545            rev = 0; /* return FALSE */
;;;546        }
;;;547        else
;;;548        {
;;;549            /* Command Setting */
;;;550            tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_MASK_Msk | CAN_IF_CMASK_ARB_Msk |
00001c  eb010341          ADD      r3,r1,r1,LSL #1
000020  eb091043          ADD      r0,r9,r3,LSL #5
000024  22f3              MOVS     r2,#0xf3
000026  6242              STR      r2,[r0,#0x24]
000028  2200              MOVS     r2,#0
;;;551                                          CAN_IF_CMASK_CONTROL_Msk | CAN_IF_CMASK_DATAA_Msk | CAN_IF_CMASK_DATAB_Msk;
;;;552    
;;;553            if(u8idType == CAN_STD_ID)    /* According STD/EXT ID format,Configure Mask and Arbitration register */
00002a  f1b80f00          CMP      r8,#0
00002e  d016              BEQ      |L21.94|
;;;554            {
;;;555                tCAN->IF[u32MsgIfNum].ARB1 = 0ul;
;;;556                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | (u32id & 0x7FFul) << 2;
;;;557            }
;;;558            else
;;;559            {
;;;560                tCAN->IF[u32MsgIfNum].ARB1 = u32id & 0xFFFFul;
000030  b2a3              UXTH     r3,r4
000032  6303              STR      r3,[r0,#0x30]
;;;561                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | CAN_IF_ARB2_XTD_Msk | (u32id & 0x1FFF0000ul) >> 16;
000034  f3c4430c          UBFX     r3,r4,#16,#13
000038  f4434340          ORR      r3,r3,#0xc000
                  |L21.60|
00003c  6343              STR      r3,[r0,#0x34]
;;;562            }
;;;563    
;;;564            tCAN->IF[u32MsgIfNum].MASK1 = (u32idmask & 0xFFFFul);
00003e  b2b3              UXTH     r3,r6
000040  6283              STR      r3,[r0,#0x28]
;;;565            tCAN->IF[u32MsgIfNum].MASK2 = (u32idmask >> 16) & 0xFFFFul;
000042  0c33              LSRS     r3,r6,#16
000044  62c3              STR      r3,[r0,#0x2c]
;;;566    
;;;567            /* tCAN->IF[u32MsgIfNum].MCON |= CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk; */
;;;568            tCAN->IF[u32MsgIfNum].MCON = CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk;
000046  f44f53a0          MOV      r3,#0x1400
00004a  6383              STR      r3,[r0,#0x38]
;;;569            if(u8singleOrFifoLast)
;;;570            {
;;;571                tCAN->IF[u32MsgIfNum].MCON |= CAN_IF_MCON_EOB_Msk;
;;;572            }
;;;573            else
;;;574            {
;;;575                tCAN->IF[u32MsgIfNum].MCON &= (~CAN_IF_MCON_EOB_Msk);
00004c  6b83              LDR      r3,[r0,#0x38]
00004e  f1ba0f00          CMP      r10,#0                ;569
000052  d00c              BEQ      |L21.110|
000054  f0430380          ORR      r3,r3,#0x80           ;571
000058  e00b              B        |L21.114|
                  |L21.90|
00005a  2500              MOVS     r5,#0                 ;545
00005c  e013              B        |L21.134|
                  |L21.94|
00005e  6302              STR      r2,[r0,#0x30]         ;555
000060  f3c4030a          UBFX     r3,r4,#0,#11          ;556
000064  f44f4400          MOV      r4,#0x8000            ;556
000068  ea440383          ORR      r3,r4,r3,LSL #2       ;556
00006c  e7e6              B        |L21.60|
                  |L21.110|
00006e  f0230380          BIC      r3,r3,#0x80
                  |L21.114|
000072  6383              STR      r3,[r0,#0x38]
;;;576            }
;;;577    
;;;578            tCAN->IF[u32MsgIfNum].DAT_A1  = 0ul;
000074  63c2              STR      r2,[r0,#0x3c]
;;;579            tCAN->IF[u32MsgIfNum].DAT_A2  = 0ul;
000076  6402              STR      r2,[r0,#0x40]
;;;580            tCAN->IF[u32MsgIfNum].DAT_B1  = 0ul;
000078  6442              STR      r2,[r0,#0x44]
;;;581            tCAN->IF[u32MsgIfNum].DAT_B2  = 0ul;
00007a  6482              STR      r2,[r0,#0x48]
00007c  1c7f              ADDS     r7,r7,#1
;;;582    
;;;583            tCAN->IF[u32MsgIfNum].CREQ = 1ul + u8MsgObj;
00007e  6207              STR      r7,[r0,#0x20]
;;;584            ReleaseIF(tCAN, u32MsgIfNum);
000080  4648              MOV      r0,r9
000082  f7fffffe          BL       ReleaseIF
                  |L21.134|
;;;585        }
;;;586    
;;;587        return rev;
000086  4628              MOV      r0,r5
;;;588    }
000088  e8bd87f0          POP      {r4-r10,pc}
;;;589    
                          ENDP


                          AREA ||i.CAN_SetTxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetTxMsg PROC
;;;926      */
;;;927    int32_t CAN_SetTxMsg(CAN_T *tCAN, uint32_t u32MsgNum, STR_CANMSG_T* pCanMsg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;928    {
000004  4614              MOV      r4,r2
000006  460e              MOV      r6,r1
000008  4607              MOV      r7,r0
;;;929        int32_t rev = 1l;
00000a  2501              MOVS     r5,#1
;;;930        uint32_t u32MsgIfNum;
;;;931    
;;;932        if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
00000c  f7fffffe          BL       LockIF_TL
000010  4601              MOV      r1,r0
000012  2802              CMP      r0,#2
000014  d017              BEQ      |L22.70|
;;;933        {
;;;934            rev = 0; /* return FALSE */
;;;935        }
;;;936        else
;;;937        {
;;;938            /* update the contents needed for transmission*/
;;;939            tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_MASK_Msk | CAN_IF_CMASK_ARB_Msk |
000016  eb010041          ADD      r0,r1,r1,LSL #1
00001a  eb071040          ADD      r0,r7,r0,LSL #5
00001e  22f3              MOVS     r2,#0xf3
000020  6242              STR      r2,[r0,#0x24]
;;;940                                          CAN_IF_CMASK_CONTROL_Msk | CAN_IF_CMASK_DATAA_Msk  | CAN_IF_CMASK_DATAB_Msk;
;;;941    
;;;942            if(pCanMsg->IdType == CAN_STD_ID)
000022  6822              LDR      r2,[r4,#0]
000024  b18a              CBZ      r2,|L22.74|
;;;943            {
;;;944                /* standard ID*/
;;;945                tCAN->IF[u32MsgIfNum].ARB1 = 0ul;
;;;946                tCAN->IF[u32MsgIfNum].ARB2 = (((pCanMsg->Id) & 0x7FFul) << 2) | CAN_IF_ARB2_DIR_Msk | CAN_IF_ARB2_MSGVAL_Msk;
;;;947            }
;;;948            else
;;;949            {
;;;950                /* extended ID*/
;;;951                tCAN->IF[u32MsgIfNum].ARB1 = (pCanMsg->Id) & 0xFFFFul;
000026  8922              LDRH     r2,[r4,#8]
000028  b292              UXTH     r2,r2
00002a  6302              STR      r2,[r0,#0x30]
;;;952                tCAN->IF[u32MsgIfNum].ARB2 = ((pCanMsg->Id) & 0x1FFF0000ul) >> 16 |
00002c  68a2              LDR      r2,[r4,#8]
00002e  f3c2420c          UBFX     r2,r2,#16,#13
000032  f4424260          ORR      r2,r2,#0xe000
                  |L22.54|
000036  6342              STR      r2,[r0,#0x34]
;;;953                                             CAN_IF_ARB2_DIR_Msk | CAN_IF_ARB2_XTD_Msk | CAN_IF_ARB2_MSGVAL_Msk;
;;;954            }
;;;955    
;;;956            if(pCanMsg->FrameType)
000038  6862              LDR      r2,[r4,#4]
00003a  2a00              CMP      r2,#0
;;;957            {
;;;958                tCAN->IF[u32MsgIfNum].ARB2 |=   CAN_IF_ARB2_DIR_Msk;
;;;959            }
;;;960            else
;;;961            {
;;;962                tCAN->IF[u32MsgIfNum].ARB2 &= (~CAN_IF_ARB2_DIR_Msk);
00003c  6b42              LDR      r2,[r0,#0x34]
00003e  d00e              BEQ      |L22.94|
000040  f4425200          ORR      r2,r2,#0x2000         ;958
000044  e00d              B        |L22.98|
                  |L22.70|
000046  2500              MOVS     r5,#0                 ;934
000048  e020              B        |L22.140|
                  |L22.74|
00004a  2200              MOVS     r2,#0                 ;945
00004c  6302              STR      r2,[r0,#0x30]         ;945
00004e  8922              LDRH     r2,[r4,#8]            ;946
000050  f44f4320          MOV      r3,#0xa000            ;946
000054  f3c2020a          UBFX     r2,r2,#0,#11          ;946
000058  ea430282          ORR      r2,r3,r2,LSL #2       ;946
00005c  e7eb              B        |L22.54|
                  |L22.94|
00005e  f4225200          BIC      r2,r2,#0x2000
                  |L22.98|
000062  6342              STR      r2,[r0,#0x34]
;;;963            }
;;;964    
;;;965            tCAN->IF[u32MsgIfNum].DAT_A1 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[1] << 8)) | pCanMsg->Data[0]);
000064  f8342f0d          LDRH     r2,[r4,#0xd]!
000068  63c2              STR      r2,[r0,#0x3c]
;;;966            tCAN->IF[u32MsgIfNum].DAT_A2 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[3] << 8)) | pCanMsg->Data[2]);
00006a  8862              LDRH     r2,[r4,#2]
00006c  6402              STR      r2,[r0,#0x40]
;;;967            tCAN->IF[u32MsgIfNum].DAT_B1 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[5] << 8)) | pCanMsg->Data[4]);
00006e  88a2              LDRH     r2,[r4,#4]
000070  6442              STR      r2,[r0,#0x44]
;;;968            tCAN->IF[u32MsgIfNum].DAT_B2 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[7] << 8)) | pCanMsg->Data[6]);
000072  88e2              LDRH     r2,[r4,#6]
000074  6482              STR      r2,[r0,#0x48]
;;;969    
;;;970            tCAN->IF[u32MsgIfNum].MCON   =  CAN_IF_MCON_NEWDAT_Msk | pCanMsg->DLC | CAN_IF_MCON_TXIE_Msk | CAN_IF_MCON_EOB_Msk;
000076  f8142c01          LDRB     r2,[r4,#-1]
00007a  f6480380          MOV      r3,#0x8880
00007e  431a              ORRS     r2,r2,r3
000080  6382              STR      r2,[r0,#0x38]
000082  1c76              ADDS     r6,r6,#1
;;;971            tCAN->IF[u32MsgIfNum].CREQ   = 1ul + u32MsgNum;
000084  6206              STR      r6,[r0,#0x20]
;;;972    
;;;973            ReleaseIF(tCAN, u32MsgIfNum);
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       ReleaseIF
                  |L22.140|
;;;974        }
;;;975    
;;;976        return rev;
00008c  4628              MOV      r0,r5
;;;977    }
00008e  e8bd81f0          POP      {r4-r8,pc}
;;;978    
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;1197     */
;;;1198   int32_t CAN_Transmit(CAN_T *tCAN, uint32_t u32MsgNum, STR_CANMSG_T* pCanMsg)
000000  b570              PUSH     {r4-r6,lr}
;;;1199   {
000002  4605              MOV      r5,r0
;;;1200       int32_t rev = (int32_t)TRUE;
;;;1201       uint32_t u32Tmp;
;;;1202   
;;;1203       u32Tmp = (tCAN->TEST & CAN_TEST_BASIC_Msk);
000004  6940              LDR      r0,[r0,#0x14]
000006  460e              MOV      r6,r1                 ;1199
000008  2401              MOVS     r4,#1                 ;1200
;;;1204   
;;;1205       if((tCAN->CON & CAN_CON_TEST_Msk) && u32Tmp)
00000a  6829              LDR      r1,[r5,#0]
00000c  f0000004          AND      r0,r0,#4              ;1203
000010  0609              LSLS     r1,r1,#24
000012  d506              BPL      |L23.34|
000014  b128              CBZ      r0,|L23.34|
;;;1206       {
;;;1207           rev = CAN_BasicSendMsg(tCAN, pCanMsg);
000016  4611              MOV      r1,r2
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       CAN_BasicSendMsg
00001e  4604              MOV      r4,r0
000020  e008              B        |L23.52|
                  |L23.34|
;;;1208       }
;;;1209       else
;;;1210       {
;;;1211           if(CAN_SetTxMsg(tCAN, u32MsgNum, pCanMsg) == FALSE)
000022  4631              MOV      r1,r6
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       CAN_SetTxMsg
00002a  b128              CBZ      r0,|L23.56|
;;;1212           {
;;;1213               rev = (int32_t)FALSE;
;;;1214           }
;;;1215           else
;;;1216           {
;;;1217               CAN_TriggerTxMsg(tCAN, u32MsgNum);
00002c  4631              MOV      r1,r6
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       CAN_TriggerTxMsg
                  |L23.52|
;;;1218           }
;;;1219       }
;;;1220   
;;;1221       return rev;
000034  4620              MOV      r0,r4
;;;1222   }
000036  bd70              POP      {r4-r6,pc}
                  |L23.56|
000038  2400              MOVS     r4,#0                 ;1213
00003a  e7fb              B        |L23.52|
;;;1223   
                          ENDP


                          AREA ||i.CAN_TriggerTxMsg||, CODE, READONLY, ALIGN=1

                  CAN_TriggerTxMsg PROC
;;;988      */
;;;989    int32_t CAN_TriggerTxMsg(CAN_T  *tCAN, uint32_t u32MsgNum)
000000  b570              PUSH     {r4-r6,lr}
;;;990    {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;991        int32_t rev = 1l;
000006  2501              MOVS     r5,#1
;;;992        uint32_t u32MsgIfNum;
;;;993    
;;;994        if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
000008  f7fffffe          BL       LockIF_TL
00000c  4602              MOV      r2,r0
00000e  2802              CMP      r0,#2
000010  d017              BEQ      |L24.66|
;;;995        {
;;;996            rev = 0; /* return FALSE */
;;;997        }
;;;998        else
;;;999        {
;;;1000           tCAN->STATUS &= (~CAN_STATUS_TXOK_Msk);
000012  6860              LDR      r0,[r4,#4]
000014  f0200008          BIC      r0,r0,#8
000018  6060              STR      r0,[r4,#4]
;;;1001   
;;;1002           /* read the message contents*/
;;;1003           tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_CLRINTPND_Msk
00001a  eb020042          ADD      r0,r2,r2,LSL #1
00001e  eb041040          ADD      r0,r4,r0,LSL #5
000022  210c              MOVS     r1,#0xc
000024  6241              STR      r1,[r0,#0x24]
000026  1c76              ADDS     r6,r6,#1
;;;1004                                         | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
;;;1005   
;;;1006           tCAN->IF[u32MsgIfNum].CREQ = 1ul + u32MsgNum;
000028  6206              STR      r6,[r0,#0x20]
                  |L24.42|
;;;1007   
;;;1008           while(tCAN->IF[u32MsgIfNum].CREQ & CAN_IF_CREQ_BUSY_Msk)
00002a  6a01              LDR      r1,[r0,#0x20]
00002c  0409              LSLS     r1,r1,#16
00002e  d4fc              BMI      |L24.42|
;;;1009           {
;;;1010               /*Wait*/
;;;1011           }
;;;1012           tCAN->IF[u32MsgIfNum].CMASK  = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
000030  2184              MOVS     r1,#0x84
000032  6241              STR      r1,[r0,#0x24]
;;;1013           tCAN->IF[u32MsgIfNum].CREQ  = 1ul + u32MsgNum;
000034  6206              STR      r6,[r0,#0x20]
;;;1014   
;;;1015           ReleaseIF(tCAN, u32MsgIfNum);
000036  4611              MOV      r1,r2
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       ReleaseIF
                  |L24.62|
;;;1016       }
;;;1017   
;;;1018       return rev;
00003e  4628              MOV      r0,r5
;;;1019   }
000040  bd70              POP      {r4-r6,pc}
                  |L24.66|
000042  2500              MOVS     r5,#0                 ;996
000044  e7fb              B        |L24.62|
;;;1020   
                          ENDP


                          AREA ||i.CAN_WaitMsg||, CODE, READONLY, ALIGN=1

                  CAN_WaitMsg PROC
;;;275      */
;;;276    void CAN_WaitMsg(CAN_T *tCAN)
000000  2100              MOVS     r1,#0
;;;277    {
;;;278        tCAN->STATUS = 0x0ul; /* clr status */
000002  6041              STR      r1,[r0,#4]
                  |L25.4|
;;;279    
;;;280        while(1)
;;;281        {
;;;282            if(tCAN->IF[1].MCON & CAN_IF_MCON_NEWDAT_Msk)   /* check new data */
000004  f8d01098          LDR      r1,[r0,#0x98]
000008  0409              LSLS     r1,r1,#16
00000a  d402              BMI      |L25.18|
;;;283            {
;;;284                /* New Data IN */
;;;285                break;
;;;286            }
;;;287            else
;;;288            {
;;;289            }
;;;290    
;;;291            if(tCAN->STATUS & CAN_STATUS_RXOK_Msk)
00000c  6841              LDR      r1,[r0,#4]
;;;292            {
;;;293                /* Rx OK */
;;;294            }
;;;295            else
;;;296            {
;;;297            }
;;;298    
;;;299            if(tCAN->STATUS & CAN_STATUS_LEC_Msk)
00000e  6841              LDR      r1,[r0,#4]
000010  e7f8              B        |L25.4|
                  |L25.18|
;;;300            {
;;;301                /* Error */
;;;302            }
;;;303            else
;;;304            {
;;;305            }
;;;306        }
;;;307    }
000012  4770              BX       lr
;;;308    
                          ENDP


                          AREA ||i.LockIF||, CODE, READONLY, ALIGN=2

                  LockIF PROC
;;;59       */
;;;60     static uint32_t LockIF(CAN_T *tCAN)
000000  b570              PUSH     {r4-r6,lr}
;;;61     {
;;;62         uint32_t u32CanNo;
;;;63         uint32_t u32FreeIfNo;
;;;64         uint32_t u32IntMask;
;;;65     
;;;66     #if defined(CAN1)
;;;67         if(tCAN == CAN0)
000002  4a19              LDR      r2,|L26.104|
000004  4290              CMP      r0,r2
000006  d101              BNE      |L26.12|
;;;68             u32CanNo = 0ul;
000008  2100              MOVS     r1,#0
00000a  e008              B        |L26.30|
                  |L26.12|
;;;69         else if(tCAN == CAN1)
00000c  4a17              LDR      r2,|L26.108|
00000e  4290              CMP      r0,r2
000010  d101              BNE      |L26.22|
;;;70             u32CanNo = 1ul;
000012  2101              MOVS     r1,#1
000014  e003              B        |L26.30|
                  |L26.22|
;;;71         #if defined(CAN2)
;;;72         else if(tCAN == CAN2)
000016  4a16              LDR      r2,|L26.112|
000018  4290              CMP      r0,r2
00001a  d100              BNE      |L26.30|
;;;73             u32CanNo = 2ul;
00001c  2102              MOVS     r1,#2
                  |L26.30|
;;;74         #endif
;;;75     #else /* defined(CAN0) || defined(CAN) */
;;;76         u32CanNo = 0ul;
;;;77     #endif
;;;78     
;;;79         u32FreeIfNo = 2ul;
;;;80     
;;;81         /* Disable CAN interrupt */
;;;82         u32IntMask = tCAN->CON & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
00001e  6803              LDR      r3,[r0,#0]
000020  2202              MOVS     r2,#2                 ;79
;;;83         tCAN->CON = tCAN->CON & ~(CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
000022  6804              LDR      r4,[r0,#0]
000024  f003030e          AND      r3,r3,#0xe            ;82
000028  f024040e          BIC      r4,r4,#0xe
00002c  6004              STR      r4,[r0,#0]
;;;84     
;;;85         /* Check interface 1 is available or not */
;;;86         if((tCAN->IF[0ul].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0ul)
00002e  6a04              LDR      r4,[r0,#0x20]
000030  f04f0501          MOV      r5,#1                 ;70
000034  0426              LSLS     r6,r4,#16
;;;87         {
;;;88             if(gu8LockCanIf[u32CanNo][0ul] == 0ul)
000036  4c0f              LDR      r4,|L26.116|
000038  d402              BMI      |L26.64|
00003a  f8146011          LDRB     r6,[r4,r1,LSL #1]
00003e  b146              CBZ      r6,|L26.82|
                  |L26.64|
;;;89             {
;;;90                 gu8LockCanIf[u32CanNo][0ul] = 1u;
;;;91                 u32FreeIfNo = 0ul;
;;;92             }
;;;93             else
;;;94             {
;;;95             }
;;;96         }
;;;97         else
;;;98         {
;;;99         }
;;;100    
;;;101        /* Or check interface 2 is available or not */
;;;102        if(u32FreeIfNo == 2ul)
;;;103        {
;;;104            if((tCAN->IF[1ul].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0ul)
000040  f8d06080          LDR      r6,[r0,#0x80]
000044  0436              LSLS     r6,r6,#16
000046  d40a              BMI      |L26.94|
;;;105            {
;;;106                if(gu8LockCanIf[u32CanNo][1ul] == 0ul)
000048  eb040141          ADD      r1,r4,r1,LSL #1
00004c  784c              LDRB     r4,[r1,#1]
00004e  b124              CBZ      r4,|L26.90|
000050  e005              B        |L26.94|
                  |L26.82|
000052  f8045011          STRB     r5,[r4,r1,LSL #1]     ;90
000056  2200              MOVS     r2,#0                 ;91
000058  e001              B        |L26.94|
                  |L26.90|
;;;107                {
;;;108                    gu8LockCanIf[u32CanNo][1ul] = 1u;
00005a  704d              STRB     r5,[r1,#1]
;;;109                    u32FreeIfNo = 1ul;
00005c  2201              MOVS     r2,#1
                  |L26.94|
;;;110                }
;;;111                else
;;;112                {
;;;113                }
;;;114            }
;;;115            else
;;;116            {
;;;117            }
;;;118        }
;;;119        else
;;;120        {
;;;121        }
;;;122    
;;;123        /* Enable CAN interrupt */
;;;124        tCAN->CON |= u32IntMask;
00005e  6801              LDR      r1,[r0,#0]
000060  4319              ORRS     r1,r1,r3
000062  6001              STR      r1,[r0,#0]
;;;125    
;;;126        return u32FreeIfNo;
000064  4610              MOV      r0,r2
;;;127    }
000066  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP

                  |L26.104|
                          DCD      0x400a0000
                  |L26.108|
                          DCD      0x400a1000
                  |L26.112|
                          DCD      0x400a2000
                  |L26.116|
                          DCD      ||.data||

                          AREA ||i.LockIF_TL||, CODE, READONLY, ALIGN=1

                  LockIF_TL PROC
;;;138      */
;;;139    static uint32_t LockIF_TL(CAN_T *tCAN)
000000  b570              PUSH     {r4-r6,lr}
;;;140    {
000002  4606              MOV      r6,r0
;;;141        uint32_t u32Count;
;;;142        uint32_t u32FreeIfNo;
;;;143    
;;;144        for(u32Count = 0ul; u32Count < RETRY_COUNTS; u32Count++)
000004  2400              MOVS     r4,#0
000006  f04f5580          MOV      r5,#0x10000000
                  |L27.10|
;;;145        {
;;;146            if((u32FreeIfNo = LockIF(tCAN)) != 2ul)
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       LockIF
000010  2802              CMP      r0,#2
000012  d102              BNE      |L27.26|
000014  1c64              ADDS     r4,r4,#1
000016  42ac              CMP      r4,r5                 ;144
000018  d3f7              BCC      |L27.10|
                  |L27.26|
;;;147            {
;;;148                break;
;;;149            }
;;;150            else
;;;151            {
;;;152            }
;;;153        }
;;;154    
;;;155        return u32FreeIfNo;
;;;156    }
00001a  bd70              POP      {r4-r6,pc}
;;;157    
                          ENDP


                          AREA ||i.ReleaseIF||, CODE, READONLY, ALIGN=2

                  ReleaseIF PROC
;;;164      */
;;;165    static void ReleaseIF(CAN_T *tCAN, uint32_t u32IfNo)
000000  b530              PUSH     {r4,r5,lr}
;;;166    {
;;;167        uint32_t u32IntMask;
;;;168        uint32_t u32CanNo;
;;;169    
;;;170        if(u32IfNo >= 2ul)
000002  2902              CMP      r1,#2
000004  d21c              BCS      |L28.64|
;;;171        {
;;;172        }
;;;173        else
;;;174        {
;;;175    #if defined(CAN1)
;;;176        if(tCAN == CAN0)
000006  4b0f              LDR      r3,|L28.68|
000008  4298              CMP      r0,r3
00000a  d101              BNE      |L28.16|
;;;177            u32CanNo = 0ul;
00000c  2200              MOVS     r2,#0
00000e  e008              B        |L28.34|
                  |L28.16|
;;;178        else if(tCAN == CAN1)
000010  4b0d              LDR      r3,|L28.72|
000012  4298              CMP      r0,r3
000014  d101              BNE      |L28.26|
;;;179            u32CanNo = 1ul;
000016  2201              MOVS     r2,#1
000018  e003              B        |L28.34|
                  |L28.26|
;;;180        #if defined(CAN2)
;;;181        else if(tCAN == CAN2)
00001a  4b0c              LDR      r3,|L28.76|
00001c  4298              CMP      r0,r3
00001e  d100              BNE      |L28.34|
;;;182            u32CanNo = 2ul;
000020  2202              MOVS     r2,#2
                  |L28.34|
;;;183        #endif
;;;184    #else /* defined(CAN0) || defined(CAN) */
;;;185            u32CanNo = 0ul;
;;;186    #endif
;;;187    
;;;188            /* Disable CAN interrupt */
;;;189            u32IntMask = tCAN->CON & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
000022  6803              LDR      r3,[r0,#0]
;;;190            tCAN->CON = tCAN->CON & ~(CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
000024  6804              LDR      r4,[r0,#0]
000026  f003030e          AND      r3,r3,#0xe            ;189
00002a  f024040e          BIC      r4,r4,#0xe
00002e  6004              STR      r4,[r0,#0]
;;;191    
;;;192            gu8LockCanIf[u32CanNo][u32IfNo] = 0u;
000030  4d07              LDR      r5,|L28.80|
000032  2400              MOVS     r4,#0
000034  eb050242          ADD      r2,r5,r2,LSL #1
000038  5454              STRB     r4,[r2,r1]
;;;193    
;;;194            /* Enable CAN interrupt */
;;;195            tCAN->CON |= u32IntMask;
00003a  6801              LDR      r1,[r0,#0]
00003c  4319              ORRS     r1,r1,r3
00003e  6001              STR      r1,[r0,#0]
                  |L28.64|
;;;196        }
;;;197    }
000040  bd30              POP      {r4,r5,pc}
;;;198    
                          ENDP

000042  0000              DCW      0x0000
                  |L28.68|
                          DCD      0x400a0000
                  |L28.72|
                          DCD      0x400a1000
                  |L28.76|
                          DCD      0x400a2000
                  |L28.80|
                          DCD      ||.data||

                          AREA ||i.can_update_spt||, CODE, READONLY, ALIGN=1

                  can_update_spt PROC
;;;198    
;;;199    static int can_update_spt(int sampl_pt, int tseg, int *tseg1, int *tseg2)
000000  b530              PUSH     {r4,r5,lr}
;;;200    {
;;;201        *tseg2 = tseg + 1 - (sampl_pt * (tseg + 1)) / 1000;
000002  1c4c              ADDS     r4,r1,#1
000004  4360              MULS     r0,r4,r0
000006  f44f757a          MOV      r5,#0x3e8
00000a  fb90f0f5          SDIV     r0,r0,r5
00000e  1a08              SUBS     r0,r1,r0
000010  1c40              ADDS     r0,r0,#1
000012  6018              STR      r0,[r3,#0]            ;200
000014  d009              BEQ      |L29.42|
;;;202        if (*tseg2 < TSEG2_MIN)
;;;203        {
;;;204            *tseg2 = TSEG2_MIN;
;;;205        }
;;;206        else
;;;207        {
;;;208        }
;;;209    
;;;210        if (*tseg2 > TSEG2_MAX)
000016  2808              CMP      r0,#8
000018  d901              BLS      |L29.30|
;;;211        {
;;;212            *tseg2 = TSEG2_MAX;
00001a  2008              MOVS     r0,#8
                  |L29.28|
00001c  6018              STR      r0,[r3,#0]            ;204
                  |L29.30|
;;;213        }
;;;214        else
;;;215        {
;;;216        }
;;;217    
;;;218        *tseg1 = tseg - *tseg2;
00001e  1a08              SUBS     r0,r1,r0
;;;219        if (*tseg1 > TSEG1_MAX)
000020  6010              STR      r0,[r2,#0]
000022  2810              CMP      r0,#0x10
000024  d803              BHI      |L29.46|
;;;220        {
;;;221            *tseg1 = TSEG1_MAX;
;;;222            *tseg2 = tseg - *tseg1;
000026  6818              LDR      r0,[r3,#0]
000028  e006              B        |L29.56|
                  |L29.42|
00002a  2001              MOVS     r0,#1                 ;204
00002c  e7f6              B        |L29.28|
                  |L29.46|
00002e  2010              MOVS     r0,#0x10              ;221
000030  6010              STR      r0,[r2,#0]
000032  f1a10010          SUB      r0,r1,#0x10
000036  6018              STR      r0,[r3,#0]
                  |L29.56|
;;;223        }
;;;224        else
;;;225        {
;;;226        }
;;;227    
;;;228        return 1000 * (tseg + 1 - *tseg2) / (tseg + 1);
000038  1a08              SUBS     r0,r1,r0
00003a  f44f717a          MOV      r1,#0x3e8
00003e  1c40              ADDS     r0,r0,#1
000040  4348              MULS     r0,r1,r0
000042  fb90f0f4          SDIV     r0,r0,r4
;;;229    }
000046  bd30              POP      {r4,r5,pc}
;;;230    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  gu8LockCanIf
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_0fdded17____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_can_c_0fdded17____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_0fdded17____REVSH|
#line 402
|__asm___5_can_c_0fdded17____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_0fdded17____RRX|
#line 587
|__asm___5_can_c_0fdded17____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
