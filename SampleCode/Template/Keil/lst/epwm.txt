; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\epwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\epwm.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -D__FPU_PRESENT=1 --omf_browse=.\obj\epwm.crf ..\..\..\Library\StdDriver\src\epwm.c]
                          THUMB

                          AREA ||i.EPWM_ClearADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  EPWM_ClearADCTriggerFlag PROC
;;;323     */
;;;324    void EPWM_ClearADCTriggerFlag(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  f44f3280          MOV      r2,#0x10000
;;;325    {
;;;326        (epwm)->STATUS = (EPWM_STATUS_EADCTRGF0_Msk << u32ChannelNum);
000004  408a              LSLS     r2,r2,r1
000006  f8c02120          STR      r2,[r0,#0x120]
;;;327    }
00000a  4770              BX       lr
;;;328    
                          ENDP


                          AREA ||i.EPWM_ClearAccInt||, CODE, READONLY, ALIGN=1

                  EPWM_ClearAccInt PROC
;;;1009    */
;;;1010   void EPWM_ClearAccInt(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  2201              MOVS     r2,#1
;;;1011   {
;;;1012       (epwm)->AINTSTS = (1UL << (u32ChannelNum));
000002  408a              LSLS     r2,r2,r1
000004  f8c02150          STR      r2,[r0,#0x150]
;;;1013   }
000008  4770              BX       lr
;;;1014   
                          ENDP


                          AREA ||i.EPWM_ClearCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  EPWM_ClearCaptureIntFlag PROC
;;;674     */
;;;675    void EPWM_ClearCaptureIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  408a              LSLS     r2,r2,r1
;;;676    {
;;;677        (epwm)->CAPIF = (u32Edge << u32ChannelNum);
000002  f8c02254          STR      r2,[r0,#0x254]
;;;678    }
000006  4770              BX       lr
;;;679    
                          ENDP


                          AREA ||i.EPWM_ClearDACTriggerFlag||, CODE, READONLY, ALIGN=1

                  EPWM_ClearDACTriggerFlag PROC
;;;387     */
;;;388    void EPWM_ClearDACTriggerFlag(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  f04f7180          MOV      r1,#0x1000000
;;;389    {
;;;390        (epwm)->STATUS = EPWM_STATUS_DACTRGF_Msk;
000004  f8c01120          STR      r1,[r0,#0x120]
;;;391    }
000008  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.EPWM_ClearDutyIntFlag||, CODE, READONLY, ALIGN=2

                  EPWM_ClearDutyIntFlag PROC
;;;736     */
;;;737    void EPWM_ClearDutyIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  4a02              LDR      r2,|L5.12|
;;;738    {
;;;739        (epwm)->INTSTS0 = (EPWM_INTSTS0_CMPUIF0_Msk | EPWM_INTSTS0_CMPDIF0_Msk) << u32ChannelNum;
000002  408a              LSLS     r2,r2,r1
000004  f8c020e8          STR      r2,[r0,#0xe8]
;;;740    }
000008  4770              BX       lr
;;;741    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x01010000

                          AREA ||i.EPWM_ClearFTDutyIntFlag||, CODE, READONLY, ALIGN=1

                  EPWM_ClearFTDutyIntFlag PROC
;;;1094    */
;;;1095   void EPWM_ClearFTDutyIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  084a              LSRS     r2,r1,#1
;;;1096   {
;;;1097       (epwm)->FTCI = ((EPWM_FTCI_FTCMU0_Msk | EPWM_FTCI_FTCMD0_Msk) << (u32ChannelNum >> 1U));
000002  f2401101          MOV      r1,#0x101
000006  4091              LSLS     r1,r1,r2
000008  f8c0134c          STR      r1,[r0,#0x34c]
;;;1098   }
00000c  4770              BX       lr
;;;1099   
                          ENDP


                          AREA ||i.EPWM_ClearFaultBrakeIntFlag||, CODE, READONLY, ALIGN=1

                  EPWM_ClearFaultBrakeIntFlag PROC
;;;799     */
;;;800    void EPWM_ClearFaultBrakeIntFlag(EPWM_T *epwm, uint32_t u32BrakeSource)
000000  223f              MOVS     r2,#0x3f
;;;801    {
;;;802        (epwm)->INTSTS1 = (0x3fUL << u32BrakeSource);
000002  408a              LSLS     r2,r2,r1
000004  f8c020ec          STR      r2,[r0,#0xec]
;;;803    }
000008  4770              BX       lr
;;;804    
                          ENDP


                          AREA ||i.EPWM_ClearPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  EPWM_ClearPeriodIntFlag PROC
;;;858     */
;;;859    void EPWM_ClearPeriodIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f44f7280          MOV      r2,#0x100
;;;860    {
;;;861        (epwm)->INTSTS0 = ((1UL << EPWM_INTSTS0_PIF0_Pos) << u32ChannelNum);
000004  408a              LSLS     r2,r2,r1
000006  f8c020e8          STR      r2,[r0,#0xe8]
;;;862    }
00000a  4770              BX       lr
;;;863    
                          ENDP


                          AREA ||i.EPWM_ClearWrapAroundFlag||, CODE, READONLY, ALIGN=1

                  EPWM_ClearWrapAroundFlag PROC
;;;1453    */
;;;1454   void EPWM_ClearWrapAroundFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  2201              MOVS     r2,#1
;;;1455   {
;;;1456       (epwm)->STATUS = (EPWM_STATUS_CNTMAXF0_Msk << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  f8c02120          STR      r2,[r0,#0x120]
;;;1457   }
000008  4770              BX       lr
;;;1458   
                          ENDP


                          AREA ||i.EPWM_ClearZeroIntFlag||, CODE, READONLY, ALIGN=1

                  EPWM_ClearZeroIntFlag PROC
;;;916     */
;;;917    void EPWM_ClearZeroIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  2201              MOVS     r2,#1
;;;918    {
;;;919        (epwm)->INTSTS0 = ((1UL << EPWM_INTEN0_ZIEN0_Pos) << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  f8c020e8          STR      r2,[r0,#0xe8]
;;;920    }
000008  4770              BX       lr
;;;921    
                          ENDP


                          AREA ||i.EPWM_ConfigCaptureChannel||, CODE, READONLY, ALIGN=2

                  EPWM_ConfigCaptureChannel PROC
;;;35      */
;;;36     uint32_t EPWM_ConfigCaptureChannel(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32UnitTimeNsec, uint32_t u32CaptureEdge)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;37     {
000004  4605              MOV      r5,r0
;;;38         uint32_t u32Src;
;;;39         uint32_t u32EPWMClockSrc;
;;;40         uint32_t u32NearestUnitTimeNsec;
;;;41         uint32_t u16Prescale = 1U, u16CNR = 0xFFFFU;
000006  2401              MOVS     r4,#1
;;;42     
;;;43         if(epwm == EPWM0)
;;;44         {
;;;45             u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_EPWM0SEL_Msk;
000008  07a0              LSLS     r0,r4,#30
00000a  f8df8098          LDR      r8,|L11.164|
;;;46         }
;;;47         else     /* (epwm == EPWM1) */
;;;48         {
;;;49             u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_EPWM1SEL_Msk;
00000e  f8d00218          LDR      r0,[r0,#0x218]
000012  4691              MOV      r9,r2                 ;37
000014  460e              MOV      r6,r1                 ;37
000016  f64f77ff          MOV      r7,#0xffff            ;41
00001a  4545              CMP      r5,r8                 ;43
00001c  d102              BNE      |L11.36|
00001e  f0000001          AND      r0,r0,#1              ;45
000022  e001              B        |L11.40|
                  |L11.36|
000024  f0000002          AND      r0,r0,#2
                  |L11.40|
;;;50         }
;;;51     
;;;52         if(u32Src == 0U)
000028  b130              CBZ      r0,|L11.56|
;;;53         {
;;;54             /* clock source is from PLL clock */
;;;55             u32EPWMClockSrc = CLK_GetPLLClockFreq();
;;;56         }
;;;57         else
;;;58         {
;;;59             /* clock source is from PCLK */
;;;60             SystemCoreClockUpdate();
00002a  f7fffffe          BL       SystemCoreClockUpdate
;;;61             if(epwm == EPWM0)
00002e  4545              CMP      r5,r8
000030  d105              BNE      |L11.62|
;;;62             {
;;;63                 u32EPWMClockSrc = CLK_GetPCLK0Freq();
000032  f7fffffe          BL       CLK_GetPCLK0Freq
000036  e004              B        |L11.66|
                  |L11.56|
000038  f7fffffe          BL       CLK_GetPLLClockFreq
00003c  e001              B        |L11.66|
                  |L11.62|
;;;64             }
;;;65             else     /* (epwm == EPWM1) */
;;;66             {
;;;67                 u32EPWMClockSrc = CLK_GetPCLK1Freq();
00003e  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L11.66|
;;;68             }
;;;69         }
;;;70     
;;;71         u32EPWMClockSrc /= 1000U;
000042  f44f717a          MOV      r1,#0x3e8
000046  fbb0f1f1          UDIV     r1,r0,r1
;;;72         for(u16Prescale = 1U; u16Prescale <= 0x1000U; u16Prescale++)
;;;73         {
;;;74             uint32_t u32Exit = 0U;
;;;75             u32NearestUnitTimeNsec = (1000000U * u16Prescale) / u32EPWMClockSrc;
;;;76             if(u32NearestUnitTimeNsec < u32UnitTimeNsec)
;;;77             {
;;;78                 if(u16Prescale == 0x1000U)    /* limit to the maximum unit time(nano second) */
00004a  f44f5880          MOV      r8,#0x1000
                  |L11.78|
00004e  4816              LDR      r0,|L11.168|
000050  4360              MULS     r0,r4,r0              ;75
000052  fbb0f0f1          UDIV     r0,r0,r1              ;75
000056  4548              CMP      r0,r9                 ;76
000058  d20c              BCS      |L11.116|
;;;79                 {
;;;80                     u32Exit = 1U;
;;;81                 }
;;;82                 else
;;;83                 {
;;;84                     u32Exit = 0U;
;;;85                 }
;;;86                 if(!((1000000U * (u16Prescale + 1U) > (u32NearestUnitTimeNsec * u32EPWMClockSrc))))
00005a  1c62              ADDS     r2,r4,#1
00005c  f6435c09          MOV      r12,#0x3d09
000060  fb00f301          MUL      r3,r0,r1
000064  fb02f20c          MUL      r2,r2,r12
000068  ebb31f82          CMP      r3,r2,LSL #6
00006c  d202              BCS      |L11.116|
00006e  1c64              ADDS     r4,r4,#1
000070  4544              CMP      r4,r8                 ;72
;;;87                 {
;;;88                     u32Exit = 1U;
;;;89                 }
;;;90                 else
;;;91                 {
;;;92                     u32Exit = 0U;
000072  d9ec              BLS      |L11.78|
                  |L11.116|
;;;93                 }
;;;94             }
;;;95             else
;;;96             {
;;;97                 u32Exit = 1U;
;;;98             }
;;;99             if (u32Exit == 1U)
;;;100            {
;;;101                break;
;;;102            }
;;;103            else {}
;;;104        }
;;;105    
;;;106        /* convert to real register value */
;;;107        /* every two channels share a prescaler */
;;;108        u16Prescale -= 1U;
;;;109        EPWM_SET_PRESCALER(epwm, u32ChannelNum, u16Prescale);
000074  0871              LSRS     r1,r6,#1
000076  eb050181          ADD      r1,r5,r1,LSL #2
00007a  1e64              SUBS     r4,r4,#1
00007c  614c              STR      r4,[r1,#0x14]
;;;110    
;;;111        /* set EPWM to down count type(edge aligned) */
;;;112        (epwm)->CTL1 = ((epwm)->CTL1 & ~((1UL << EPWM_CTL1_CNTTYPE0_Pos) << (u32ChannelNum << 1U))) | (1UL << (u32ChannelNum << 1U));
00007e  686a              LDR      r2,[r5,#4]
000080  0073              LSLS     r3,r6,#1
000082  2101              MOVS     r1,#1
000084  4099              LSLS     r1,r1,r3
000086  438a              BICS     r2,r2,r1
000088  430a              ORRS     r2,r2,r1
00008a  606a              STR      r2,[r5,#4]
;;;113        /* set EPWM to auto-reload mode */
;;;114        (epwm)->CTL1 &= ~((1UL << EPWM_CTL1_CNTMODE0_Pos) << u32ChannelNum);
00008c  6869              LDR      r1,[r5,#4]
00008e  f44f3280          MOV      r2,#0x10000
000092  40b2              LSLS     r2,r2,r6
000094  4391              BICS     r1,r1,r2
000096  6069              STR      r1,[r5,#4]
;;;115        EPWM_SET_CNR(epwm, u32ChannelNum, u16CNR);
000098  eb050186          ADD      r1,r5,r6,LSL #2
00009c  630f              STR      r7,[r1,#0x30]
;;;116    
;;;117        return (u32NearestUnitTimeNsec);
;;;118    }
00009e  e8bd87f0          POP      {r4-r10,pc}
;;;119    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L11.164|
                          DCD      0x40058000
                  |L11.168|
                          DCD      0x000f4240

                          AREA ||i.EPWM_ConfigOutputChannel||, CODE, READONLY, ALIGN=2

                  EPWM_ConfigOutputChannel PROC
;;;133     */
;;;134    uint32_t EPWM_ConfigOutputChannel(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Frequency, uint32_t u32DutyCycle)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;135    {
000004  4605              MOV      r5,r0
;;;136        uint32_t u32Src;
;;;137        uint32_t u32EPWMClockSrc;
;;;138        uint32_t i;
;;;139        uint32_t u32Prescale = 1U, u32CNR = 0xFFFFU;
000006  2401              MOVS     r4,#1
;;;140    
;;;141        if(epwm == EPWM0)
;;;142        {
;;;143            u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_EPWM0SEL_Msk;
000008  07a0              LSLS     r0,r4,#30
00000a  f8df90b0          LDR      r9,|L12.188|
;;;144        }
;;;145        else     /* (epwm == EPWM1) */
;;;146        {
;;;147            u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_EPWM1SEL_Msk;
00000e  f8d00218          LDR      r0,[r0,#0x218]
000012  469a              MOV      r10,r3                ;135
000014  4690              MOV      r8,r2                 ;135
000016  460f              MOV      r7,r1                 ;135
000018  f64f76ff          MOV      r6,#0xffff            ;139
00001c  454d              CMP      r5,r9                 ;141
00001e  d102              BNE      |L12.38|
000020  f0000001          AND      r0,r0,#1              ;143
000024  e001              B        |L12.42|
                  |L12.38|
000026  f0000002          AND      r0,r0,#2
                  |L12.42|
;;;148        }
;;;149    
;;;150        if(u32Src == 0U)
00002a  b130              CBZ      r0,|L12.58|
;;;151        {
;;;152            /* clock source is from PLL clock */
;;;153            u32EPWMClockSrc = CLK_GetPLLClockFreq();
;;;154        }
;;;155        else
;;;156        {
;;;157            /* clock source is from PCLK */
;;;158            SystemCoreClockUpdate();
00002c  f7fffffe          BL       SystemCoreClockUpdate
;;;159            if(epwm == EPWM0)
000030  454d              CMP      r5,r9
000032  d105              BNE      |L12.64|
;;;160            {
;;;161                u32EPWMClockSrc = CLK_GetPCLK0Freq();
000034  f7fffffe          BL       CLK_GetPCLK0Freq
000038  e004              B        |L12.68|
                  |L12.58|
00003a  f7fffffe          BL       CLK_GetPLLClockFreq
00003e  e001              B        |L12.68|
                  |L12.64|
;;;162            }
;;;163            else     /* (epwm == EPWM1) */
;;;164            {
;;;165                u32EPWMClockSrc = CLK_GetPCLK1Freq();
000040  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L12.68|
;;;166            }
;;;167        }
;;;168    
;;;169        for(u32Prescale = 1U; u32Prescale < 0xFFFU; u32Prescale++)   /* prescale could be 0~0xFFF */
;;;170        {
;;;171            i = (u32EPWMClockSrc / u32Frequency) / u32Prescale;
;;;172            /* If target value is larger than CNR, need to use a larger prescaler */
;;;173            if(i < (0x10000U))
000044  f44f3280          MOV      r2,#0x10000
000048  f64073ff          MOV      r3,#0xfff             ;169
                  |L12.76|
00004c  fbb0f1f8          UDIV     r1,r0,r8              ;171
000050  fbb1f1f4          UDIV     r1,r1,r4              ;171
000054  4291              CMP      r1,r2
000056  d201              BCS      |L12.92|
;;;174            {
;;;175                u32CNR = i;
000058  460e              MOV      r6,r1
;;;176                break;
00005a  e002              B        |L12.98|
                  |L12.92|
00005c  1c64              ADDS     r4,r4,#1
00005e  429c              CMP      r4,r3                 ;169
000060  d3f4              BCC      |L12.76|
                  |L12.98|
;;;177            }
;;;178        }
;;;179        /* Store return value here 'cos we're gonna change u16Prescale & u16CNR to the real value to fill into register */
;;;180        i = u32EPWMClockSrc / (u32Prescale * u32CNR);
000062  fb04f106          MUL      r1,r4,r6
000066  fbb0f3f1          UDIV     r3,r0,r1
;;;181    
;;;182        /* convert to real register value */
;;;183        /* every two channels share a prescaler */
;;;184        u32Prescale -= 1U;
;;;185        EPWM_SET_PRESCALER(epwm, u32ChannelNum, u32Prescale);
00006a  0878              LSRS     r0,r7,#1
00006c  eb050080          ADD      r0,r5,r0,LSL #2
000070  1e64              SUBS     r4,r4,#1
000072  6144              STR      r4,[r0,#0x14]
;;;186        /* set EPWM to up counter type(edge aligned) and auto-reload mode */
;;;187        (epwm)->CTL1 = ((epwm)->CTL1 & ~(((1UL << EPWM_CTL1_CNTTYPE0_Pos) << (u32ChannelNum << 1U))|((1UL << EPWM_CTL1_CNTMODE0_Pos) << u32ChannelNum)));
000074  0078              LSLS     r0,r7,#1
000076  2101              MOVS     r1,#1
000078  4081              LSLS     r1,r1,r0
00007a  40ba              LSLS     r2,r2,r7
00007c  686c              LDR      r4,[r5,#4]
00007e  430a              ORRS     r2,r2,r1
000080  4394              BICS     r4,r4,r2
000082  606c              STR      r4,[r5,#4]
;;;188    
;;;189        u32CNR -= 1U;
;;;190        EPWM_SET_CNR(epwm, u32ChannelNum, u32CNR);
000084  eb050287          ADD      r2,r5,r7,LSL #2
000088  1e76              SUBS     r6,r6,#1
00008a  6316              STR      r6,[r2,#0x30]
00008c  1c76              ADDS     r6,r6,#1
;;;191        EPWM_SET_CMR(epwm, u32ChannelNum, u32DutyCycle * (u32CNR + 1U) / 100U);
00008e  fb0af406          MUL      r4,r10,r6
000092  2664              MOVS     r6,#0x64
000094  fbb4f4f6          UDIV     r4,r4,r6
000098  6514              STR      r4,[r2,#0x50]
;;;192    
;;;193        (epwm)->WGCTL0 = ((epwm)->WGCTL0 & ~(((1UL << EPWM_WGCTL0_PRDPCTL0_Pos) | (1UL << EPWM_WGCTL0_ZPCTL0_Pos)) << (u32ChannelNum << 1U))) | \
00009a  f8554fb0          LDR      r4,[r5,#0xb0]!
00009e  f04f1201          MOV      r2,#0x10001
0000a2  4082              LSLS     r2,r2,r0
0000a4  2602              MOVS     r6,#2
0000a6  4394              BICS     r4,r4,r2
0000a8  4086              LSLS     r6,r6,r0
0000aa  4334              ORRS     r4,r4,r6
0000ac  602c              STR      r4,[r5,#0]
;;;194                         ((uint32_t)EPWM_OUTPUT_HIGH << ((u32ChannelNum << 1U) + (uint32_t)EPWM_WGCTL0_ZPCTL0_Pos));
;;;195        (epwm)->WGCTL1 = ((epwm)->WGCTL1 & ~(((1UL << EPWM_WGCTL1_CMPDCTL0_Pos) | (1UL << EPWM_WGCTL1_CMPUCTL0_Pos)) << (u32ChannelNum << 1U))) | \
0000ae  6868              LDR      r0,[r5,#4]
0000b0  4390              BICS     r0,r0,r2
0000b2  4308              ORRS     r0,r0,r1
0000b4  6068              STR      r0,[r5,#4]
;;;196                         ((uint32_t)EPWM_OUTPUT_LOW << ((u32ChannelNum << 1U) + (uint32_t)EPWM_WGCTL1_CMPUCTL0_Pos));
;;;197    
;;;198        return(i);
0000b6  4618              MOV      r0,r3
;;;199    }
0000b8  e8bd87f0          POP      {r4-r10,pc}
;;;200    
                          ENDP

                  |L12.188|
                          DCD      0x40058000

                          AREA ||i.EPWM_ConfigSyncPhase||, CODE, READONLY, ALIGN=1

                  EPWM_ConfigSyncPhase PROC
;;;1170    */
;;;1171   void EPWM_ConfigSyncPhase(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32SyncSrc, uint32_t u32Direction, uint32_t u32StartPhase)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1172   {
;;;1173       /* every two channels shares the same setting */
;;;1174       u32ChannelNum >>= 1U;
000002  0849              LSRS     r1,r1,#1
;;;1175       (epwm)->SYNC = (((epwm)->SYNC & ~(((3UL << EPWM_SYNC_SINSRC0_Pos) << (u32ChannelNum << 1U)) | ((1UL << EPWM_SYNC_PHSDIR0_Pos) << u32ChannelNum))) | \
000004  004c              LSLS     r4,r1,#1
000006  f44f7540          MOV      r5,#0x300
00000a  40a5              LSLS     r5,r5,r4
00000c  f04f7780          MOV      r7,#0x1000000
000010  408f              LSLS     r7,r7,r1
000012  433d              ORRS     r5,r5,r7
000014  9e05              LDR      r6,[sp,#0x14]
000016  6887              LDR      r7,[r0,#8]
000018  408b              LSLS     r3,r3,r1
00001a  43af              BICS     r7,r7,r5
00001c  ea476303          ORR      r3,r7,r3,LSL #24
000020  40a2              LSLS     r2,r2,r4
000022  ea432202          ORR      r2,r3,r2,LSL #8
000026  6082              STR      r2,[r0,#8]
;;;1176                       (u32Direction << EPWM_SYNC_PHSDIR0_Pos << u32ChannelNum) | ((u32SyncSrc << EPWM_SYNC_SINSRC0_Pos) << (u32ChannelNum << 1U)));
;;;1177       (epwm)->PHS[(u32ChannelNum)] = u32StartPhase;
000028  eb000081          ADD      r0,r0,r1,LSL #2
00002c  f8c06080          STR      r6,[r0,#0x80]
;;;1178   }
000030  bdf0              POP      {r4-r7,pc}
;;;1179   
                          ENDP


                          AREA ||i.EPWM_DisableADCTrigger||, CODE, READONLY, ALIGN=1

                  EPWM_DisableADCTrigger PROC
;;;301     */
;;;302    void EPWM_DisableADCTrigger(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  00ca              LSLS     r2,r1,#3
;;;303    {
;;;304        if(u32ChannelNum < 4U)
;;;305        {
;;;306            (epwm)->EADCTS0 &= ~(EPWM_EADCTS0_TRGEN0_Msk << (u32ChannelNum << 3U));
000002  2380              MOVS     r3,#0x80
000004  2904              CMP      r1,#4                 ;304
000006  d203              BCS      |L14.16|
000008  f8501ff8          LDR      r1,[r0,#0xf8]!
00000c  4093              LSLS     r3,r3,r2
00000e  e003              B        |L14.24|
                  |L14.16|
000010  3a20              SUBS     r2,r2,#0x20
;;;307        }
;;;308        else
;;;309        {
;;;310            (epwm)->EADCTS1 &= ~(EPWM_EADCTS1_TRGEN4_Msk << ((u32ChannelNum - 4U) << 3U));
000012  f8501ffc          LDR      r1,[r0,#0xfc]!
000016  4093              LSLS     r3,r3,r2
                  |L14.24|
000018  4399              BICS     r1,r1,r3              ;306
00001a  6001              STR      r1,[r0,#0]            ;306
;;;311        }
;;;312    }
00001c  4770              BX       lr
;;;313    
                          ENDP


                          AREA ||i.EPWM_DisableAcc||, CODE, READONLY, ALIGN=1

                  EPWM_DisableAcc PROC
;;;967     */
;;;968    void EPWM_DisableAcc(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  eb000081          ADD      r0,r0,r1,LSL #2
;;;969    {
;;;970        (epwm)->IFA[u32ChannelNum] = ((epwm)->IFA[u32ChannelNum] & ~(EPWM_IFA0_IFAEN_Msk));
000004  f8d01130          LDR      r1,[r0,#0x130]
000008  f0214100          BIC      r1,r1,#0x80000000
00000c  f8c01130          STR      r1,[r0,#0x130]
;;;971    }
000010  4770              BX       lr
;;;972    
                          ENDP


                          AREA ||i.EPWM_DisableAccInt||, CODE, READONLY, ALIGN=1

                  EPWM_DisableAccInt PROC
;;;995     */
;;;996    void EPWM_DisableAccInt(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d02154          LDR      r2,[r0,#0x154]
;;;997    {
;;;998        (epwm)->AINTEN &= ~(1UL << (u32ChannelNum));
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  f8c02154          STR      r2,[r0,#0x154]
;;;999    }
00000e  4770              BX       lr
;;;1000   
                          ENDP


                          AREA ||i.EPWM_DisableAccPDMA||, CODE, READONLY, ALIGN=1

                  EPWM_DisableAccPDMA PROC
;;;1052    */
;;;1053   void EPWM_DisableAccPDMA(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d02158          LDR      r2,[r0,#0x158]
;;;1054   {
;;;1055       (epwm)->APDMACTL &= ~(1UL << (u32ChannelNum));
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  f8c02158          STR      r2,[r0,#0x158]
;;;1056   }
00000e  4770              BX       lr
;;;1057   
                          ENDP


                          AREA ||i.EPWM_DisableAccStopMode||, CODE, READONLY, ALIGN=1

                  EPWM_DisableAccStopMode PROC
;;;1080    */
;;;1081   void EPWM_DisableAccStopMode(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  eb000081          ADD      r0,r0,r1,LSL #2
;;;1082   {
;;;1083       (epwm)->IFA[u32ChannelNum] &= ~EPWM_IFA0_STPMOD_Msk;
000004  f8d01130          LDR      r1,[r0,#0x130]
000008  f0217180          BIC      r1,r1,#0x1000000
00000c  f8c01130          STR      r1,[r0,#0x130]
;;;1084   }
000010  4770              BX       lr
;;;1085   
                          ENDP


                          AREA ||i.EPWM_DisableBrakeNoiseFilter||, CODE, READONLY, ALIGN=1

                  EPWM_DisableBrakeNoiseFilter PROC
;;;1347    */
;;;1348   void EPWM_DisableBrakeNoiseFilter(EPWM_T *epwm, uint32_t u32BrakePinNum)
000000  f8502fc0          LDR      r2,[r0,#0xc0]!
;;;1349   {
;;;1350       (epwm)->BNF &= ~(EPWM_BNF_BRK0NFEN_Msk << (u32BrakePinNum << 3U));
000004  00cb              LSLS     r3,r1,#3
000006  2101              MOVS     r1,#1
000008  4099              LSLS     r1,r1,r3
00000a  438a              BICS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;1351   }
00000e  4770              BX       lr
;;;1352   
                          ENDP


                          AREA ||i.EPWM_DisableBrakePinInverse||, CODE, READONLY, ALIGN=1

                  EPWM_DisableBrakePinInverse PROC
;;;1375    */
;;;1376   void EPWM_DisableBrakePinInverse(EPWM_T *epwm, uint32_t u32BrakePinNum)
000000  f8502fc0          LDR      r2,[r0,#0xc0]!
;;;1377   {
;;;1378       (epwm)->BNF &= ~(EPWM_BNF_BRK0PINV_Msk << (u32BrakePinNum * (uint32_t)EPWM_BNF_BRK1NFEN_Pos));
000004  00cb              LSLS     r3,r1,#3
000006  2180              MOVS     r1,#0x80
000008  4099              LSLS     r1,r1,r3
00000a  438a              BICS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;1379   }
00000e  4770              BX       lr
;;;1380   
                          ENDP


                          AREA ||i.EPWM_DisableCapture||, CODE, READONLY, ALIGN=1

                  EPWM_DisableCapture PROC
;;;519     */
;;;520    void EPWM_DisableCapture(EPWM_T *epwm, uint32_t u32ChannelMask)
000000  f8d02200          LDR      r2,[r0,#0x200]
;;;521    {
;;;522        (epwm)->CAPINEN &= ~u32ChannelMask;
000004  438a              BICS     r2,r2,r1
000006  f8c02200          STR      r2,[r0,#0x200]
;;;523        (epwm)->CAPCTL &= ~u32ChannelMask;
00000a  f8d02204          LDR      r2,[r0,#0x204]
00000e  438a              BICS     r2,r2,r1
000010  f8c02204          STR      r2,[r0,#0x204]
;;;524    }
000014  4770              BX       lr
;;;525    
                          ENDP


                          AREA ||i.EPWM_DisableCaptureInt||, CODE, READONLY, ALIGN=1

                  EPWM_DisableCaptureInt PROC
;;;657     */
;;;658    void EPWM_DisableCaptureInt(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  f8d03250          LDR      r3,[r0,#0x250]
;;;659    {
;;;660        (epwm)->CAPIEN &= ~(u32Edge << u32ChannelNum);
000004  408a              LSLS     r2,r2,r1
000006  4393              BICS     r3,r3,r2
000008  f8c03250          STR      r3,[r0,#0x250]
;;;661    }
00000c  4770              BX       lr
;;;662    
                          ENDP


                          AREA ||i.EPWM_DisableDACTrigger||, CODE, READONLY, ALIGN=1

                  EPWM_DisableDACTrigger PROC
;;;371     */
;;;372    void EPWM_DisableDACTrigger(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8502ff4          LDR      r2,[r0,#0xf4]!
;;;373    {
;;;374        (epwm)->DACTRGEN &= ~((EPWM_TRIGGER_DAC_ZERO | EPWM_TRIGGER_DAC_PERIOD | EPWM_TRIGGER_DAC_COMPARE_UP | \
000004  f04f3301          MOV      r3,#0x1010101
000008  408b              LSLS     r3,r3,r1
00000a  439a              BICS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
;;;375                               EPWM_TRIGGER_DAC_COMPARE_DOWN) << u32ChannelNum);
;;;376    }
00000e  4770              BX       lr
;;;377    
                          ENDP


                          AREA ||i.EPWM_DisableDeadZone||, CODE, READONLY, ALIGN=1

                  EPWM_DisableDeadZone PROC
;;;622     */
;;;623    void EPWM_DisableDeadZone(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  0849              LSRS     r1,r1,#1
;;;624    {
;;;625        /* every two channels shares the same setting */
;;;626        (epwm)->DTCTL[(u32ChannelNum) >> 1U] &= ~EPWM_DTCTL0_1_DTEN_Msk;
000002  eb000081          ADD      r0,r0,r1,LSL #2
000006  6f01              LDR      r1,[r0,#0x70]
000008  f4213180          BIC      r1,r1,#0x10000
00000c  6701              STR      r1,[r0,#0x70]
;;;627    }
00000e  4770              BX       lr
;;;628    
                          ENDP


                          AREA ||i.EPWM_DisableDutyInt||, CODE, READONLY, ALIGN=2

                  EPWM_DisableDutyInt PROC
;;;722     */
;;;723    void EPWM_DisableDutyInt(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8502fe0          LDR      r2,[r0,#0xe0]!
;;;724    {
;;;725        (epwm)->INTEN0 &= ~((uint32_t)(EPWM_DUTY_INT_DOWN_COUNT_MATCH_CMP | EPWM_DUTY_INT_UP_COUNT_MATCH_CMP) << u32ChannelNum);
000004  4b02              LDR      r3,|L25.16|
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
;;;726    }
00000c  4770              BX       lr
;;;727    
                          ENDP

00000e  0000              DCW      0x0000
                  |L25.16|
                          DCD      0x01010000

                          AREA ||i.EPWM_DisableFaultBrakeInt||, CODE, READONLY, ALIGN=1

                  EPWM_DisableFaultBrakeInt PROC
;;;784     */
;;;785    void EPWM_DisableFaultBrakeInt(EPWM_T *epwm, uint32_t u32BrakeSource)
000000  f8502fe4          LDR      r2,[r0,#0xe4]!
;;;786    {
;;;787        (epwm)->INTEN1 &= ~(0x7UL << u32BrakeSource);
000004  2307              MOVS     r3,#7
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
;;;788    }
00000c  4770              BX       lr
;;;789    
                          ENDP


                          AREA ||i.EPWM_DisableLoadMode||, CODE, READONLY, ALIGN=1

                  EPWM_DisableLoadMode PROC
;;;1146    */
;;;1147   void EPWM_DisableLoadMode(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
000000  6803              LDR      r3,[r0,#0]
;;;1148   {
;;;1149       (epwm)->CTL0 &= ~(u32LoadMode << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  4393              BICS     r3,r3,r2
000006  6003              STR      r3,[r0,#0]
;;;1150   }
000008  4770              BX       lr
;;;1151   
                          ENDP


                          AREA ||i.EPWM_DisableOutput||, CODE, READONLY, ALIGN=1

                  EPWM_DisableOutput PROC
;;;550     */
;;;551    void EPWM_DisableOutput(EPWM_T *epwm, uint32_t u32ChannelMask)
000000  f8502fd8          LDR      r2,[r0,#0xd8]!
;;;552    {
;;;553        (epwm)->POEN &= ~u32ChannelMask;
000004  438a              BICS     r2,r2,r1
000006  6002              STR      r2,[r0,#0]
;;;554    }
000008  4770              BX       lr
;;;555    
                          ENDP


                          AREA ||i.EPWM_DisablePDMA||, CODE, READONLY, ALIGN=1

                  EPWM_DisablePDMA PROC
;;;588     */
;;;589    void EPWM_DisablePDMA(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d0223c          LDR      r2,[r0,#0x23c]
;;;590    {
;;;591        (epwm)->PDMACTL &= ~(EPWM_PDMACTL_CHEN0_1_Msk << ((u32ChannelNum >> 1U) << 3U));
000004  0849              LSRS     r1,r1,#1
000006  00cb              LSLS     r3,r1,#3
000008  2101              MOVS     r1,#1
00000a  4099              LSLS     r1,r1,r3
00000c  438a              BICS     r2,r2,r1
00000e  f8c0223c          STR      r2,[r0,#0x23c]
;;;592    }
000012  4770              BX       lr
;;;593    
                          ENDP


                          AREA ||i.EPWM_DisablePeriodInt||, CODE, READONLY, ALIGN=1

                  EPWM_DisablePeriodInt PROC
;;;844     */
;;;845    void EPWM_DisablePeriodInt(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8502fe0          LDR      r2,[r0,#0xe0]!
;;;846    {
;;;847        (epwm)->INTEN0 &= ~((1UL << EPWM_INTEN0_PIEN0_Pos) << u32ChannelNum);
000004  f44f7380          MOV      r3,#0x100
000008  408b              LSLS     r3,r3,r1
00000a  439a              BICS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
;;;848    }
00000e  4770              BX       lr
;;;849    
                          ENDP


                          AREA ||i.EPWM_DisableSyncNoiseFilter||, CODE, READONLY, ALIGN=1

                  EPWM_DisableSyncNoiseFilter PROC
;;;1259    */
;;;1260   void EPWM_DisableSyncNoiseFilter(EPWM_T *epwm)
000000  6881              LDR      r1,[r0,#8]
;;;1261   {
;;;1262       (epwm)->SYNC &= ~EPWM_SYNC_SNFLTEN_Msk;
000002  f4213180          BIC      r1,r1,#0x10000
000006  6081              STR      r1,[r0,#8]
;;;1263   }
000008  4770              BX       lr
;;;1264   
                          ENDP


                          AREA ||i.EPWM_DisableSyncPhase||, CODE, READONLY, ALIGN=1

                  EPWM_DisableSyncPhase PROC
;;;1214    */
;;;1215   void EPWM_DisableSyncPhase(EPWM_T *epwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;1216   {
;;;1217       uint32_t i;
;;;1218       for(i = 0U; i < EPWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;1219       {
;;;1220           if(u32ChannelMask & (1UL << i))
000004  2501              MOVS     r5,#1
                  |L32.6|
000006  fa05f302          LSL      r3,r5,r2
00000a  420b              TST      r3,r1
00000c  d005              BEQ      |L32.26|
;;;1221           {
;;;1222               (epwm)->SYNC &= ~((1UL << EPWM_SYNC_PHSEN0_Pos) << (i >> 1U));
00000e  6884              LDR      r4,[r0,#8]
000010  0856              LSRS     r6,r2,#1
000012  fa05f306          LSL      r3,r5,r6
000016  439c              BICS     r4,r4,r3
000018  6084              STR      r4,[r0,#8]
                  |L32.26|
00001a  1c52              ADDS     r2,r2,#1
00001c  2a06              CMP      r2,#6                 ;1218
00001e  d3f2              BCC      |L32.6|
;;;1223           }
;;;1224       }
;;;1225   }
000020  bd70              POP      {r4-r6,pc}
;;;1226   
                          ENDP


                          AREA ||i.EPWM_DisableSyncPinInverse||, CODE, READONLY, ALIGN=1

                  EPWM_DisableSyncPinInverse PROC
;;;1285    */
;;;1286   void EPWM_DisableSyncPinInverse(EPWM_T *epwm)
000000  6881              LDR      r1,[r0,#8]
;;;1287   {
;;;1288       (epwm)->SYNC &= (~EPWM_SYNC_SINPINV_Msk);
000002  f4210100          BIC      r1,r1,#0x800000
000006  6081              STR      r1,[r0,#8]
;;;1289   }
000008  4770              BX       lr
;;;1290   
                          ENDP


                          AREA ||i.EPWM_DisableZeroInt||, CODE, READONLY, ALIGN=1

                  EPWM_DisableZeroInt PROC
;;;902     */
;;;903    void EPWM_DisableZeroInt(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8502fe0          LDR      r2,[r0,#0xe0]!
;;;904    {
;;;905        (epwm)->INTEN0 &= ~((1UL << EPWM_INTEN0_ZIEN0_Pos) << u32ChannelNum);
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
;;;906    }
00000c  4770              BX       lr
;;;907    
                          ENDP


                          AREA ||i.EPWM_EnableADCTrigger||, CODE, READONLY, ALIGN=1

                  EPWM_EnableADCTrigger PROC
;;;278     */
;;;279    void EPWM_EnableADCTrigger(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  b510              PUSH     {r4,lr}
;;;280    {
;;;281        if(u32ChannelNum < 4U)
;;;282        {
;;;283            (epwm)->EADCTS0 &= ~((EPWM_EADCTS0_TRGSEL0_Msk) << (u32ChannelNum << 3U));
;;;284            (epwm)->EADCTS0 |= ((EPWM_EADCTS0_TRGEN0_Msk | u32Condition) << (u32ChannelNum << 3));
000002  f0420380          ORR      r3,r2,#0x80
000006  240f              MOVS     r4,#0xf               ;283
000008  00ca              LSLS     r2,r1,#3              ;283
00000a  2904              CMP      r1,#4                 ;281
00000c  d203              BCS      |L35.22|
00000e  f8501ff8          LDR      r1,[r0,#0xf8]!        ;283
000012  4094              LSLS     r4,r4,r2              ;283
000014  e003              B        |L35.30|
                  |L35.22|
000016  3a20              SUBS     r2,r2,#0x20
;;;285        }
;;;286        else
;;;287        {
;;;288            (epwm)->EADCTS1 &= ~((EPWM_EADCTS1_TRGSEL4_Msk) << ((u32ChannelNum - 4U) << 3U));
000018  f8501ffc          LDR      r1,[r0,#0xfc]!
00001c  4094              LSLS     r4,r4,r2
                  |L35.30|
00001e  43a1              BICS     r1,r1,r4              ;283
000020  6001              STR      r1,[r0,#0]            ;283
000022  6801              LDR      r1,[r0,#0]            ;284
000024  4093              LSLS     r3,r3,r2              ;284
000026  430b              ORRS     r3,r3,r1              ;284
000028  6003              STR      r3,[r0,#0]            ;284
;;;289            (epwm)->EADCTS1 |= ((EPWM_EADCTS1_TRGEN4_Msk | u32Condition) << ((u32ChannelNum - 4U) << 3U));
;;;290        }
;;;291    }
00002a  bd10              POP      {r4,pc}
;;;292    
                          ENDP


                          AREA ||i.EPWM_EnableAcc||, CODE, READONLY, ALIGN=2

                  EPWM_EnableAcc PROC
;;;952     */
;;;953    void EPWM_EnableAcc(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32IntFlagCnt, uint32_t u32IntAccSrc)
000000  b510              PUSH     {r4,lr}
;;;954    {
;;;955        (epwm)->IFA[u32ChannelNum] = (((epwm)->IFA[u32ChannelNum] & ~((EPWM_IFA0_IFACNT_Msk | EPWM_IFA0_IFASEL_Msk))) | \
000002  eb000081          ADD      r0,r0,r1,LSL #2
000006  f8d01130          LDR      r1,[r0,#0x130]
00000a  4c05              LDR      r4,|L36.32|
00000c  ea427203          ORR      r2,r2,r3,LSL #28
000010  4021              ANDS     r1,r1,r4
000012  4311              ORRS     r1,r1,r2
000014  f0414100          ORR      r1,r1,#0x80000000
000018  f8c01130          STR      r1,[r0,#0x130]
;;;956                                      (EPWM_IFA0_IFAEN_Msk | (u32IntAccSrc << EPWM_IFA0_IFASEL_Pos) | u32IntFlagCnt) );
;;;957    }
00001c  bd10              POP      {r4,pc}
;;;958    
                          ENDP

00001e  0000              DCW      0x0000
                  |L36.32|
                          DCD      0xcfff0000

                          AREA ||i.EPWM_EnableAccInt||, CODE, READONLY, ALIGN=1

                  EPWM_EnableAccInt PROC
;;;981     */
;;;982    void EPWM_EnableAccInt(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d02154          LDR      r2,[r0,#0x154]
;;;983    {
;;;984        (epwm)->AINTEN |= (1UL << (u32ChannelNum));
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  f8c02154          STR      r2,[r0,#0x154]
;;;985    }
00000e  4770              BX       lr
;;;986    
                          ENDP


                          AREA ||i.EPWM_EnableAccPDMA||, CODE, READONLY, ALIGN=1

                  EPWM_EnableAccPDMA PROC
;;;1038    */
;;;1039   void EPWM_EnableAccPDMA(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d02158          LDR      r2,[r0,#0x158]
;;;1040   {
;;;1041       (epwm)->APDMACTL |= (1UL << (u32ChannelNum));
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  f8c02158          STR      r2,[r0,#0x158]
;;;1042   }
00000e  4770              BX       lr
;;;1043   
                          ENDP


                          AREA ||i.EPWM_EnableAccStopMode||, CODE, READONLY, ALIGN=1

                  EPWM_EnableAccStopMode PROC
;;;1066    */
;;;1067   void EPWM_EnableAccStopMode(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  eb000081          ADD      r0,r0,r1,LSL #2
;;;1068   {
;;;1069       (epwm)->IFA[u32ChannelNum] |= EPWM_IFA0_STPMOD_Msk;
000004  f8d01130          LDR      r1,[r0,#0x130]
000008  f0417180          ORR      r1,r1,#0x1000000
00000c  f8c01130          STR      r1,[r0,#0x130]
;;;1070   }
000010  4770              BX       lr
;;;1071   
                          ENDP


                          AREA ||i.EPWM_EnableBrakeNoiseFilter||, CODE, READONLY, ALIGN=1

                  EPWM_EnableBrakeNoiseFilter PROC
;;;1332    */
;;;1333   void EPWM_EnableBrakeNoiseFilter(EPWM_T *epwm, uint32_t u32BrakePinNum, uint32_t u32ClkCnt, uint32_t u32ClkDivSel)
000000  b530              PUSH     {r4,r5,lr}
;;;1334   {
;;;1335       (epwm)->BNF = ((epwm)->BNF & ~((EPWM_BNF_BRK0FCNT_Msk | EPWM_BNF_BRK0NFSEL_Msk) << (u32BrakePinNum << 3U))) | \
000002  f8504fc0          LDR      r4,[r0,#0xc0]!
000006  00c9              LSLS     r1,r1,#3
000008  257e              MOVS     r5,#0x7e
00000a  408d              LSLS     r5,r5,r1
00000c  0112              LSLS     r2,r2,#4
00000e  ea420243          ORR      r2,r2,r3,LSL #1
000012  1c52              ADDS     r2,r2,#1
000014  43ac              BICS     r4,r4,r5
000016  408a              LSLS     r2,r2,r1
000018  4314              ORRS     r4,r4,r2
00001a  6004              STR      r4,[r0,#0]
;;;1336                     (((u32ClkCnt << EPWM_BNF_BRK0FCNT_Pos) | (u32ClkDivSel << EPWM_BNF_BRK0NFSEL_Pos) | EPWM_BNF_BRK0NFEN_Msk) << (u32BrakePinNum << 3U));
;;;1337   }
00001c  bd30              POP      {r4,r5,pc}
;;;1338   
                          ENDP


                          AREA ||i.EPWM_EnableBrakePinInverse||, CODE, READONLY, ALIGN=1

                  EPWM_EnableBrakePinInverse PROC
;;;1361    */
;;;1362   void EPWM_EnableBrakePinInverse(EPWM_T *epwm, uint32_t u32BrakePinNum)
000000  f8502fc0          LDR      r2,[r0,#0xc0]!
;;;1363   {
;;;1364       (epwm)->BNF |= (EPWM_BNF_BRK0PINV_Msk << (u32BrakePinNum << 3U));
000004  00cb              LSLS     r3,r1,#3
000006  2180              MOVS     r1,#0x80
000008  4099              LSLS     r1,r1,r3
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;1365   }
00000e  4770              BX       lr
;;;1366   
                          ENDP


                          AREA ||i.EPWM_EnableCapture||, CODE, READONLY, ALIGN=1

                  EPWM_EnableCapture PROC
;;;503     */
;;;504    void EPWM_EnableCapture(EPWM_T *epwm, uint32_t u32ChannelMask)
000000  f8d02200          LDR      r2,[r0,#0x200]
;;;505    {
;;;506        (epwm)->CAPINEN |= u32ChannelMask;
000004  430a              ORRS     r2,r2,r1
000006  f8c02200          STR      r2,[r0,#0x200]
;;;507        (epwm)->CAPCTL |= u32ChannelMask;
00000a  f8d02204          LDR      r2,[r0,#0x204]
00000e  430a              ORRS     r2,r2,r1
000010  f8c02204          STR      r2,[r0,#0x204]
;;;508    }
000014  4770              BX       lr
;;;509    
                          ENDP


                          AREA ||i.EPWM_EnableCaptureInt||, CODE, READONLY, ALIGN=1

                  EPWM_EnableCaptureInt PROC
;;;640     */
;;;641    void EPWM_EnableCaptureInt(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  f8d03250          LDR      r3,[r0,#0x250]
;;;642    {
;;;643        (epwm)->CAPIEN |= (u32Edge << u32ChannelNum);
000004  408a              LSLS     r2,r2,r1
000006  4313              ORRS     r3,r3,r2
000008  f8c03250          STR      r3,[r0,#0x250]
;;;644    }
00000c  4770              BX       lr
;;;645    
                          ENDP


                          AREA ||i.EPWM_EnableDACTrigger||, CODE, READONLY, ALIGN=1

                  EPWM_EnableDACTrigger PROC
;;;357     */
;;;358    void EPWM_EnableDACTrigger(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  f8503ff4          LDR      r3,[r0,#0xf4]!
;;;359    {
;;;360        (epwm)->DACTRGEN |= (u32Condition << u32ChannelNum);
000004  408a              LSLS     r2,r2,r1
000006  4313              ORRS     r3,r3,r2
000008  6003              STR      r3,[r0,#0]
;;;361    }
00000a  4770              BX       lr
;;;362    
                          ENDP


                          AREA ||i.EPWM_EnableDeadZone||, CODE, READONLY, ALIGN=1

                  EPWM_EnableDeadZone PROC
;;;605     */
;;;606    void EPWM_EnableDeadZone(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Duration)
000000  0849              LSRS     r1,r1,#1
;;;607    {
;;;608        /* every two channels share the same setting */
;;;609        (epwm)->DTCTL[(u32ChannelNum) >> 1U] &= ~EPWM_DTCTL0_1_DTCNT_Msk;
000002  eb000081          ADD      r0,r0,r1,LSL #2
000006  6f01              LDR      r1,[r0,#0x70]
000008  f36f010b          BFC      r1,#0,#12
00000c  6701              STR      r1,[r0,#0x70]
;;;610        (epwm)->DTCTL[(u32ChannelNum) >> 1U] |= EPWM_DTCTL0_1_DTEN_Msk | u32Duration;
00000e  6f01              LDR      r1,[r0,#0x70]
000010  f4423280          ORR      r2,r2,#0x10000
000014  4311              ORRS     r1,r1,r2
000016  6701              STR      r1,[r0,#0x70]
;;;611    }
000018  4770              BX       lr
;;;612    
                          ENDP


                          AREA ||i.EPWM_EnableDutyInt||, CODE, READONLY, ALIGN=1

                  EPWM_EnableDutyInt PROC
;;;708     */
;;;709    void EPWM_EnableDutyInt(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType)
000000  f8503fe0          LDR      r3,[r0,#0xe0]!
;;;710    {
;;;711        (epwm)->INTEN0 |= (u32IntDutyType << u32ChannelNum);
000004  408a              LSLS     r2,r2,r1
000006  4313              ORRS     r3,r3,r2
000008  6003              STR      r3,[r0,#0]
;;;712    }
00000a  4770              BX       lr
;;;713    
                          ENDP


                          AREA ||i.EPWM_EnableFaultBrake||, CODE, READONLY, ALIGN=1

                  EPWM_EnableFaultBrake PROC
;;;438     */
;;;439    void EPWM_EnableFaultBrake(EPWM_T *epwm, uint32_t u32ChannelMask, uint32_t u32LevelMask, uint32_t u32BrakeSource)
000000  b5f0              PUSH     {r4-r7,lr}
;;;440    {
;;;441        uint32_t i;
;;;442    
;;;443        for(i = 0U; i < EPWM_CHANNEL_NUM; i ++)
000002  2400              MOVS     r4,#0
;;;444        {
;;;445            if(u32ChannelMask & (1UL << i))
000004  2601              MOVS     r6,#1
                  |L47.6|
000006  fa06f704          LSL      r7,r6,r4
00000a  420f              TST      r7,r1
00000c  d020              BEQ      |L47.80|
;;;446            {
;;;447                if((u32BrakeSource == EPWM_FB_EDGE_SYS_CSS) || (u32BrakeSource == EPWM_FB_EDGE_SYS_BOD) || \
00000e  2b81              CMP      r3,#0x81
000010  d031              BEQ      |L47.118|
000012  2b82              CMP      r3,#0x82
000014  d02f              BEQ      |L47.118|
;;;448                        (u32BrakeSource == EPWM_FB_EDGE_SYS_RAM) || (u32BrakeSource == EPWM_FB_EDGE_SYS_COR) || \
000016  2b84              CMP      r3,#0x84
000018  d02d              BEQ      |L47.118|
00001a  2b88              CMP      r3,#0x88
00001c  d02b              BEQ      |L47.118|
;;;449                        (u32BrakeSource == EPWM_FB_LEVEL_SYS_CSS) || (u32BrakeSource == EPWM_FB_LEVEL_SYS_BOD) || \
00001e  f2480501          MOV      r5,#0x8001
000022  42ab              CMP      r3,r5
000024  d027              BEQ      |L47.118|
000026  f5a34500          SUB      r5,r3,#0x8000
00002a  3d02              SUBS     r5,#2
00002c  d023              BEQ      |L47.118|
;;;450                        (u32BrakeSource == EPWM_FB_LEVEL_SYS_RAM) || (u32BrakeSource == EPWM_FB_LEVEL_SYS_COR))
00002e  f5a34500          SUB      r5,r3,#0x8000
000032  3d04              SUBS     r5,#4
000034  d01f              BEQ      |L47.118|
000036  f5a34500          SUB      r5,r3,#0x8000
00003a  3d08              SUBS     r5,r5,#8
00003c  d01b              BEQ      |L47.118|
;;;451                {
;;;452                    (epwm)->BRKCTL[i >> 1U] |= (u32BrakeSource & (EPWM_BRKCTL0_1_SYSEBEN_Msk | EPWM_BRKCTL0_1_SYSLBEN_Msk));
;;;453                    (epwm)->FAILBRK |= (u32BrakeSource & 0xFU);
;;;454                }
;;;455                else
;;;456                {
;;;457                    (epwm)->BRKCTL[i >> 1U] |= u32BrakeSource;
00003e  0865              LSRS     r5,r4,#1
000040  eb000585          ADD      r5,r0,r5,LSL #2
000044  f8d5c0c8          LDR      r12,[r5,#0xc8]
000048  ea4c0c03          ORR      r12,r12,r3
00004c  f8c5c0c8          STR      r12,[r5,#0xc8]
                  |L47.80|
;;;458                }
;;;459            }
;;;460    
;;;461            if(u32LevelMask & (1UL << i))
000050  4217              TST      r7,r2
;;;462            {
;;;463                if((i & 0x1U) == 0U)
;;;464                {
;;;465                    /* set brake action as high level for even channel */
;;;466                    (epwm)->BRKCTL[i >> 1] &= ~EPWM_BRKCTL0_1_BRKAEVEN_Msk;
;;;467                    (epwm)->BRKCTL[i >> 1] |= ((3U) << EPWM_BRKCTL0_1_BRKAEVEN_Pos);
;;;468                }
;;;469                else
;;;470                {
;;;471                    /* set brake action as high level for odd channel */
;;;472                    (epwm)->BRKCTL[i >> 1] &= ~EPWM_BRKCTL0_1_BRKAODD_Msk;
;;;473                    (epwm)->BRKCTL[i >> 1] |= ((3U) << EPWM_BRKCTL0_1_BRKAODD_Pos);
;;;474                }
;;;475            }
;;;476            else
;;;477            {
;;;478                if((i & 0x1U) == 0U)
000052  ea4f75c4          LSL      r5,r4,#31
000056  d02b              BEQ      |L47.176|
000058  2d00              CMP      r5,#0                 ;463
00005a  ea4f0554          LSR      r5,r4,#1              ;472
00005e  eb000585          ADD      r5,r0,r5,LSL #2       ;472
000062  f8557fc8          LDR      r7,[r5,#0xc8]!        ;472
000066  d01c              BEQ      |L47.162|
000068  f4272740          BIC      r7,r7,#0xc0000        ;472
00006c  602f              STR      r7,[r5,#0]            ;472
00006e  682f              LDR      r7,[r5,#0]            ;473
000070  f4472740          ORR      r7,r7,#0xc0000        ;473
000074  e02a              B        |L47.204|
                  |L47.118|
000076  0865              LSRS     r5,r4,#1              ;452
000078  eb000585          ADD      r5,r0,r5,LSL #2       ;452
00007c  f8d5c0c8          LDR      r12,[r5,#0xc8]        ;452
000080  f2480e80          MOV      lr,#0x8080            ;452
000084  ea030e0e          AND      lr,r3,lr              ;452
000088  ea4c0c0e          ORR      r12,r12,lr            ;452
00008c  f8c5c0c8          STR      r12,[r5,#0xc8]        ;452
000090  f8d050c4          LDR      r5,[r0,#0xc4]         ;453
000094  f0030c0f          AND      r12,r3,#0xf           ;453
000098  ea45050c          ORR      r5,r5,r12             ;453
00009c  f8c050c4          STR      r5,[r0,#0xc4]         ;453
0000a0  e7d6              B        |L47.80|
                  |L47.162|
0000a2  f4273740          BIC      r7,r7,#0x30000        ;466
0000a6  602f              STR      r7,[r5,#0]            ;466
0000a8  682f              LDR      r7,[r5,#0]            ;467
0000aa  f4473740          ORR      r7,r7,#0x30000        ;467
0000ae  e00d              B        |L47.204|
                  |L47.176|
0000b0  2d00              CMP      r5,#0
;;;479                {
;;;480                    /* set brake action as low level for even channel */
;;;481                    (epwm)->BRKCTL[i >> 1U] &= ~EPWM_BRKCTL0_1_BRKAEVEN_Msk;
;;;482                    (epwm)->BRKCTL[i >> 1U] |= ((2U) << EPWM_BRKCTL0_1_BRKAEVEN_Pos);
;;;483                }
;;;484                else
;;;485                {
;;;486                    /* set brake action as low level for odd channel */
;;;487                    (epwm)->BRKCTL[i >> 1U] &= ~EPWM_BRKCTL0_1_BRKAODD_Msk;
0000b2  ea4f0554          LSR      r5,r4,#1
0000b6  eb000585          ADD      r5,r0,r5,LSL #2
0000ba  f8557fc8          LDR      r7,[r5,#0xc8]!
0000be  d00a              BEQ      |L47.214|
0000c0  f4272740          BIC      r7,r7,#0xc0000
0000c4  602f              STR      r7,[r5,#0]
;;;488                    (epwm)->BRKCTL[i >> 1U] |= ((2U) << EPWM_BRKCTL0_1_BRKAODD_Pos);
0000c6  682f              LDR      r7,[r5,#0]
0000c8  f4472700          ORR      r7,r7,#0x80000
                  |L47.204|
0000cc  602f              STR      r7,[r5,#0]            ;482
0000ce  1c64              ADDS     r4,r4,#1              ;482
0000d0  2c06              CMP      r4,#6                 ;443
0000d2  d398              BCC      |L47.6|
;;;489                }
;;;490            }
;;;491        }
;;;492    }
0000d4  bdf0              POP      {r4-r7,pc}
                  |L47.214|
0000d6  f4273740          BIC      r7,r7,#0x30000        ;481
0000da  602f              STR      r7,[r5,#0]            ;481
0000dc  682f              LDR      r7,[r5,#0]            ;482
0000de  f4473700          ORR      r7,r7,#0x20000        ;482
0000e2  e7f3              B        |L47.204|
;;;493    
                          ENDP


                          AREA ||i.EPWM_EnableFaultBrakeInt||, CODE, READONLY, ALIGN=1

                  EPWM_EnableFaultBrakeInt PROC
;;;768     */
;;;769    void EPWM_EnableFaultBrakeInt(EPWM_T *epwm, uint32_t u32BrakeSource)
000000  f8502fe4          LDR      r2,[r0,#0xe4]!
;;;770    {
;;;771        (epwm)->INTEN1 |= (0x7UL << u32BrakeSource);
000004  2307              MOVS     r3,#7
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
;;;772    }
00000c  4770              BX       lr
;;;773    
                          ENDP


                          AREA ||i.EPWM_EnableLoadMode||, CODE, READONLY, ALIGN=1

                  EPWM_EnableLoadMode PROC
;;;1128    */
;;;1129   void EPWM_EnableLoadMode(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
000000  6803              LDR      r3,[r0,#0]
;;;1130   {
;;;1131       (epwm)->CTL0 |= (u32LoadMode << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  4313              ORRS     r3,r3,r2
000006  6003              STR      r3,[r0,#0]
;;;1132   }
000008  4770              BX       lr
;;;1133   
                          ENDP


                          AREA ||i.EPWM_EnableOutput||, CODE, READONLY, ALIGN=1

                  EPWM_EnableOutput PROC
;;;535     */
;;;536    void EPWM_EnableOutput(EPWM_T *epwm, uint32_t u32ChannelMask)
000000  f8502fd8          LDR      r2,[r0,#0xd8]!
;;;537    {
;;;538        (epwm)->POEN |= u32ChannelMask;
000004  430a              ORRS     r2,r2,r1
000006  6002              STR      r2,[r0,#0]
;;;539    }
000008  4770              BX       lr
;;;540    
                          ENDP


                          AREA ||i.EPWM_EnablePDMA||, CODE, READONLY, ALIGN=1

                  EPWM_EnablePDMA PROC
;;;570     */
;;;571    void EPWM_EnablePDMA(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32RisingFirst, uint32_t u32Mode)
000000  b570              PUSH     {r4-r6,lr}
;;;572    {
;;;573        uint32_t u32IsOddCh;
;;;574        u32IsOddCh = u32ChannelNum & 0x1U;
;;;575        (epwm)->PDMACTL = ((epwm)->PDMACTL & ~((EPWM_PDMACTL_CHSEL0_1_Msk | EPWM_PDMACTL_CAPORD0_1_Msk | EPWM_PDMACTL_CAPMOD0_1_Msk) << ((u32ChannelNum >> 1U) << 3U))) | \
000002  f8d0523c          LDR      r5,[r0,#0x23c]
000006  07cc              LSLS     r4,r1,#31             ;574
000008  0849              LSRS     r1,r1,#1
00000a  00c9              LSLS     r1,r1,#3
00000c  261e              MOVS     r6,#0x1e
00000e  408e              LSLS     r6,r6,r1
000010  0ee4              LSRS     r4,r4,#27
000012  ea4402c2          ORR      r2,r4,r2,LSL #3
000016  431a              ORRS     r2,r2,r3
000018  f0420201          ORR      r2,r2,#1
00001c  43b5              BICS     r5,r5,r6
00001e  408a              LSLS     r2,r2,r1
000020  4315              ORRS     r5,r5,r2
000022  f8c0523c          STR      r5,[r0,#0x23c]
;;;576                          (((u32IsOddCh << EPWM_PDMACTL_CHSEL0_1_Pos) | (u32RisingFirst << EPWM_PDMACTL_CAPORD0_1_Pos) | \
;;;577                            u32Mode | EPWM_PDMACTL_CHEN0_1_Msk) << ((u32ChannelNum >> 1U) << 3U));
;;;578    }
000026  bd70              POP      {r4-r6,pc}
;;;579    
                          ENDP


                          AREA ||i.EPWM_EnablePeriodInt||, CODE, READONLY, ALIGN=1

                  EPWM_EnablePeriodInt PROC
;;;830     */
;;;831    void EPWM_EnablePeriodInt(EPWM_T *epwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
000000  f8502fe0          LDR      r2,[r0,#0xe0]!
;;;832    {
;;;833        (epwm)->INTEN0 |= ((1UL << EPWM_INTEN0_PIEN0_Pos) << u32ChannelNum);
000004  f44f7380          MOV      r3,#0x100
000008  408b              LSLS     r3,r3,r1
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
;;;834    }
00000e  4770              BX       lr
;;;835    
                          ENDP


                          AREA ||i.EPWM_EnableSyncNoiseFilter||, CODE, READONLY, ALIGN=1

                  EPWM_EnableSyncNoiseFilter PROC
;;;1245    */
;;;1246   void EPWM_EnableSyncNoiseFilter(EPWM_T *epwm, uint32_t u32ClkCnt, uint32_t u32ClkDivSel)
000000  0509              LSLS     r1,r1,#20
;;;1247   {
;;;1248       (epwm)->SYNC = ((epwm)->SYNC & ~(EPWM_SYNC_SFLTCNT_Msk | EPWM_SYNC_SFLTCSEL_Msk)) | \
000002  ea414142          ORR      r1,r1,r2,LSL #17
000006  6882              LDR      r2,[r0,#8]
000008  f42202fc          BIC      r2,r2,#0x7e0000
00000c  4311              ORRS     r1,r1,r2
00000e  f4413180          ORR      r1,r1,#0x10000
000012  6081              STR      r1,[r0,#8]
;;;1249                      ((u32ClkCnt << EPWM_SYNC_SFLTCNT_Pos) | (u32ClkDivSel << EPWM_SYNC_SFLTCSEL_Pos) | EPWM_SYNC_SNFLTEN_Msk);
;;;1250   }
000014  4770              BX       lr
;;;1251   
                          ENDP


                          AREA ||i.EPWM_EnableSyncPhase||, CODE, READONLY, ALIGN=1

                  EPWM_EnableSyncPhase PROC
;;;1191    */
;;;1192   void EPWM_EnableSyncPhase(EPWM_T *epwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;1193   {
;;;1194       uint32_t i;
;;;1195       for(i = 0U; i < EPWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;1196       {
;;;1197           if(u32ChannelMask & (1UL << i))
000004  2501              MOVS     r5,#1
                  |L54.6|
000006  fa05f302          LSL      r3,r5,r2
00000a  420b              TST      r3,r1
00000c  d005              BEQ      |L54.26|
;;;1198           {
;;;1199               (epwm)->SYNC |= ((1UL << EPWM_SYNC_PHSEN0_Pos) << (i >> 1U));
00000e  6884              LDR      r4,[r0,#8]
000010  0856              LSRS     r6,r2,#1
000012  fa05f306          LSL      r3,r5,r6
000016  431c              ORRS     r4,r4,r3
000018  6084              STR      r4,[r0,#8]
                  |L54.26|
00001a  1c52              ADDS     r2,r2,#1
00001c  2a06              CMP      r2,#6                 ;1195
00001e  d3f2              BCC      |L54.6|
;;;1200           }
;;;1201       }
;;;1202   }
000020  bd70              POP      {r4-r6,pc}
;;;1203   
                          ENDP


                          AREA ||i.EPWM_EnableSyncPinInverse||, CODE, READONLY, ALIGN=1

                  EPWM_EnableSyncPinInverse PROC
;;;1272    */
;;;1273   void EPWM_EnableSyncPinInverse(EPWM_T *epwm)
000000  6881              LDR      r1,[r0,#8]
;;;1274   {
;;;1275       (epwm)->SYNC |= EPWM_SYNC_SINPINV_Msk;
000002  f4410100          ORR      r1,r1,#0x800000
000006  6081              STR      r1,[r0,#8]
;;;1276   }
000008  4770              BX       lr
;;;1277   
                          ENDP


                          AREA ||i.EPWM_EnableZeroInt||, CODE, READONLY, ALIGN=1

                  EPWM_EnableZeroInt PROC
;;;888     */
;;;889    void EPWM_EnableZeroInt(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8502fe0          LDR      r2,[r0,#0xe0]!
;;;890    {
;;;891        (epwm)->INTEN0 |= ((1UL << EPWM_INTEN0_ZIEN0_Pos) << u32ChannelNum);
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
;;;892    }
00000c  4770              BX       lr
;;;893    
                          ENDP


                          AREA ||i.EPWM_ForceStop||, CODE, READONLY, ALIGN=1

                  EPWM_ForceStop PROC
;;;247     */
;;;248    void EPWM_ForceStop(EPWM_T *epwm, uint32_t u32ChannelMask)
000000  6a02              LDR      r2,[r0,#0x20]
;;;249    {
;;;250        (epwm)->CNTEN &= ~u32ChannelMask;
000002  438a              BICS     r2,r2,r1
000004  6202              STR      r2,[r0,#0x20]
;;;251    }
000006  4770              BX       lr
;;;252    
                          ENDP


                          AREA ||i.EPWM_GetADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  EPWM_GetADCTriggerFlag PROC
;;;338     */
;;;339    uint32_t EPWM_GetADCTriggerFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d00120          LDR      r0,[r0,#0x120]
;;;340    {
;;;341        return (((epwm)->STATUS & (EPWM_STATUS_EADCTRGF0_Msk << u32ChannelNum))?1UL:0UL);
000004  f44f3280          MOV      r2,#0x10000
000008  408a              LSLS     r2,r2,r1
00000a  4010              ANDS     r0,r0,r2
00000c  d000              BEQ      |L58.16|
00000e  2001              MOVS     r0,#1
                  |L58.16|
;;;342    }
000010  4770              BX       lr
;;;343    
                          ENDP


                          AREA ||i.EPWM_GetAccInt||, CODE, READONLY, ALIGN=1

                  EPWM_GetAccInt PROC
;;;1024    */
;;;1025   uint32_t EPWM_GetAccInt(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d00150          LDR      r0,[r0,#0x150]
;;;1026   {
;;;1027       return (((epwm)->AINTSTS & (1UL << (u32ChannelNum))) ? 1UL : 0UL);
000004  2201              MOVS     r2,#1
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L59.14|
00000c  2001              MOVS     r0,#1
                  |L59.14|
;;;1028   }
00000e  4770              BX       lr
;;;1029   
                          ENDP


                          AREA ||i.EPWM_GetCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  EPWM_GetCaptureIntFlag PROC
;;;691     */
;;;692    uint32_t EPWM_GetCaptureIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d02254          LDR      r2,[r0,#0x254]
;;;693    {
;;;694        return (((((epwm)->CAPIF & (EPWM_CAPIF_CFLIF0_Msk << u32ChannelNum)) ? 1UL : 0UL) << 1) | \
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  401a              ANDS     r2,r2,r3
00000a  d000              BEQ      |L60.14|
;;;695                (((epwm)->CAPIF & (EPWM_CAPIF_CRLIF0_Msk << u32ChannelNum)) ? 1UL : 0UL));
00000c  2201              MOVS     r2,#1
                  |L60.14|
00000e  f8d00254          LDR      r0,[r0,#0x254]
000012  f44f7380          MOV      r3,#0x100
000016  408b              LSLS     r3,r3,r1
000018  4018              ANDS     r0,r0,r3
00001a  d000              BEQ      |L60.30|
00001c  2001              MOVS     r0,#1                 ;694
                  |L60.30|
00001e  ea420040          ORR      r0,r2,r0,LSL #1       ;694
;;;696    }
000022  4770              BX       lr
;;;697    /**
                          ENDP


                          AREA ||i.EPWM_GetDACTriggerFlag||, CODE, READONLY, ALIGN=1

                  EPWM_GetDACTriggerFlag PROC
;;;402     */
;;;403    uint32_t EPWM_GetDACTriggerFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d00120          LDR      r0,[r0,#0x120]
;;;404    {
;;;405        return (((epwm)->STATUS & EPWM_STATUS_DACTRGF_Msk)?1UL:0UL);
000004  f3c06000          UBFX     r0,r0,#24,#1
;;;406    }
000008  4770              BX       lr
;;;407    
                          ENDP


                          AREA ||i.EPWM_GetDutyIntFlag||, CODE, READONLY, ALIGN=2

                  EPWM_GetDutyIntFlag PROC
;;;752     */
;;;753    uint32_t EPWM_GetDutyIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d000e8          LDR      r0,[r0,#0xe8]
;;;754    {
;;;755        return ((((epwm)->INTSTS0 & ((EPWM_INTSTS0_CMPDIF0_Msk | EPWM_INTSTS0_CMPUIF0_Msk) << u32ChannelNum))) ? 1UL : 0UL);
000004  4a02              LDR      r2,|L62.16|
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L62.14|
00000c  2001              MOVS     r0,#1
                  |L62.14|
;;;756    }
00000e  4770              BX       lr
;;;757    
                          ENDP

                  |L62.16|
                          DCD      0x01010000

                          AREA ||i.EPWM_GetFTDutyIntFlag||, CODE, READONLY, ALIGN=1

                  EPWM_GetFTDutyIntFlag PROC
;;;1110    */
;;;1111   uint32_t EPWM_GetFTDutyIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d0034c          LDR      r0,[r0,#0x34c]
;;;1112   {
;;;1113       return (((epwm)->FTCI & ((EPWM_FTCI_FTCMU0_Msk | EPWM_FTCI_FTCMD0_Msk) << (u32ChannelNum >> 1U))) ? 1UL : 0UL);
000004  084a              LSRS     r2,r1,#1
000006  f2401101          MOV      r1,#0x101
00000a  4091              LSLS     r1,r1,r2
00000c  4008              ANDS     r0,r0,r1
00000e  d000              BEQ      |L63.18|
000010  2001              MOVS     r0,#1
                  |L63.18|
;;;1114   }
000012  4770              BX       lr
;;;1115   
                          ENDP


                          AREA ||i.EPWM_GetFaultBrakeIntFlag||, CODE, READONLY, ALIGN=1

                  EPWM_GetFaultBrakeIntFlag PROC
;;;815     */
;;;816    uint32_t EPWM_GetFaultBrakeIntFlag(EPWM_T *epwm, uint32_t u32BrakeSource)
000000  f8d000ec          LDR      r0,[r0,#0xec]
;;;817    {
;;;818        return (((epwm)->INTSTS1 & (0x3fUL << u32BrakeSource)) ? 1UL : 0UL);
000004  223f              MOVS     r2,#0x3f
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L64.14|
00000c  2001              MOVS     r0,#1
                  |L64.14|
;;;819    }
00000e  4770              BX       lr
;;;820    
                          ENDP


                          AREA ||i.EPWM_GetPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  EPWM_GetPeriodIntFlag PROC
;;;874     */
;;;875    uint32_t EPWM_GetPeriodIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d000e8          LDR      r0,[r0,#0xe8]
;;;876    {
;;;877        return ((((epwm)->INTSTS0 & ((1UL << EPWM_INTSTS0_PIF0_Pos) << u32ChannelNum))) ? 1UL : 0UL);
000004  f44f7280          MOV      r2,#0x100
000008  408a              LSLS     r2,r2,r1
00000a  4010              ANDS     r0,r0,r2
00000c  d000              BEQ      |L65.16|
00000e  2001              MOVS     r0,#1
                  |L65.16|
;;;878    }
000010  4770              BX       lr
;;;879    
                          ENDP


                          AREA ||i.EPWM_GetWrapAroundFlag||, CODE, READONLY, ALIGN=1

                  EPWM_GetWrapAroundFlag PROC
;;;1439    */
;;;1440   uint32_t EPWM_GetWrapAroundFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d00120          LDR      r0,[r0,#0x120]
;;;1441   {
;;;1442       return (((epwm)->STATUS & (EPWM_STATUS_CNTMAXF0_Msk << u32ChannelNum)) ? 1UL : 0UL);
000004  2201              MOVS     r2,#1
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L66.14|
00000c  2001              MOVS     r0,#1
                  |L66.14|
;;;1443   }
00000e  4770              BX       lr
;;;1444   
                          ENDP


                          AREA ||i.EPWM_GetZeroIntFlag||, CODE, READONLY, ALIGN=1

                  EPWM_GetZeroIntFlag PROC
;;;932     */
;;;933    uint32_t EPWM_GetZeroIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum)
000000  f8d000e8          LDR      r0,[r0,#0xe8]
;;;934    {
;;;935        return ((((epwm)->INTSTS0 & ((1UL << EPWM_INTEN0_ZIEN0_Pos) << u32ChannelNum))) ? 1UL : 0UL);
000004  2201              MOVS     r2,#1
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L67.14|
00000c  2001              MOVS     r0,#1
                  |L67.14|
;;;936    }
00000e  4770              BX       lr
;;;937    
                          ENDP


                          AREA ||i.EPWM_SetBrakePinSource||, CODE, READONLY, ALIGN=1

                  EPWM_SetBrakePinSource PROC
;;;1390    */
;;;1391   void EPWM_SetBrakePinSource(EPWM_T *epwm, uint32_t u32BrakePinNum, uint32_t u32SelAnotherModule)
000000  b530              PUSH     {r4,r5,lr}
;;;1392   {
;;;1393       (epwm)->BNF = ((epwm)->BNF & ~(EPWM_BNF_BK0SRC_Msk << (u32BrakePinNum << 3U))) | (u32SelAnotherModule << ((uint32_t)EPWM_BNF_BK0SRC_Pos + (u32BrakePinNum << 3U)));
000002  f8503fc0          LDR      r3,[r0,#0xc0]!
000006  00cd              LSLS     r5,r1,#3
000008  f44f3480          MOV      r4,#0x10000
00000c  40ac              LSLS     r4,r4,r5
00000e  43a3              BICS     r3,r3,r4
000010  2410              MOVS     r4,#0x10
000012  eb0401c1          ADD      r1,r4,r1,LSL #3
000016  408a              LSLS     r2,r2,r1
000018  4313              ORRS     r3,r3,r2
00001a  6003              STR      r3,[r0,#0]
;;;1394   }
00001c  bd30              POP      {r4,r5,pc}
;;;1395   
                          ENDP


                          AREA ||i.EPWM_SetClockSource||, CODE, READONLY, ALIGN=1

                  EPWM_SetClockSource PROC
;;;1307    */
;;;1308   void EPWM_SetClockSource(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32ClkSrcSel)
000000  b510              PUSH     {r4,lr}
;;;1309   {
;;;1310       (epwm)->CLKSRC = ((epwm)->CLKSRC & ~(EPWM_CLKSRC_ECLKSRC0_Msk << ((u32ChannelNum >> 1U) << 3U))) | \
000002  6903              LDR      r3,[r0,#0x10]
000004  0849              LSRS     r1,r1,#1
000006  00c9              LSLS     r1,r1,#3
000008  2407              MOVS     r4,#7
00000a  408c              LSLS     r4,r4,r1
00000c  43a3              BICS     r3,r3,r4
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6103              STR      r3,[r0,#0x10]
;;;1311                        (u32ClkSrcSel << ((u32ChannelNum >> 1U) << 3U));
;;;1312   }
000014  bd10              POP      {r4,pc}
;;;1313   
                          ENDP


                          AREA ||i.EPWM_SetLeadingEdgeBlanking||, CODE, READONLY, ALIGN=1

                  EPWM_SetLeadingEdgeBlanking PROC
;;;1421    */
;;;1422   void EPWM_SetLeadingEdgeBlanking(EPWM_T *epwm, uint32_t u32TrigSrcSel, uint32_t u32TrigType, uint32_t u32BlankingCnt, uint32_t u32BlankingEnable)
000000  b510              PUSH     {r4,lr}
;;;1423   {
;;;1424       (epwm)->LEBCTL = (u32TrigType) | (u32TrigSrcSel) | (u32BlankingEnable);
000002  430a              ORRS     r2,r2,r1
000004  9c02              LDR      r4,[sp,#8]
000006  4322              ORRS     r2,r2,r4
000008  f8c02118          STR      r2,[r0,#0x118]
00000c  1e5b              SUBS     r3,r3,#1
;;;1425       /* Blanking window size = LEBCNT + 1, so LEBCNT = u32BlankingCnt - 1 */
;;;1426       (epwm)->LEBCNT = (u32BlankingCnt) - 1U;
00000e  f8c0311c          STR      r3,[r0,#0x11c]
;;;1427   }
000012  bd10              POP      {r4,pc}
;;;1428   
                          ENDP


                          AREA ||i.EPWM_Start||, CODE, READONLY, ALIGN=1

                  EPWM_Start PROC
;;;210     */
;;;211    void EPWM_Start(EPWM_T *epwm, uint32_t u32ChannelMask)
000000  6a02              LDR      r2,[r0,#0x20]
;;;212    {
;;;213        (epwm)->CNTEN |= u32ChannelMask;
000002  430a              ORRS     r2,r2,r1
000004  6202              STR      r2,[r0,#0x20]
;;;214    }
000006  4770              BX       lr
;;;215    
                          ENDP


                          AREA ||i.EPWM_Stop||, CODE, READONLY, ALIGN=1

                  EPWM_Stop PROC
;;;225     */
;;;226    void EPWM_Stop(EPWM_T *epwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;227    {
;;;228        uint32_t i;
;;;229        for(i = 0U; i < EPWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;230        {
;;;231            if(u32ChannelMask & (1UL << i))
000004  2501              MOVS     r5,#1
000006  4614              MOV      r4,r2
                  |L72.8|
000008  fa05f302          LSL      r3,r5,r2
00000c  420b              TST      r3,r1
00000e  d002              BEQ      |L72.22|
;;;232            {
;;;233                (epwm)->PERIOD[i] = 0U;
000010  eb000382          ADD      r3,r0,r2,LSL #2
000014  631c              STR      r4,[r3,#0x30]
                  |L72.22|
000016  1c52              ADDS     r2,r2,#1
000018  2a06              CMP      r2,#6                 ;229
00001a  d3f5              BCC      |L72.8|
;;;234            }
;;;235        }
;;;236    }
00001c  bd30              POP      {r4,r5,pc}
;;;237    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\epwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_epwm_c_6b9cef3d____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_epwm_c_6b9cef3d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_epwm_c_6b9cef3d____REVSH|
#line 402
|__asm___6_epwm_c_6b9cef3d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_epwm_c_6b9cef3d____RRX|
#line 587
|__asm___6_epwm_c_6b9cef3d____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
