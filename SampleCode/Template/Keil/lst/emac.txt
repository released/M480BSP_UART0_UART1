; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\emac.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\emac.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -D__FPU_PRESENT=1 --omf_browse=.\obj\emac.crf ..\..\..\Library\StdDriver\src\emac.c]
                          THUMB

                          AREA ||i.EMAC_CheckLinkStatus||, CODE, READONLY, ALIGN=2

                  EMAC_CheckLinkStatus PROC
;;;926      */
;;;927    uint32_t EMAC_CheckLinkStatus(void)
000000  b510              PUSH     {r4,lr}
;;;928    {
;;;929        uint32_t reg, ret = EMAC_LINK_DOWN;
;;;930    
;;;931        /* Check link valid again */
;;;932        if(EMAC_MdioRead(PHY_STATUS_REG, EMAC_PHY_ADDR) & PHY_STATUS_LINK_VALID)
000002  2101              MOVS     r1,#1
000004  2400              MOVS     r4,#0                 ;929
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       EMAC_MdioRead
00000c  0740              LSLS     r0,r0,#29
00000e  d52f              BPL      |L1.112|
;;;933        {
;;;934            /* Check link partner capability */
;;;935            reg = EMAC_MdioRead(PHY_ANLPA_REG, EMAC_PHY_ADDR) ;
000010  2101              MOVS     r1,#1
000012  2005              MOVS     r0,#5
000014  f7fffffe          BL       EMAC_MdioRead
;;;936            if (reg & PHY_ANLPA_DR100_TX_FULL)
;;;937            {
;;;938                EMAC->CTL |= EMAC_CTL_OPMODE_Msk;
000018  4916              LDR      r1,|L1.116|
00001a  05c2              LSLS     r2,r0,#23             ;936
00001c  d50a              BPL      |L1.52|
00001e  f8510f90          LDR      r0,[r1,#0x90]!
000022  f4401080          ORR      r0,r0,#0x100000
000026  6008              STR      r0,[r1,#0]
;;;939                EMAC->CTL |= EMAC_CTL_FUDUP_Msk;
000028  6808              LDR      r0,[r1,#0]
00002a  f4402080          ORR      r0,r0,#0x40000
00002e  6008              STR      r0,[r1,#0]
;;;940                ret = EMAC_LINK_100F;
000030  2401              MOVS     r4,#1
000032  e01d              B        |L1.112|
                  |L1.52|
;;;941            }
;;;942            else if (reg & PHY_ANLPA_DR100_TX_HALF)
000034  0602              LSLS     r2,r0,#24
000036  d50a              BPL      |L1.78|
;;;943            {
;;;944                EMAC->CTL |= EMAC_CTL_OPMODE_Msk;
000038  f8510f90          LDR      r0,[r1,#0x90]!
00003c  f4401080          ORR      r0,r0,#0x100000
000040  6008              STR      r0,[r1,#0]
;;;945                EMAC->CTL &= ~EMAC_CTL_FUDUP_Msk;
000042  6808              LDR      r0,[r1,#0]
000044  f4202080          BIC      r0,r0,#0x40000
000048  6008              STR      r0,[r1,#0]
;;;946                ret = EMAC_LINK_100H;
00004a  2402              MOVS     r4,#2
00004c  e010              B        |L1.112|
                  |L1.78|
;;;947            }
;;;948            else if (reg & PHY_ANLPA_DR10_TX_FULL)
00004e  0640              LSLS     r0,r0,#25
;;;949            {
;;;950                EMAC->CTL &= ~EMAC_CTL_OPMODE_Msk;
;;;951                EMAC->CTL |= EMAC_CTL_FUDUP_Msk;
;;;952                ret = EMAC_LINK_10F;
;;;953            }
;;;954            else
;;;955            {
;;;956                EMAC->CTL &= ~EMAC_CTL_OPMODE_Msk;
000050  f8510f90          LDR      r0,[r1,#0x90]!
000054  f4201080          BIC      r0,r0,#0x100000
000058  6008              STR      r0,[r1,#0]
;;;957                EMAC->CTL &= ~EMAC_CTL_FUDUP_Msk;
00005a  6808              LDR      r0,[r1,#0]
00005c  d504              BPL      |L1.104|
00005e  f4402080          ORR      r0,r0,#0x40000        ;951
000062  6008              STR      r0,[r1,#0]            ;951
000064  2403              MOVS     r4,#3                 ;952
000066  e003              B        |L1.112|
                  |L1.104|
000068  f4202080          BIC      r0,r0,#0x40000
00006c  6008              STR      r0,[r1,#0]
;;;958                ret = EMAC_LINK_10H;
00006e  2404              MOVS     r4,#4
                  |L1.112|
;;;959            }
;;;960        }
;;;961        return ret;
000070  4620              MOV      r0,r4
;;;962    }
000072  bd10              POP      {r4,pc}
;;;963    
                          ENDP

                  |L1.116|
                          DCD      0x4000b000

                          AREA ||i.EMAC_Close||, CODE, READONLY, ALIGN=2

                  EMAC_Close PROC
;;;412    
;;;413    void EMAC_Close(void)
000000  4805              LDR      r0,|L2.24|
;;;414    {
;;;415        EMAC->CTL |= EMAC_CTL_RST_Msk;
000002  f8d01090          LDR      r1,[r0,#0x90]
000006  f0417180          ORR      r1,r1,#0x1000000
00000a  f8c01090          STR      r1,[r0,#0x90]
                  |L2.14|
;;;416        while(EMAC->CTL & EMAC_CTL_RST_Msk) {}
00000e  f8d01090          LDR      r1,[r0,#0x90]
000012  01c9              LSLS     r1,r1,#7
000014  d4fb              BMI      |L2.14|
;;;417    }
000016  4770              BX       lr
;;;418    
                          ENDP

                  |L2.24|
                          DCD      0x4000b000

                          AREA ||i.EMAC_DisableAlarm||, CODE, READONLY, ALIGN=2

                  EMAC_DisableAlarm PROC
;;;889      */
;;;890    void EMAC_DisableAlarm(void)
000000  4803              LDR      r0,|L3.16|
;;;891    {
;;;892    
;;;893        EMAC->TSCTL &= ~EMAC_TSCTL_TSALMEN_Msk;
000002  f8d01100          LDR      r1,[r0,#0x100]
000006  f0210120          BIC      r1,r1,#0x20
00000a  f8c01100          STR      r1,[r0,#0x100]
;;;894    
;;;895    }
00000e  4770              BX       lr
;;;896    
                          ENDP

                  |L3.16|
                          DCD      0x4000b000

                          AREA ||i.EMAC_DisableCamEntry||, CODE, READONLY, ALIGN=2

                  EMAC_DisableCamEntry PROC
;;;459      */
;;;460    void EMAC_DisableCamEntry(uint32_t u32Entry)
000000  4903              LDR      r1,|L4.16|
;;;461    {
;;;462        EMAC->CAMEN &= ~(1UL << u32Entry);
000002  684a              LDR      r2,[r1,#4]
000004  2301              MOVS     r3,#1
000006  4083              LSLS     r3,r3,r0
000008  439a              BICS     r2,r2,r3
00000a  604a              STR      r2,[r1,#4]
;;;463    }
00000c  4770              BX       lr
;;;464    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x4000b000

                          AREA ||i.EMAC_DisableTS||, CODE, READONLY, ALIGN=2

                  EMAC_DisableTS PROC
;;;835      */
;;;836    void EMAC_DisableTS(void)
000000  4902              LDR      r1,|L5.12|
;;;837    {
;;;838        EMAC->TSCTL = 0UL;
000002  2000              MOVS     r0,#0
000004  f8c10100          STR      r0,[r1,#0x100]
;;;839    }
000008  4770              BX       lr
;;;840    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x4000b000

                          AREA ||i.EMAC_EnableAlarm||, CODE, READONLY, ALIGN=2

                  EMAC_EnableAlarm PROC
;;;875      */
;;;876    void EMAC_EnableAlarm(uint32_t u32Sec, uint32_t u32Nsec)
000000  b510              PUSH     {r4,lr}
;;;877    {
;;;878    
;;;879        EMAC->ALMSEC = u32Sec;
000002  4c07              LDR      r4,|L6.32|
000004  f8c40128          STR      r0,[r4,#0x128]
;;;880        EMAC->ALMSUBSEC = EMAC_Nsec2Subsec(u32Nsec);
000008  4608              MOV      r0,r1
00000a  f5047480          ADD      r4,r4,#0x100
00000e  f7fffffe          BL       EMAC_Nsec2Subsec
000012  62e0              STR      r0,[r4,#0x2c]
;;;881        EMAC->TSCTL |= EMAC_TSCTL_TSALMEN_Msk;
000014  6820              LDR      r0,[r4,#0]
000016  f0400020          ORR      r0,r0,#0x20
00001a  6020              STR      r0,[r4,#0]
;;;882    
;;;883    }
00001c  bd10              POP      {r4,pc}
;;;884    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x4000b000

                          AREA ||i.EMAC_EnableCamEntry||, CODE, READONLY, ALIGN=2

                  EMAC_EnableCamEntry PROC
;;;435      */
;;;436    void EMAC_EnableCamEntry(uint32_t u32Entry, uint8_t pu8MacAddr[])
000000  888a              LDRH     r2,[r1,#4]
;;;437    {
;;;438        uint32_t u32Lsw, u32Msw;
;;;439        uint32_t reg;
;;;440        u32Lsw = (uint32_t)(((uint32_t)pu8MacAddr[4] << 24) |
000002  ba52              REV16    r2,r2
000004  0413              LSLS     r3,r2,#16
;;;441                            ((uint32_t)pu8MacAddr[5] << 16));
;;;442        u32Msw = (uint32_t)(((uint32_t)pu8MacAddr[0] << 24)|
000006  680a              LDR      r2,[r1,#0]
000008  78c9              LDRB     r1,[r1,#3]
00000a  ba12              REV      r2,r2
00000c  f02202ff          BIC      r2,r2,#0xff
000010  430a              ORRS     r2,r2,r1
;;;443                            ((uint32_t)pu8MacAddr[1] << 16)|
;;;444                            ((uint32_t)pu8MacAddr[2] << 8)|
;;;445                            (uint32_t)pu8MacAddr[3]);
;;;446    
;;;447        reg = (uint32_t)&EMAC->CAM0M + u32Entry * 2UL * 4UL;
000012  4907              LDR      r1,|L7.48|
;;;448        *(uint32_t volatile *)reg = u32Msw;
000014  f8412030          STR      r2,[r1,r0,LSL #3]
;;;449        reg = (uint32_t)&EMAC->CAM0L + u32Entry * 2UL * 4UL;
000018  1d09              ADDS     r1,r1,#4
;;;450        *(uint32_t volatile *)reg = u32Lsw;
00001a  f8413030          STR      r3,[r1,r0,LSL #3]
;;;451    
;;;452        EMAC->CAMEN |= (1UL << u32Entry);
00001e  4904              LDR      r1,|L7.48|
000020  3908              SUBS     r1,r1,#8
000022  684a              LDR      r2,[r1,#4]
000024  2301              MOVS     r3,#1
000026  4083              LSLS     r3,r3,r0
000028  431a              ORRS     r2,r2,r3
00002a  604a              STR      r2,[r1,#4]
;;;453    }
00002c  4770              BX       lr
;;;454    
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      0x4000b008

                          AREA ||i.EMAC_EnableTS||, CODE, READONLY, ALIGN=2

                  EMAC_EnableTS PROC
;;;807      */
;;;808    void EMAC_EnableTS(uint32_t u32Sec, uint32_t u32Nsec)
000000  b510              PUSH     {r4,lr}
;;;809    {
;;;810        double f;
;;;811        uint32_t reg;
;;;812        EMAC->TSCTL = EMAC_TSCTL_TSEN_Msk;
000002  4c1a              LDR      r4,|L8.108|
000004  2201              MOVS     r2,#1
000006  ed2d8b02          VPUSH    {d8}                  ;809
00000a  f8c42100          STR      r2,[r4,#0x100]
;;;813        EMAC->UPDSEC = u32Sec;   /* Assume current time is 0 sec + 0 nano sec */
00000e  f8c40120          STR      r0,[r4,#0x120]
;;;814        EMAC->UPDSUBSEC = EMAC_Nsec2Subsec(u32Nsec);
000012  4608              MOV      r0,r1
000014  f5047480          ADD      r4,r4,#0x100
000018  f7fffffe          BL       EMAC_Nsec2Subsec
00001c  6260              STR      r0,[r4,#0x24]
;;;815    
;;;816        /* PTP source clock is 160MHz (Real chip using PLL). Each tick is 6.25ns
;;;817           Assume we want to set each tick to 100ns.
;;;818           Increase register = (100 * 2^31) / (10^9) = 214.71 =~ 215 = 0xD7
;;;819           Addend register = 2^32 * tick_freq / (160MHz), where tick_freq = (2^31 / 215) MHz
;;;820           From above equation, addend register = 2^63 / (160M * 215) ~= 268121280 = 0xFFB34C0
;;;821           So:
;;;822            EMAC->TSIR = 0xD7;
;;;823            EMAC->TSAR = 0x1E70C600; */
;;;824        f = (100.0 * 2147483648.0) / (1000000000.0) + 0.5;
00001e  ed9f0b14          VLDR     d0,|L8.112|
;;;825        EMAC->TSINC = (reg = (uint32_t)f);
000022  ec510b10          VMOV     r0,r1,d0
000026  f7fffffe          BL       __aeabi_d2uiz
00002a  61a0              STR      r0,[r4,#0x18]
;;;826        f = (double)9223372036854775808.0 / ((double)(CLK_GetHCLKFreq()) * (double)reg);
00002c  f7fffffe          BL       __aeabi_ui2d
000030  ec410b18          VMOV     d8,r0,r1
000034  f7fffffe          BL       CLK_GetHCLKFreq
000038  f7fffffe          BL       __aeabi_ui2d
00003c  ec532b18          VMOV     r2,r3,d8
000040  f7fffffe          BL       __aeabi_dmul
000044  ec410b10          VMOV     d0,r0,r1
000048  ec532b10          VMOV     r2,r3,d0
00004c  ed9f0b0a          VLDR     d0,|L8.120|
000050  ec510b10          VMOV     r0,r1,d0
000054  f7fffffe          BL       __aeabi_ddiv
;;;827        EMAC->TSADDEND = (uint32_t)f;
000058  f7fffffe          BL       __aeabi_d2uiz
00005c  61e0              STR      r0,[r4,#0x1c]
;;;828        EMAC->TSCTL |= (EMAC_TSCTL_TSUPDATE_Msk | EMAC_TSCTL_TSIEN_Msk | EMAC_TSCTL_TSMODE_Msk); /* Fine update */
00005e  6820              LDR      r0,[r4,#0]
000060  f040000e          ORR      r0,r0,#0xe
000064  6020              STR      r0,[r4,#0]
;;;829    }
000066  ecbd8b02          VPOP     {d8}
00006a  bd10              POP      {r4,pc}
;;;830    
                          ENDP

                  |L8.108|
                          DCD      0x4000b000
                  |L8.112|
000070  9abcaf48          DCFD     0x406ae7f29abcaf48 ; 215.24836479999999
000074  406ae7f2
                  |L8.120|
000078  00000000          DCFD     0x43e0000000000000 ; 9223372036854775800
00007c  43e00000

                          AREA ||i.EMAC_GetTime||, CODE, READONLY, ALIGN=2

                  EMAC_GetTime PROC
;;;846      */
;;;847    void EMAC_GetTime(uint32_t *pu32Sec, uint32_t *pu32Nsec)
000000  b570              PUSH     {r4-r6,lr}
;;;848    {
;;;849        /* Must read TSLSR firstly. Hardware will preserve TSMSR value at the time TSLSR read. */
;;;850        *pu32Nsec = EMAC_Subsec2Nsec(EMAC->TSSUBSEC);
000002  4c06              LDR      r4,|L9.28|
000004  4606              MOV      r6,r0                 ;848
000006  460d              MOV      r5,r1                 ;848
000008  f8d40114          LDR      r0,[r4,#0x114]
00000c  f5047488          ADD      r4,r4,#0x110
000010  f7fffffe          BL       EMAC_Subsec2Nsec
;;;851        *pu32Sec = EMAC->TSSEC;
000014  6028              STR      r0,[r5,#0]
000016  6820              LDR      r0,[r4,#0]
000018  6030              STR      r0,[r6,#0]
;;;852    }
00001a  bd70              POP      {r4-r6,pc}
;;;853    
                          ENDP

                  |L9.28|
                          DCD      0x4000b000

                          AREA ||i.EMAC_MdioRead||, CODE, READONLY, ALIGN=2

                  EMAC_MdioRead PROC
;;;169      */
;;;170    static uint32_t EMAC_MdioRead(uint32_t u32Reg, uint32_t u32Addr)
000000  ea402001          ORR      r0,r0,r1,LSL #8
;;;171    {
;;;172        /* Set PHY address, PHY register address, busy bit */
;;;173        EMAC->MIIMCTL = u32Reg | (u32Addr << EMAC_MIIMCTL_PHYADDR_Pos) | EMAC_MIIMCTL_BUSY_Msk | EMAC_MIIMCTL_MDCON_Msk;
000004  f4402120          ORR      r1,r0,#0xa0000
000008  4804              LDR      r0,|L10.28|
00000a  f8c01098          STR      r1,[r0,#0x98]
                  |L10.14|
;;;174        /* Wait read complete by polling busy bit */
;;;175        while(EMAC->MIIMCTL & EMAC_MIIMCTL_BUSY_Msk)
00000e  f8d01098          LDR      r1,[r0,#0x98]
000012  0389              LSLS     r1,r1,#14
000014  d4fb              BMI      |L10.14|
;;;176        {
;;;177            ;
;;;178        }
;;;179        /* Get return data */
;;;180        return EMAC->MIIMDAT;
000016  f8d00094          LDR      r0,[r0,#0x94]
;;;181    }
00001a  4770              BX       lr
;;;182    
                          ENDP

                  |L10.28|
                          DCD      0x4000b000

                          AREA ||i.EMAC_MdioWrite||, CODE, READONLY, ALIGN=2

                  EMAC_MdioWrite PROC
;;;149      */
;;;150    static void EMAC_MdioWrite(uint32_t u32Reg, uint32_t u32Addr, uint32_t u32Data)
000000  4b06              LDR      r3,|L11.28|
;;;151    {
;;;152        /* Set data register */
;;;153        EMAC->MIIMDAT = u32Data ;
000002  f8c32094          STR      r2,[r3,#0x94]
;;;154        /* Set PHY address, PHY register address, busy bit and write bit */
;;;155        EMAC->MIIMCTL = u32Reg | (u32Addr << 8) | EMAC_MIIMCTL_BUSY_Msk | EMAC_MIIMCTL_WRITE_Msk | EMAC_MIIMCTL_MDCON_Msk;
000006  ea402001          ORR      r0,r0,r1,LSL #8
00000a  f4402030          ORR      r0,r0,#0xb0000
00000e  f8c30098          STR      r0,[r3,#0x98]
                  |L11.18|
;;;156        /* Wait write complete by polling busy bit. */
;;;157        while(EMAC->MIIMCTL & EMAC_MIIMCTL_BUSY_Msk)
000012  f8d30098          LDR      r0,[r3,#0x98]
000016  0380              LSLS     r0,r0,#14
000018  d4fb              BMI      |L11.18|
;;;158        {
;;;159            ;
;;;160        }
;;;161    
;;;162    }
00001a  4770              BX       lr
;;;163    
                          ENDP

                  |L11.28|
                          DCD      0x4000b000

                          AREA ||i.EMAC_Nsec2Subsec||, CODE, READONLY, ALIGN=2

                  EMAC_Nsec2Subsec PROC
;;;341      */
;;;342    static uint32_t EMAC_Nsec2Subsec(uint32_t nsec)
000000  b510              PUSH     {r4,lr}
;;;343    {
;;;344        /* 10^9 ns =  2^31 subsec */
;;;345        uint64_t i;
;;;346        i = (1ull << 31) * nsec;
000002  0841              LSRS     r1,r0,#1
000004  07c0              LSLS     r0,r0,#31
;;;347        i /= 1000000000ull;
000006  4a02              LDR      r2,|L12.16|
000008  2300              MOVS     r3,#0
00000a  f7fffffe          BL       __aeabi_uldivmod
;;;348        return((uint32_t)i);
;;;349    }
00000e  bd10              POP      {r4,pc}
;;;350    
                          ENDP

                  |L12.16|
                          DCD      0x3b9aca00

                          AREA ||i.EMAC_Open||, CODE, READONLY, ALIGN=2

                  EMAC_Open PROC
;;;372      */
;;;373    void EMAC_Open(uint8_t *pu8MacAddr)
000000  b510              PUSH     {r4,lr}
;;;374    {
000002  4604              MOV      r4,r0
;;;375        /* Enable transmit and receive descriptor */
;;;376        EMAC_TxDescInit();
000004  f7fffffe          BL       EMAC_TxDescInit
;;;377        EMAC_RxDescInit();
000008  f7fffffe          BL       EMAC_RxDescInit
;;;378    
;;;379        /* Set the CAM Control register and the MAC address value */
;;;380        EMAC_SetMacAddr(pu8MacAddr);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       EMAC_SetMacAddr
;;;381    
;;;382        /* Configure the MAC interrupt enable register. */
;;;383        EMAC->INTEN = EMAC_INTEN_RXIEN_Msk |
000012  4809              LDR      r0,|L13.56|
000014  4907              LDR      r1,|L13.52|
000016  f8c010ac          STR      r1,[r0,#0xac]
;;;384                      EMAC_INTEN_TXIEN_Msk |
;;;385                      EMAC_INTEN_RXGDIEN_Msk |
;;;386                      EMAC_INTEN_TXCPIEN_Msk |
;;;387                      EMAC_INTEN_RXBEIEN_Msk |
;;;388                      EMAC_INTEN_TXBEIEN_Msk |
;;;389                      EMAC_INTEN_RDUIEN_Msk |
;;;390                      EMAC_INTEN_TSALMIEN_Msk |
;;;391                      EMAC_INTEN_WOLIEN_Msk;
;;;392    
;;;393        /* Configure the MAC control register. */
;;;394        EMAC->CTL = EMAC_CTL_STRIPCRC_Msk |
00001a  4908              LDR      r1,|L13.60|
00001c  f8c01090          STR      r1,[r0,#0x90]
;;;395                    EMAC_CTL_RMIIEN_Msk;
;;;396    
;;;397        /* Accept packets for us and all broadcast and multicast packets */
;;;398        EMAC->CAMCTL =  EMAC_CAMCTL_CMPEN_Msk |
000020  2116              MOVS     r1,#0x16
000022  f8401b30          STR      r1,[r0],#0x30
;;;399                        EMAC_CAMCTL_AMP_Msk |
;;;400                        EMAC_CAMCTL_ABP_Msk;
;;;401    
;;;402        /* Limit the max receive frame length to 1514 + 4 */
;;;403        EMAC->MRFL = 1518;
000026  f24051ee          MOV      r1,#0x5ee
00002a  6781              STR      r1,[r0,#0x78]
;;;404        EMAC_PhyInit();
00002c  e8bd4010          POP      {r4,lr}
000030  f7ffbffe          B.W      EMAC_PhyInit
;;;405    }
;;;406    
                          ENDP

                  |L13.52|
                          DCD      0x11058c11
                  |L13.56|
                          DCD      0x4000b000
                  |L13.60|
                          DCD      0x00400020

                          AREA ||i.EMAC_PhyInit||, CODE, READONLY, ALIGN=2

                  EMAC_PhyInit PROC
;;;187      */
;;;188    static void EMAC_PhyInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;189    {
;;;190        uint32_t reg;
;;;191        uint32_t i = 0UL;
000002  2400              MOVS     r4,#0
;;;192    
;;;193        /* Reset Phy Chip */
;;;194        EMAC_MdioWrite(PHY_CNTL_REG, EMAC_PHY_ADDR, PHY_CNTL_RESET_PHY);
000004  f44f4200          MOV      r2,#0x8000
000008  2101              MOVS     r1,#1
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       EMAC_MdioWrite
                  |L14.16|
;;;195    
;;;196        /* Wait until reset complete */
;;;197        while (1)
;;;198        {
;;;199            reg = EMAC_MdioRead(PHY_CNTL_REG, EMAC_PHY_ADDR) ;
000010  2101              MOVS     r1,#1
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       EMAC_MdioRead
;;;200            if ((reg & PHY_CNTL_RESET_PHY)==0UL)
000018  0400              LSLS     r0,r0,#16
00001a  d4f9              BMI      |L14.16|
;;;201            {
;;;202                break;
;;;203            }
;;;204        }
;;;205        while(!(EMAC_MdioRead(PHY_STATUS_REG, EMAC_PHY_ADDR) & PHY_STATUS_LINK_VALID))
;;;206        {
;;;207            if(i++ > 80000UL)       /* Cable not connected */
00001c  4e2b              LDR      r6,|L14.204|
;;;208            {
;;;209                EMAC->CTL &= ~EMAC_CTL_OPMODE_Msk;
00001e  4d2c              LDR      r5,|L14.208|
                  |L14.32|
000020  2101              MOVS     r1,#1                 ;205
000022  4608              MOV      r0,r1                 ;205
000024  f7fffffe          BL       EMAC_MdioRead
000028  0740              LSLS     r0,r0,#29             ;205
00002a  d40f              BMI      |L14.76|
00002c  4620              MOV      r0,r4                 ;207
00002e  1c64              ADDS     r4,r4,#1              ;207
000030  42b0              CMP      r0,r6                 ;207
000032  d9f5              BLS      |L14.32|
000034  f8d50090          LDR      r0,[r5,#0x90]
000038  f4201080          BIC      r0,r0,#0x100000
00003c  f8c50090          STR      r0,[r5,#0x90]
;;;210                EMAC->CTL &= ~EMAC_CTL_FUDUP_Msk;
000040  f8d50090          LDR      r0,[r5,#0x90]
000044  f4202080          BIC      r0,r0,#0x40000
000048  f8c50090          STR      r0,[r5,#0x90]
                  |L14.76|
;;;211                break;
;;;212            }
;;;213        }
;;;214    
;;;215        if(i <= 80000UL)
00004c  42b4              CMP      r4,r6
00004e  d835              BHI      |L14.188|
;;;216        {
;;;217            /* Configure auto negotiation capability */
;;;218            EMAC_MdioWrite(PHY_ANA_REG, EMAC_PHY_ADDR, PHY_ANA_DR100_TX_FULL |
000050  f24012e1          MOV      r2,#0x1e1
000054  2101              MOVS     r1,#1
000056  2004              MOVS     r0,#4
000058  f7fffffe          BL       EMAC_MdioWrite
;;;219                           PHY_ANA_DR100_TX_HALF |
;;;220                           PHY_ANA_DR10_TX_FULL |
;;;221                           PHY_ANA_DR10_TX_HALF |
;;;222                           PHY_ANA_IEEE_802_3_CSMA_CD);
;;;223            /* Restart auto negotiation */
;;;224            EMAC_MdioWrite(PHY_CNTL_REG, EMAC_PHY_ADDR, EMAC_MdioRead(PHY_CNTL_REG, EMAC_PHY_ADDR) | PHY_CNTL_RESTART_AN);
00005c  2101              MOVS     r1,#1
00005e  2000              MOVS     r0,#0
000060  f7fffffe          BL       EMAC_MdioRead
000064  f4407200          ORR      r2,r0,#0x200
000068  2101              MOVS     r1,#1
00006a  2000              MOVS     r0,#0
00006c  f7fffffe          BL       EMAC_MdioWrite
                  |L14.112|
;;;225    
;;;226            /* Wait for auto-negotiation complete */
;;;227            while(!(EMAC_MdioRead(PHY_STATUS_REG, EMAC_PHY_ADDR) & PHY_STATUS_AN_COMPLETE))
000070  2101              MOVS     r1,#1
000072  4608              MOV      r0,r1
000074  f7fffffe          BL       EMAC_MdioRead
000078  0680              LSLS     r0,r0,#26
00007a  d5f9              BPL      |L14.112|
                  |L14.124|
;;;228            {
;;;229                ;
;;;230            }
;;;231            /* Check link valid again. Some PHYs needs to check result after link valid bit set */
;;;232            while(!(EMAC_MdioRead(PHY_STATUS_REG, EMAC_PHY_ADDR) & PHY_STATUS_LINK_VALID))
00007c  2101              MOVS     r1,#1
00007e  4608              MOV      r0,r1
000080  f7fffffe          BL       EMAC_MdioRead
000084  0740              LSLS     r0,r0,#29
000086  d5f9              BPL      |L14.124|
;;;233            {
;;;234                ;
;;;235            }
;;;236    
;;;237            /* Check link partner capability */
;;;238            reg = EMAC_MdioRead(PHY_ANLPA_REG, EMAC_PHY_ADDR) ;
000088  2101              MOVS     r1,#1
00008a  2005              MOVS     r0,#5
00008c  f7fffffe          BL       EMAC_MdioRead
;;;239            if (reg & PHY_ANLPA_DR100_TX_FULL)
000090  05c1              LSLS     r1,r0,#23
000092  d508              BPL      |L14.166|
;;;240            {
;;;241                EMAC->CTL |= EMAC_CTL_OPMODE_Msk;
000094  f8550f90          LDR      r0,[r5,#0x90]!
000098  f4401080          ORR      r0,r0,#0x100000
                  |L14.156|
;;;242                EMAC->CTL |= EMAC_CTL_FUDUP_Msk;
;;;243            }
;;;244            else if (reg & PHY_ANLPA_DR100_TX_HALF)
;;;245            {
;;;246                EMAC->CTL |= EMAC_CTL_OPMODE_Msk;
;;;247                EMAC->CTL &= ~EMAC_CTL_FUDUP_Msk;
;;;248            }
;;;249            else if (reg & PHY_ANLPA_DR10_TX_FULL)
;;;250            {
;;;251                EMAC->CTL &= ~EMAC_CTL_OPMODE_Msk;
00009c  6028              STR      r0,[r5,#0]
;;;252                EMAC->CTL |= EMAC_CTL_FUDUP_Msk;
00009e  6828              LDR      r0,[r5,#0]
0000a0  f4402080          ORR      r0,r0,#0x40000
0000a4  e009              B        |L14.186|
                  |L14.166|
0000a6  0601              LSLS     r1,r0,#24             ;244
0000a8  d509              BPL      |L14.190|
0000aa  f8550f90          LDR      r0,[r5,#0x90]!        ;246
0000ae  f4401080          ORR      r0,r0,#0x100000       ;246
                  |L14.178|
;;;253            }
;;;254            else
;;;255            {
;;;256                EMAC->CTL &= ~EMAC_CTL_OPMODE_Msk;
0000b2  6028              STR      r0,[r5,#0]
;;;257                EMAC->CTL &= ~EMAC_CTL_FUDUP_Msk;
0000b4  6828              LDR      r0,[r5,#0]
0000b6  f4202080          BIC      r0,r0,#0x40000
                  |L14.186|
0000ba  6028              STR      r0,[r5,#0]            ;242
                  |L14.188|
;;;258            }
;;;259        }
;;;260    }
0000bc  bd70              POP      {r4-r6,pc}
                  |L14.190|
0000be  0640              LSLS     r0,r0,#25             ;249
0000c0  f8550f90          LDR      r0,[r5,#0x90]!        ;256
0000c4  f4201080          BIC      r0,r0,#0x100000       ;256
0000c8  d4e8              BMI      |L14.156|
0000ca  e7f2              B        |L14.178|
;;;261    
                          ENDP

                  |L14.204|
                          DCD      0x00013880
                  |L14.208|
                          DCD      0x4000b000

                          AREA ||i.EMAC_RecvPkt||, CODE, READONLY, ALIGN=2

                  EMAC_RecvPkt PROC
;;;474      */
;;;475    uint32_t EMAC_RecvPkt(uint8_t *pu8Data, uint32_t *pu32Size)
000000  b570              PUSH     {r4-r6,lr}
;;;476    {
;;;477        EMAC_DESCRIPTOR_T *desc;
;;;478        uint32_t status, reg;
;;;479        uint32_t u32Count = 0UL;
;;;480    
;;;481        /* Clear Rx interrupt flags */
;;;482        reg = EMAC->INTSTS;
000002  4b0d              LDR      r3,|L15.56|
000004  4605              MOV      r5,r0                 ;476
000006  2000              MOVS     r0,#0                 ;479
000008  f8532fb0          LDR      r2,[r3,#0xb0]!
;;;483        EMAC->INTSTS = reg & 0xFFFFUL;  /* Clear all RX related interrupt status */
00000c  b294              UXTH     r4,r2
00000e  601c              STR      r4,[r3,#0]
;;;484    
;;;485        if (reg & EMAC_INTSTS_RXBEIF_Msk)
000010  0512              LSLS     r2,r2,#20
000012  d500              BPL      |L15.22|
                  |L15.20|
;;;486        {
;;;487            /* Bus error occurred, this is usually a bad sign about software bug and will occur again... */
;;;488            while(1) {}
000014  e7fe              B        |L15.20|
                  |L15.22|
;;;489        }
;;;490        else
;;;491        {
;;;492    
;;;493            /* Get Rx Frame Descriptor */
;;;494            desc = (EMAC_DESCRIPTOR_T *)u32CurrentRxDesc;
000016  4a09              LDR      r2,|L15.60|
;;;495    
;;;496            /* If we reach last recv Rx descriptor, leave the loop */
;;;497            if ((desc->u32Status1 & EMAC_DESC_OWN_EMAC) != EMAC_DESC_OWN_EMAC)   /* ownership=CPU */
000018  68d3              LDR      r3,[r2,#0xc]  ; u32CurrentRxDesc
00001a  681a              LDR      r2,[r3,#0]
00001c  2a00              CMP      r2,#0
00001e  db09              BLT      |L15.52|
;;;498            {
;;;499    
;;;500                status = desc->u32Status1 >> 16;
000020  0c14              LSRS     r4,r2,#16
;;;501    
;;;502                /* If Rx frame is good, process received frame */
;;;503                if(status & EMAC_RXFD_RXGD)
000022  06e4              LSLS     r4,r4,#27
000024  d506              BPL      |L15.52|
;;;504                {
;;;505                    /* lower 16 bit in descriptor status1 stores the Rx packet length */
;;;506                    *pu32Size = desc->u32Status1 & 0xFFFFUL;
000026  b292              UXTH     r2,r2
;;;507                    memcpy(pu8Data, (uint8_t *)desc->u32Backup1, *pu32Size);
000028  600a              STR      r2,[r1,#0]
00002a  4628              MOV      r0,r5
00002c  6919              LDR      r1,[r3,#0x10]
00002e  f7fffffe          BL       __aeabi_memcpy
;;;508                    u32Count = 1UL;
000032  2001              MOVS     r0,#1
                  |L15.52|
;;;509                }
;;;510                else
;;;511                {
;;;512                    /* Save Error status if necessary */
;;;513                    if (status & EMAC_RXFD_RP) {}
;;;514                    if (status & EMAC_RXFD_ALIE) {}
;;;515                    if (status & EMAC_RXFD_PTLE) {}
;;;516                    if (status & EMAC_RXFD_CRCE) {}
;;;517                }
;;;518            }
;;;519        }
;;;520        return(u32Count);
;;;521    }
000034  bd70              POP      {r4-r6,pc}
;;;522    
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
                          DCD      0x4000b000
                  |L15.60|
                          DCD      ||.data||

                          AREA ||i.EMAC_RecvPktDone||, CODE, READONLY, ALIGN=2

                  EMAC_RecvPktDone PROC
;;;597      */
;;;598    void EMAC_RecvPktDone(void)
000000  4908              LDR      r1,|L16.36|
;;;599    {
;;;600        EMAC_DESCRIPTOR_T *desc;
;;;601        /* Get Rx Frame Descriptor */
;;;602        desc = (EMAC_DESCRIPTOR_T *)u32CurrentRxDesc;
;;;603    
;;;604        /* Restore descriptor link list and data pointer they will be overwrite if time stamp enabled */
;;;605        desc->u32Data = desc->u32Backup1;
000002  68c8              LDR      r0,[r1,#0xc]  ; u32CurrentRxDesc
000004  6902              LDR      r2,[r0,#0x10]
;;;606        desc->u32Next = desc->u32Backup2;
000006  6042              STR      r2,[r0,#4]
000008  6942              LDR      r2,[r0,#0x14]
;;;607    
;;;608        /* Change ownership to DMA for next use */
;;;609        desc->u32Status1 |= EMAC_DESC_OWN_EMAC;
00000a  60c2              STR      r2,[r0,#0xc]
00000c  6802              LDR      r2,[r0,#0]
00000e  f0424200          ORR      r2,r2,#0x80000000
;;;610    
;;;611        /* Get Next Frame Descriptor pointer to process */
;;;612        desc = (EMAC_DESCRIPTOR_T *)desc->u32Next;
000012  6002              STR      r2,[r0,#0]
000014  68c0              LDR      r0,[r0,#0xc]
;;;613    
;;;614        /* Save last processed Rx descriptor */
;;;615        u32CurrentRxDesc = (uint32_t)desc;
;;;616    
;;;617        EMAC_TRIGGER_RX();
000016  60c8              STR      r0,[r1,#0xc]  ; u32CurrentRxDesc
000018  4903              LDR      r1,|L16.40|
00001a  2000              MOVS     r0,#0
00001c  f8c100a4          STR      r0,[r1,#0xa4]
;;;618    }
000020  4770              BX       lr
;;;619    
                          ENDP

000022  0000              DCW      0x0000
                  |L16.36|
                          DCD      ||.data||
                  |L16.40|
                          DCD      0x4000b000

                          AREA ||i.EMAC_RecvPktTS||, CODE, READONLY, ALIGN=2

                  EMAC_RecvPktTS PROC
;;;535      */
;;;536    uint32_t EMAC_RecvPktTS(uint8_t *pu8Data, uint32_t *pu32Size, uint32_t *pu32Sec, uint32_t *pu32Nsec)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;537    {
;;;538        EMAC_DESCRIPTOR_T *desc;
;;;539        uint32_t status, reg;
;;;540        uint32_t u32Count = 0UL;
;;;541    
;;;542        /* Clear Rx interrupt flags */
;;;543        reg = EMAC->INTSTS;
000004  4f13              LDR      r7,|L17.84|
000006  461d              MOV      r5,r3                 ;537
000008  4616              MOV      r6,r2                 ;537
00000a  4603              MOV      r3,r0                 ;537
00000c  f8d720b0          LDR      r2,[r7,#0xb0]
000010  2000              MOVS     r0,#0                 ;540
;;;544        EMAC->INTSTS = reg & 0xFFFFUL; /* Clear all Rx related interrupt status */
000012  b294              UXTH     r4,r2
000014  f8c740b0          STR      r4,[r7,#0xb0]
;;;545    
;;;546        if (reg & EMAC_INTSTS_RXBEIF_Msk)
000018  0512              LSLS     r2,r2,#20
00001a  d500              BPL      |L17.30|
                  |L17.28|
;;;547        {
;;;548            /* Bus error occurred, this is usually a bad sign about software bug and will occur again... */
;;;549            while(1) {}
00001c  e7fe              B        |L17.28|
                  |L17.30|
;;;550        }
;;;551        else
;;;552        {
;;;553    
;;;554            /* Get Rx Frame Descriptor */
;;;555            desc = (EMAC_DESCRIPTOR_T *)u32CurrentRxDesc;
00001e  4a0e              LDR      r2,|L17.88|
;;;556    
;;;557            /* If we reach last recv Rx descriptor, leave the loop */
;;;558            if(EMAC->CRXDSA != (uint32_t)desc)
000020  68d4              LDR      r4,[r2,#0xc]  ; u32CurrentRxDesc
000022  f8d720d4          LDR      r2,[r7,#0xd4]
000026  42a2              CMP      r2,r4
000028  d012              BEQ      |L17.80|
;;;559            {
;;;560                if ((desc->u32Status1 | EMAC_DESC_OWN_EMAC) != EMAC_DESC_OWN_EMAC)   /* ownership=CPU */
00002a  6822              LDR      r2,[r4,#0]
00002c  0057              LSLS     r7,r2,#1
00002e  d00f              BEQ      |L17.80|
;;;561                {
;;;562    
;;;563                    status = desc->u32Status1 >> 16;
000030  0c17              LSRS     r7,r2,#16
;;;564    
;;;565                    /* If Rx frame is good, process received frame */
;;;566                    if(status & EMAC_RXFD_RXGD)
000032  06ff              LSLS     r7,r7,#27
000034  d50c              BPL      |L17.80|
;;;567                    {
;;;568                        /* lower 16 bit in descriptor status1 stores the Rx packet length */
;;;569                        *pu32Size = desc->u32Status1 & 0xFFFFUL;
000036  b292              UXTH     r2,r2
;;;570                        memcpy(pu8Data, (uint8_t *)desc->u32Backup1, *pu32Size);
000038  600a              STR      r2,[r1,#0]
00003a  4618              MOV      r0,r3
00003c  6921              LDR      r1,[r4,#0x10]
00003e  f7fffffe          BL       __aeabi_memcpy
;;;571    
;;;572                        *pu32Sec = desc->u32Next; /* second stores in descriptor's NEXT field */
000042  68e0              LDR      r0,[r4,#0xc]
;;;573                        *pu32Nsec = EMAC_Subsec2Nsec(desc->u32Data); /* Sub nano second store in DATA field */
000044  6030              STR      r0,[r6,#0]
000046  6860              LDR      r0,[r4,#4]
000048  f7fffffe          BL       EMAC_Subsec2Nsec
;;;574    
;;;575                        u32Count = 1UL;
00004c  6028              STR      r0,[r5,#0]
00004e  2001              MOVS     r0,#1
                  |L17.80|
;;;576                    }
;;;577                    else
;;;578                    {
;;;579                        /* Save Error status if necessary */
;;;580                        if (status & EMAC_RXFD_RP) {}
;;;581                        if (status & EMAC_RXFD_ALIE) {}
;;;582                        if (status & EMAC_RXFD_PTLE) {}
;;;583                        if (status & EMAC_RXFD_CRCE) {}
;;;584                    }
;;;585                }
;;;586            }
;;;587        }
;;;588        return(u32Count);
;;;589    }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;590    
                          ENDP

                  |L17.84|
                          DCD      0x4000b000
                  |L17.88|
                          DCD      ||.data||

                          AREA ||i.EMAC_RxDescInit||, CODE, READONLY, ALIGN=2

                  EMAC_RxDescInit PROC
;;;301      */
;;;302    static void EMAC_RxDescInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;303    {
;;;304    
;;;305        uint32_t i;
;;;306    
;;;307        /* Get Frame descriptor's base address. */
;;;308        EMAC->RXDSA = (uint32_t)&rx_desc[0];
000002  4816              LDR      r0,|L18.92|
000004  4a14              LDR      r2,|L18.88|
000006  f8c0208c          STR      r2,[r0,#0x8c]
;;;309        u32CurrentRxDesc = (uint32_t)&rx_desc[0];
00000a  4815              LDR      r0,|L18.96|
;;;310    
;;;311        for(i = 0UL; i < EMAC_RX_DESC_SIZE; i++)
00000c  2100              MOVS     r1,#0
00000e  460b              MOV      r3,r1
;;;312        {
;;;313            rx_desc[i].u32Status1 = EMAC_DESC_OWN_EMAC;
000010  f04f4400          MOV      r4,#0x80000000
;;;314            rx_desc[i].u32Data = (uint32_t)((uint32_t)&rx_buf[i]);
000014  f1020560          ADD      r5,r2,#0x60
000018  60c2              STR      r2,[r0,#0xc]  ; u32CurrentRxDesc
                  |L18.26|
00001a  eb010041          ADD      r0,r1,r1,LSL #1       ;313
00001e  f8424030          STR      r4,[r2,r0,LSL #3]     ;313
000022  ebc11641          RSB      r6,r1,r1,LSL #5
000026  eb061681          ADD      r6,r6,r1,LSL #6
00002a  eb0200c0          ADD      r0,r2,r0,LSL #3
00002e  eb051606          ADD      r6,r5,r6,LSL #4
000032  6046              STR      r6,[r0,#4]
;;;315            rx_desc[i].u32Backup1 = rx_desc[i].u32Data;
000034  6846              LDR      r6,[r0,#4]
000036  6106              STR      r6,[r0,#0x10]
;;;316            rx_desc[i].u32Status2 = 0UL;
000038  6083              STR      r3,[r0,#8]
;;;317            rx_desc[i].u32Next = (uint32_t)&rx_desc[(i + 1UL) % EMAC_RX_DESC_SIZE];
00003a  1c4e              ADDS     r6,r1,#1
00003c  f0060603          AND      r6,r6,#3
000040  eb060646          ADD      r6,r6,r6,LSL #1
000044  eb0206c6          ADD      r6,r2,r6,LSL #3
000048  60c6              STR      r6,[r0,#0xc]
;;;318            rx_desc[i].u32Backup2 = rx_desc[i].u32Next;
00004a  68c6              LDR      r6,[r0,#0xc]
00004c  6146              STR      r6,[r0,#0x14]
00004e  1c49              ADDS     r1,r1,#1
000050  2904              CMP      r1,#4                 ;311
000052  d3e2              BCC      |L18.26|
;;;319        }
;;;320    
;;;321    }
000054  bd70              POP      {r4-r6,pc}
;;;322    
                          ENDP

000056  0000              DCW      0x0000
                  |L18.88|
                          DCD      ||.bss||
                  |L18.92|
                          DCD      0x4000b000
                  |L18.96|
                          DCD      ||.data||

                          AREA ||i.EMAC_SendPkt||, CODE, READONLY, ALIGN=2

                  EMAC_SendPkt PROC
;;;629      */
;;;630    uint32_t EMAC_SendPkt(uint8_t *pu8Data, uint32_t u32Size)
000000  b570              PUSH     {r4-r6,lr}
;;;631    {
;;;632        EMAC_DESCRIPTOR_T *desc;
;;;633        uint32_t status;
;;;634        uint32_t ret = 0UL;
;;;635        /* Get Tx frame descriptor & data pointer */
;;;636        desc = (EMAC_DESCRIPTOR_T *)u32NextTxDesc;
000002  4d0d              LDR      r5,|L19.56|
000004  460e              MOV      r6,r1                 ;631
000006  4603              MOV      r3,r0                 ;631
;;;637    
;;;638        status = desc->u32Status1;
000008  68ac              LDR      r4,[r5,#8]  ; u32NextTxDesc
00000a  2000              MOVS     r0,#0                 ;634
;;;639    
;;;640        /* Check descriptor ownership */
;;;641        if((status & EMAC_DESC_OWN_EMAC) != EMAC_DESC_OWN_EMAC)
00000c  6821              LDR      r1,[r4,#0]
00000e  2900              CMP      r1,#0
000010  db10              BLT      |L19.52|
;;;642        {
;;;643            memcpy((uint8_t *)desc->u32Data, pu8Data, u32Size);
000012  4632              MOV      r2,r6
000014  4619              MOV      r1,r3
000016  6860              LDR      r0,[r4,#4]
000018  f7fffffe          BL       __aeabi_memcpy
;;;644    
;;;645            /* Set Tx descriptor transmit byte count */
;;;646            desc->u32Status2 = u32Size;
;;;647    
;;;648            /* Change descriptor ownership to EMAC */
;;;649            desc->u32Status1 |= EMAC_DESC_OWN_EMAC;
00001c  60a6              STR      r6,[r4,#8]
00001e  6820              LDR      r0,[r4,#0]
;;;650    
;;;651            /* Get next Tx descriptor */
;;;652            u32NextTxDesc = (uint32_t)(desc->u32Next);
;;;653    
;;;654            /* Trigger EMAC to send the packet */
;;;655            EMAC_TRIGGER_TX();
000020  4906              LDR      r1,|L19.60|
000022  f0404000          ORR      r0,r0,#0x80000000     ;649
000026  6020              STR      r0,[r4,#0]            ;652
000028  68e0              LDR      r0,[r4,#0xc]          ;652
00002a  60a8              STR      r0,[r5,#8]  ; u32NextTxDesc
00002c  2000              MOVS     r0,#0
00002e  f8c100a0          STR      r0,[r1,#0xa0]
;;;656            ret = 1UL;
000032  2001              MOVS     r0,#1
                  |L19.52|
;;;657        }
;;;658        return(ret);
;;;659    }
000034  bd70              POP      {r4-r6,pc}
;;;660    
                          ENDP

000036  0000              DCW      0x0000
                  |L19.56|
                          DCD      ||.data||
                  |L19.60|
                          DCD      0x4000b000

                          AREA ||i.EMAC_SendPktDone||, CODE, READONLY, ALIGN=2

                  EMAC_SendPktDone PROC
;;;668      */
;;;669    uint32_t EMAC_SendPktDone(void)
000000  4a10              LDR      r2,|L20.68|
;;;670    {
000002  b510              PUSH     {r4,lr}
;;;671        EMAC_DESCRIPTOR_T *desc;
;;;672        uint32_t status, reg;
;;;673        uint32_t last_tx_desc;
;;;674        uint32_t u32Count = 0UL;
;;;675    
;;;676        reg = EMAC->INTSTS;
000004  f8d210b0          LDR      r1,[r2,#0xb0]
000008  2000              MOVS     r0,#0                 ;674
;;;677        /* Clear Tx interrupt flags */
;;;678        EMAC->INTSTS = reg & (0xFFFF0000UL & ~EMAC_INTSTS_TSALMIF_Msk);
00000a  4b0f              LDR      r3,|L20.72|
00000c  400b              ANDS     r3,r3,r1
00000e  f8c230b0          STR      r3,[r2,#0xb0]
;;;679    
;;;680    
;;;681        if (reg & EMAC_INTSTS_TXBEIF_Msk)
000012  01c9              LSLS     r1,r1,#7
000014  d500              BPL      |L20.24|
                  |L20.22|
;;;682        {
;;;683            /* Bus error occurred, this is usually a bad sign about software bug and will occur again... */
;;;684            while(1) {}
000016  e7fe              B        |L20.22|
                  |L20.24|
;;;685        }
;;;686        else
;;;687        {
;;;688            /* Process the descriptor(s). */
;;;689            last_tx_desc = EMAC->CTXDSA ;
000018  f8d230cc          LDR      r3,[r2,#0xcc]
;;;690            /* Get our first descriptor to process */
;;;691            desc = (EMAC_DESCRIPTOR_T *) u32CurrentTxDesc;
00001c  4c0b              LDR      r4,|L20.76|
00001e  6861              LDR      r1,[r4,#4]  ; u32CurrentTxDesc
                  |L20.32|
;;;692            do
;;;693            {
;;;694                /* Descriptor ownership is still EMAC, so this packet haven't been send. */
;;;695                if(desc->u32Status1 & EMAC_DESC_OWN_EMAC)
000020  680a              LDR      r2,[r1,#0]
000022  2a00              CMP      r2,#0
000024  db0b              BLT      |L20.62|
;;;696                {
;;;697                    break;
;;;698                }
;;;699                /* Get Tx status stored in descriptor */
;;;700                status = desc->u32Status2 >> 16UL;
000026  688a              LDR      r2,[r1,#8]
000028  0c12              LSRS     r2,r2,#16
;;;701                if (status & EMAC_TXFD_TXCP)
00002a  0712              LSLS     r2,r2,#28
00002c  d500              BPL      |L20.48|
00002e  1c40              ADDS     r0,r0,#1
                  |L20.48|
;;;702                {
;;;703                    u32Count++;
;;;704                }
;;;705                else
;;;706                {
;;;707                    /* Do nothing here on error. */
;;;708                    if (status & EMAC_TXFD_TXABT) {}
;;;709                    if (status & EMAC_TXFD_DEF) {}
;;;710                    if (status & EMAC_TXFD_PAU) {}
;;;711                    if (status & EMAC_TXFD_EXDEF) {}
;;;712                    if (status & EMAC_TXFD_NCS) {}
;;;713                    if (status & EMAC_TXFD_SQE) {}
;;;714                    if (status & EMAC_TXFD_LC) {}
;;;715                    if (status & EMAC_TXFD_TXHA) {}
;;;716                }
;;;717    
;;;718                /* restore descriptor link list and data pointer they will be overwrite if time stamp enabled */
;;;719                desc->u32Data = desc->u32Backup1;
000030  690a              LDR      r2,[r1,#0x10]
;;;720                desc->u32Next = desc->u32Backup2;
000032  604a              STR      r2,[r1,#4]
000034  694a              LDR      r2,[r1,#0x14]
;;;721                /* go to next descriptor in link */
;;;722                desc = (EMAC_DESCRIPTOR_T *)desc->u32Next;
000036  60ca              STR      r2,[r1,#0xc]
000038  4611              MOV      r1,r2
;;;723            }
;;;724            while (last_tx_desc != (uint32_t)desc);      /* If we reach last sent Tx descriptor, leave the loop */
00003a  428b              CMP      r3,r1
00003c  d1f0              BNE      |L20.32|
                  |L20.62|
;;;725            /* Save last processed Tx descriptor */
;;;726            u32CurrentTxDesc = (uint32_t)desc;
00003e  6061              STR      r1,[r4,#4]  ; u32CurrentTxDesc
;;;727        }
;;;728        return(u32Count);
;;;729    }
000040  bd10              POP      {r4,pc}
;;;730    
                          ENDP

000042  0000              DCW      0x0000
                  |L20.68|
                          DCD      0x4000b000
                  |L20.72|
                          DCD      0xefff0000
                  |L20.76|
                          DCD      ||.data||

                          AREA ||i.EMAC_SendPktDoneTS||, CODE, READONLY, ALIGN=2

                  EMAC_SendPktDoneTS PROC
;;;740      */
;;;741    uint32_t EMAC_SendPktDoneTS(uint32_t *pu32Sec, uint32_t *pu32Nsec)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;742    {
000004  460e              MOV      r6,r1
000006  4601              MOV      r1,r0
;;;743    
;;;744        EMAC_DESCRIPTOR_T *desc;
;;;745        uint32_t status, reg;
;;;746        uint32_t u32Count = 0UL;
;;;747    
;;;748        reg = EMAC->INTSTS;
000008  4810              LDR      r0,|L21.76|
00000a  2500              MOVS     r5,#0                 ;746
00000c  f8502fb0          LDR      r2,[r0,#0xb0]!
;;;749        /* Clear Tx interrupt flags */
;;;750        EMAC->INTSTS = reg & (0xFFFF0000UL & ~EMAC_INTSTS_TSALMIF_Msk);
000010  4b0f              LDR      r3,|L21.80|
000012  4013              ANDS     r3,r3,r2
000014  6003              STR      r3,[r0,#0]
;;;751    
;;;752    
;;;753        if (reg & EMAC_INTSTS_TXBEIF_Msk)
000016  01d0              LSLS     r0,r2,#7
000018  d500              BPL      |L21.28|
                  |L21.26|
;;;754        {
;;;755            /* Bus error occurred, this is usually a bad sign about software bug and will occur again... */
;;;756            while(1) {}
00001a  e7fe              B        |L21.26|
                  |L21.28|
;;;757        }
;;;758        else
;;;759        {
;;;760            /* Process the descriptor.
;;;761               Get our first descriptor to process */
;;;762            desc = (EMAC_DESCRIPTOR_T *) u32CurrentTxDesc;
00001c  4f0d              LDR      r7,|L21.84|
;;;763    
;;;764            /* Descriptor ownership is still EMAC, so this packet haven't been send. */
;;;765            if((desc->u32Status1 & EMAC_DESC_OWN_EMAC) != EMAC_DESC_OWN_EMAC)
00001e  687c              LDR      r4,[r7,#4]  ; u32CurrentTxDesc
000020  6820              LDR      r0,[r4,#0]
000022  2800              CMP      r0,#0
000024  db0f              BLT      |L21.70|
;;;766            {
;;;767                /* Get Tx status stored in descriptor */
;;;768                status = desc->u32Status2 >> 16UL;
000026  68a0              LDR      r0,[r4,#8]
000028  0c00              LSRS     r0,r0,#16
;;;769                if (status & EMAC_TXFD_TXCP)
00002a  0700              LSLS     r0,r0,#28
00002c  d506              BPL      |L21.60|
;;;770                {
;;;771                    u32Count = 1UL;
;;;772                    *pu32Sec = desc->u32Next; /* second stores in descriptor's NEXT field */
00002e  68e0              LDR      r0,[r4,#0xc]
;;;773                    *pu32Nsec = EMAC_Subsec2Nsec(desc->u32Data); /* Sub nano second store in DATA field */
000030  6008              STR      r0,[r1,#0]
000032  2501              MOVS     r5,#1                 ;771
000034  6860              LDR      r0,[r4,#4]
000036  f7fffffe          BL       EMAC_Subsec2Nsec
00003a  6030              STR      r0,[r6,#0]
                  |L21.60|
;;;774                }
;;;775                else
;;;776                {
;;;777                    /* Do nothing here on error. */
;;;778                    if (status & EMAC_TXFD_TXABT) {}
;;;779                    if (status & EMAC_TXFD_DEF) {}
;;;780                    if (status & EMAC_TXFD_PAU) {}
;;;781                    if (status & EMAC_TXFD_EXDEF) {}
;;;782                    if (status & EMAC_TXFD_NCS) {}
;;;783                    if (status & EMAC_TXFD_SQE) {}
;;;784                    if (status & EMAC_TXFD_LC) {}
;;;785                    if (status & EMAC_TXFD_TXHA) {}
;;;786                }
;;;787    
;;;788                /* restore descriptor link list and data pointer they will be overwrite if time stamp enabled */
;;;789                desc->u32Data = desc->u32Backup1;
00003c  6920              LDR      r0,[r4,#0x10]
;;;790                desc->u32Next = desc->u32Backup2;
00003e  6060              STR      r0,[r4,#4]
000040  6960              LDR      r0,[r4,#0x14]
;;;791                /* go to next descriptor in link */
;;;792                desc = (EMAC_DESCRIPTOR_T *)desc->u32Next;
;;;793    
;;;794                /* Save last processed Tx descriptor */
;;;795                u32CurrentTxDesc = (uint32_t)desc;
000042  60e0              STR      r0,[r4,#0xc]
000044  6078              STR      r0,[r7,#4]  ; u32CurrentTxDesc
                  |L21.70|
;;;796            }
;;;797        }
;;;798    
;;;799        return(u32Count);
000046  4628              MOV      r0,r5
;;;800    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;801    
                          ENDP

                  |L21.76|
                          DCD      0x4000b000
                  |L21.80|
                          DCD      0xefff0000
                  |L21.84|
                          DCD      ||.data||

                          AREA ||i.EMAC_SetMacAddr||, CODE, READONLY, ALIGN=1

                  EMAC_SetMacAddr PROC
;;;423      */
;;;424    void EMAC_SetMacAddr(uint8_t *pu8MacAddr)
000000  4601              MOV      r1,r0
;;;425    {
;;;426        EMAC_EnableCamEntry(0UL, pu8MacAddr);
000002  2000              MOVS     r0,#0
000004  f7ffbffe          B.W      EMAC_EnableCamEntry
;;;427    
;;;428    }
;;;429    
                          ENDP


                          AREA ||i.EMAC_SetTime||, CODE, READONLY, ALIGN=2

                  EMAC_SetTime PROC
;;;859      */
;;;860    void EMAC_SetTime(uint32_t u32Sec, uint32_t u32Nsec)
000000  b510              PUSH     {r4,lr}
;;;861    {
;;;862        /* Disable time stamp counter before update time value (clear EMAC_TSCTL_TSIEN_Msk) */
;;;863        EMAC->TSCTL = EMAC_TSCTL_TSEN_Msk;
000002  4c08              LDR      r4,|L23.36|
000004  2201              MOVS     r2,#1
000006  f8c42100          STR      r2,[r4,#0x100]
;;;864        EMAC->UPDSEC = u32Sec;
00000a  f8c40120          STR      r0,[r4,#0x120]
;;;865        EMAC->UPDSUBSEC = EMAC_Nsec2Subsec(u32Nsec);
00000e  4608              MOV      r0,r1
000010  f5047480          ADD      r4,r4,#0x100
000014  f7fffffe          BL       EMAC_Nsec2Subsec
000018  6260              STR      r0,[r4,#0x24]
;;;866        EMAC->TSCTL |= (EMAC_TSCTL_TSIEN_Msk | EMAC_TSCTL_TSMODE_Msk);
00001a  6820              LDR      r0,[r4,#0]
00001c  f0400006          ORR      r0,r0,#6
000020  6020              STR      r0,[r4,#0]
;;;867    
;;;868    }
000022  bd10              POP      {r4,pc}
;;;869    
                          ENDP

                  |L23.36|
                          DCD      0x4000b000

                          AREA ||i.EMAC_Subsec2Nsec||, CODE, READONLY, ALIGN=2

                  EMAC_Subsec2Nsec PROC
;;;327      */
;;;328    static uint32_t EMAC_Subsec2Nsec(uint32_t subsec)
000000  4903              LDR      r1,|L24.16|
;;;329    {
;;;330        /* 2^31 subsec == 10^9 ns */
;;;331        uint64_t i;
;;;332        i = 1000000000ull * (uint64_t)subsec;
000002  fba00101          UMULL    r0,r1,r0,r1
;;;333        i >>= 31;
000006  0fc0              LSRS     r0,r0,#31
000008  ea400041          ORR      r0,r0,r1,LSL #1
;;;334        return((uint32_t)i);
;;;335    }
00000c  4770              BX       lr
;;;336    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      0x3b9aca00

                          AREA ||i.EMAC_TxDescInit||, CODE, READONLY, ALIGN=2

                  EMAC_TxDescInit PROC
;;;266      */
;;;267    static void EMAC_TxDescInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;268    {
;;;269        uint32_t i;
;;;270    
;;;271        /* Get Frame descriptor's base address. */
;;;272        EMAC->TXDSA = (uint32_t)&tx_desc[0];
000002  4819              LDR      r0,|L25.104|
000004  4a17              LDR      r2,|L25.100|
000006  f8c02088          STR      r2,[r0,#0x88]
;;;273        u32NextTxDesc = u32CurrentTxDesc = (uint32_t)&tx_desc[0];
00000a  4918              LDR      r1,|L25.108|
;;;274    
;;;275        for(i = 0UL; i < EMAC_TX_DESC_SIZE; i++)
00000c  2000              MOVS     r0,#0
;;;276        {
;;;277    
;;;278            if(s_u32EnableTs)
00000e  4604              MOV      r4,r0
000010  604a              STR      r2,[r1,#4]            ;273  ; u32CurrentTxDesc
000012  608a              STR      r2,[r1,#8]  ; u32NextTxDesc
;;;279            {
;;;280                tx_desc[i].u32Status1 = EMAC_TXFD_PADEN | EMAC_TXFD_CRCAPP | EMAC_TXFD_INTEN;
;;;281            }
;;;282            else
;;;283            {
;;;284                tx_desc[i].u32Status1 = EMAC_TXFD_PADEN | EMAC_TXFD_CRCAPP | EMAC_TXFD_INTEN | EMAC_TXFD_TTSEN;
;;;285            }
;;;286            tx_desc[i].u32Data = (uint32_t)((uint32_t)&tx_buf[i]);
000014  680b              LDR      r3,[r1,#0]
000016  f1020560          ADD      r5,r2,#0x60
                  |L25.26|
00001a  b10b              CBZ      r3,|L25.32|
00001c  2107              MOVS     r1,#7                 ;280
00001e  e000              B        |L25.34|
                  |L25.32|
000020  210f              MOVS     r1,#0xf               ;284
                  |L25.34|
000022  eb000640          ADD      r6,r0,r0,LSL #1       ;284
000026  f8421036          STR      r1,[r2,r6,LSL #3]     ;284
00002a  ebc01140          RSB      r1,r0,r0,LSL #5
00002e  eb011180          ADD      r1,r1,r0,LSL #6
000032  eb051601          ADD      r6,r5,r1,LSL #4
000036  eb000140          ADD      r1,r0,r0,LSL #1
00003a  eb0201c1          ADD      r1,r2,r1,LSL #3
00003e  604e              STR      r6,[r1,#4]
;;;287            tx_desc[i].u32Backup1 = tx_desc[i].u32Data;
000040  684e              LDR      r6,[r1,#4]
000042  610e              STR      r6,[r1,#0x10]
;;;288            tx_desc[i].u32Status2 = 0UL;
000044  608c              STR      r4,[r1,#8]
;;;289            tx_desc[i].u32Next = (uint32_t)&tx_desc[(i + 1UL) % EMAC_TX_DESC_SIZE];
000046  1c46              ADDS     r6,r0,#1
000048  f0060603          AND      r6,r6,#3
00004c  eb060646          ADD      r6,r6,r6,LSL #1
000050  eb0206c6          ADD      r6,r2,r6,LSL #3
000054  60ce              STR      r6,[r1,#0xc]
;;;290            tx_desc[i].u32Backup2 = tx_desc[i].u32Next;
000056  68ce              LDR      r6,[r1,#0xc]
000058  614e              STR      r6,[r1,#0x14]
00005a  1c40              ADDS     r0,r0,#1
00005c  2804              CMP      r0,#4                 ;275
00005e  d3dc              BCC      |L25.26|
;;;291    
;;;292        }
;;;293    
;;;294    }
000060  bd70              POP      {r4-r6,pc}
;;;295    
                          ENDP

000062  0000              DCW      0x0000
                  |L25.100|
                          DCD      ||.bss||+0x1820
                  |L25.104|
                          DCD      0x4000b000
                  |L25.108|
                          DCD      ||.data||

                          AREA ||i.EMAC_UpdateTime||, CODE, READONLY, ALIGN=2

                  EMAC_UpdateTime PROC
;;;903      */
;;;904    void EMAC_UpdateTime(uint32_t u32Neg, uint32_t u32Sec, uint32_t u32Nsec)
000000  b570              PUSH     {r4-r6,lr}
;;;905    {
;;;906        EMAC->UPDSEC = u32Sec;
000002  4c0b              LDR      r4,|L26.48|
000004  4605              MOV      r5,r0                 ;905
000006  f8c41120          STR      r1,[r4,#0x120]
;;;907        EMAC->UPDSUBSEC = EMAC_Nsec2Subsec(u32Nsec);
00000a  4610              MOV      r0,r2
00000c  f7fffffe          BL       EMAC_Nsec2Subsec
000010  f8c40124          STR      r0,[r4,#0x124]
;;;908        if(u32Neg)
000014  b12d              CBZ      r5,|L26.34|
;;;909        {
;;;910            EMAC->UPDSUBSEC |= BIT31;   /* Set bit 31 indicates this is a negative value */
000016  f8d40124          LDR      r0,[r4,#0x124]
00001a  f0404000          ORR      r0,r0,#0x80000000
00001e  f8c40124          STR      r0,[r4,#0x124]
                  |L26.34|
;;;911        }
;;;912        EMAC->TSCTL |= EMAC_TSCTL_TSUPDATE_Msk;
000022  f8d40100          LDR      r0,[r4,#0x100]
000026  f0400008          ORR      r0,r0,#8
00002a  f8c40100          STR      r0,[r4,#0x100]
;;;913    
;;;914    }
00002e  bd70              POP      {r4-r6,pc}
;;;915    
                          ENDP

                  |L26.48|
                          DCD      0x4000b000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  rx_desc
                          %        96
                  rx_buf
                          %        6080
                  tx_desc
                          %        96
                  tx_buf
                          %        6080

                          AREA ||.data||, DATA, ALIGN=2

                  s_u32EnableTs
                          DCD      0x00000000
                  u32CurrentTxDesc
                          DCD      0x00000000
                  u32NextTxDesc
                          DCD      0x00000000
                  u32CurrentRxDesc
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\emac.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_emac_c_34612849____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_emac_c_34612849____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_emac_c_34612849____REVSH|
#line 402
|__asm___6_emac_c_34612849____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_emac_c_34612849____RRX|
#line 587
|__asm___6_emac_c_34612849____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
