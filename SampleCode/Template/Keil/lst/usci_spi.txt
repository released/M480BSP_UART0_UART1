; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usci_spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\usci_spi.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -D__FPU_PRESENT=1 --omf_browse=.\obj\usci_spi.crf ..\..\..\Library\StdDriver\src\usci_spi.c]
                          THUMB

                          AREA ||i.USPI_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  USPI_ClearIntFlag PROC
;;;502      */
;;;503    void USPI_ClearIntFlag(USPI_T *uspi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;504    {
000002  d002              BEQ      |L1.10|
;;;505        /* Clear slave selection signal inactive interrupt flag */
;;;506        if((u32Mask & USPI_SSINACT_INT_MASK)==USPI_SSINACT_INT_MASK)
;;;507        {
;;;508            uspi->PROTSTS = USPI_PROTSTS_SSINAIF_Msk;
000004  f44f7280          MOV      r2,#0x100
000008  6642              STR      r2,[r0,#0x64]
                  |L1.10|
;;;509        }
;;;510        else {}
;;;511        /* Clear slave selection signal active interrupt flag */
;;;512        if((u32Mask & USPI_SSACT_INT_MASK)==USPI_SSACT_INT_MASK)
00000a  078a              LSLS     r2,r1,#30
00000c  d502              BPL      |L1.20|
;;;513        {
;;;514            uspi->PROTSTS = USPI_PROTSTS_SSACTIF_Msk;
00000e  f44f7200          MOV      r2,#0x200
000012  6642              STR      r2,[r0,#0x64]
                  |L1.20|
;;;515        }
;;;516        else {}
;;;517        /* Clear slave time-out interrupt flag */
;;;518        if((u32Mask & USPI_SLVTO_INT_MASK)==USPI_SLVTO_INT_MASK)
000014  074a              LSLS     r2,r1,#29
000016  d501              BPL      |L1.28|
;;;519        {
;;;520            uspi->PROTSTS = USPI_PROTSTS_SLVTOIF_Msk;
000018  2220              MOVS     r2,#0x20
00001a  6642              STR      r2,[r0,#0x64]
                  |L1.28|
;;;521        }
;;;522        else {}
;;;523        /* Clear slave bit count error interrupt flag */
;;;524        if((u32Mask & USPI_SLVBE_INT_MASK)==USPI_SLVBE_INT_MASK)
00001c  070a              LSLS     r2,r1,#28
00001e  d501              BPL      |L1.36|
;;;525        {
;;;526            uspi->PROTSTS = USPI_PROTSTS_SLVBEIF_Msk;
000020  2240              MOVS     r2,#0x40
000022  6642              STR      r2,[r0,#0x64]
                  |L1.36|
;;;527        }
;;;528        else {}
;;;529        /* Clear TX under run interrupt flag */
;;;530        if((u32Mask & USPI_TXUDR_INT_MASK)==USPI_TXUDR_INT_MASK)
000024  06ca              LSLS     r2,r1,#27
000026  d502              BPL      |L1.46|
;;;531        {
;;;532            uspi->BUFSTS = USPI_BUFSTS_TXUDRIF_Msk;
000028  f44f6200          MOV      r2,#0x800
00002c  63c2              STR      r2,[r0,#0x3c]
                  |L1.46|
;;;533        }
;;;534        else {}
;;;535        /* Clear RX overrun interrupt flag */
;;;536        if((u32Mask & USPI_RXOV_INT_MASK)==USPI_RXOV_INT_MASK)
00002e  068b              LSLS     r3,r1,#26
;;;537        {
;;;538            uspi->BUFSTS = USPI_BUFSTS_RXOVIF_Msk;
000030  f04f0208          MOV      r2,#8
000034  d500              BPL      |L1.56|
000036  63c2              STR      r2,[r0,#0x3c]
                  |L1.56|
;;;539        }
;;;540        else {}
;;;541        /* Clear TX start interrupt flag */
;;;542        if((u32Mask & USPI_TXST_INT_MASK)==USPI_TXST_INT_MASK)
000038  064b              LSLS     r3,r1,#25
00003a  d501              BPL      |L1.64|
;;;543        {
;;;544            uspi->PROTSTS = USPI_PROTSTS_TXSTIF_Msk;
00003c  2302              MOVS     r3,#2
00003e  6643              STR      r3,[r0,#0x64]
                  |L1.64|
;;;545        }
;;;546        else {}
;;;547        /* Clear TX end interrupt flag */
;;;548        if((u32Mask & USPI_TXEND_INT_MASK)==USPI_TXEND_INT_MASK)
000040  060b              LSLS     r3,r1,#24
000042  d501              BPL      |L1.72|
;;;549        {
;;;550            uspi->PROTSTS = USPI_PROTSTS_TXENDIF_Msk;
000044  2304              MOVS     r3,#4
000046  6643              STR      r3,[r0,#0x64]
                  |L1.72|
;;;551        }
;;;552        else {}
;;;553        /* Clear RX start interrupt flag */
;;;554        if((u32Mask & USPI_RXST_INT_MASK)==USPI_RXST_INT_MASK)
000048  05cb              LSLS     r3,r1,#23
00004a  d500              BPL      |L1.78|
;;;555        {
;;;556            uspi->PROTSTS = USPI_PROTSTS_RXSTIF_Msk;
00004c  6642              STR      r2,[r0,#0x64]
                  |L1.78|
;;;557        }
;;;558        else {}
;;;559    
;;;560        /* Clear RX end interrupt flag */
;;;561        if((u32Mask & USPI_RXEND_INT_MASK)==USPI_RXEND_INT_MASK)
00004e  0589              LSLS     r1,r1,#22
000050  d501              BPL      |L1.86|
;;;562        {
;;;563            uspi->PROTSTS = USPI_PROTSTS_RXENDIF_Msk;
000052  2110              MOVS     r1,#0x10
000054  6641              STR      r1,[r0,#0x64]
                  |L1.86|
;;;564        }
;;;565        else {}
;;;566    }
000056  4770              BX       lr
;;;567    
                          ENDP


                          AREA ||i.USPI_ClearRxBuf||, CODE, READONLY, ALIGN=1

                  USPI_ClearRxBuf PROC
;;;121      */
;;;122    void USPI_ClearRxBuf(USPI_T *uspi)
000000  6b81              LDR      r1,[r0,#0x38]
;;;123    {
;;;124        uspi->BUFCTL |= USPI_BUFCTL_RXCLR_Msk;
000002  f4414100          ORR      r1,r1,#0x8000
000006  6381              STR      r1,[r0,#0x38]
;;;125    }
000008  4770              BX       lr
;;;126    
                          ENDP


                          AREA ||i.USPI_ClearTxBuf||, CODE, READONLY, ALIGN=1

                  USPI_ClearTxBuf PROC
;;;131      */
;;;132    void USPI_ClearTxBuf(USPI_T *uspi)
000000  6b81              LDR      r1,[r0,#0x38]
;;;133    {
;;;134        uspi->BUFCTL |= USPI_BUFCTL_TXCLR_Msk;
000002  f0410180          ORR      r1,r1,#0x80
000006  6381              STR      r1,[r0,#0x38]
;;;135    }
000008  4770              BX       lr
;;;136    
                          ENDP


                          AREA ||i.USPI_Close||, CODE, READONLY, ALIGN=1

                  USPI_Close PROC
;;;111      */
;;;112    void USPI_Close(USPI_T *uspi)
000000  6801              LDR      r1,[r0,#0]
;;;113    {
;;;114        uspi->CTL &= ~USPI_CTL_FUNMODE_Msk;
000002  f0210107          BIC      r1,r1,#7
000006  6001              STR      r1,[r0,#0]
;;;115    }
000008  4770              BX       lr
;;;116    
                          ENDP


                          AREA ||i.USPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  USPI_DisableAutoSS PROC
;;;141      */
;;;142    void USPI_DisableAutoSS(USPI_T *uspi)
000000  6dc1              LDR      r1,[r0,#0x5c]
;;;143    {
;;;144        uspi->PROTCTL &= ~(USPI_PROTCTL_AUTOSS_Msk | USPI_PROTCTL_SS_Msk);
000002  f021010c          BIC      r1,r1,#0xc
000006  65c1              STR      r1,[r0,#0x5c]
;;;145    }
000008  4770              BX       lr
;;;146    
                          ENDP


                          AREA ||i.USPI_DisableInt||, CODE, READONLY, ALIGN=1

                  USPI_DisableInt PROC
;;;315      */
;;;316    void USPI_DisableInt(USPI_T *uspi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;317    {
000002  d003              BEQ      |L6.12|
;;;318        /* Disable slave selection signal inactive interrupt flag */
;;;319        if((u32Mask & USPI_SSINACT_INT_MASK) == USPI_SSINACT_INT_MASK)
;;;320        {
;;;321            uspi->PROTIEN &= ~USPI_PROTIEN_SSINAIEN_Msk;
000004  6e02              LDR      r2,[r0,#0x60]
000006  f0220201          BIC      r2,r2,#1
00000a  6602              STR      r2,[r0,#0x60]
                  |L6.12|
;;;322        }
;;;323        else {}
;;;324        /* Disable slave selection signal active interrupt flag */
;;;325        if((u32Mask & USPI_SSACT_INT_MASK) == USPI_SSACT_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L6.24|
;;;326        {
;;;327            uspi->PROTIEN &= ~USPI_PROTIEN_SSACTIEN_Msk;
000010  6e02              LDR      r2,[r0,#0x60]
000012  f0220202          BIC      r2,r2,#2
000016  6602              STR      r2,[r0,#0x60]
                  |L6.24|
;;;328        }
;;;329        else {}
;;;330        /* Disable slave time-out interrupt flag */
;;;331        if((u32Mask & USPI_SLVTO_INT_MASK) == USPI_SLVTO_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L6.36|
;;;332        {
;;;333            uspi->PROTIEN &= ~USPI_PROTIEN_SLVTOIEN_Msk;
00001c  6e02              LDR      r2,[r0,#0x60]
00001e  f0220204          BIC      r2,r2,#4
000022  6602              STR      r2,[r0,#0x60]
                  |L6.36|
;;;334        }
;;;335        else {}
;;;336        /* Disable slave bit count error interrupt flag */
;;;337        if((u32Mask & USPI_SLVBE_INT_MASK) == USPI_SLVBE_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L6.48|
;;;338        {
;;;339            uspi->PROTIEN &= ~USPI_PROTIEN_SLVBEIEN_Msk;
000028  6e02              LDR      r2,[r0,#0x60]
00002a  f0220208          BIC      r2,r2,#8
00002e  6602              STR      r2,[r0,#0x60]
                  |L6.48|
;;;340        }
;;;341        else {}
;;;342        /* Disable TX under run interrupt flag */
;;;343        if((u32Mask & USPI_TXUDR_INT_MASK) == USPI_TXUDR_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L6.60|
;;;344        {
;;;345            uspi->BUFCTL &= ~USPI_BUFCTL_TXUDRIEN_Msk;
000034  6b82              LDR      r2,[r0,#0x38]
000036  f0220240          BIC      r2,r2,#0x40
00003a  6382              STR      r2,[r0,#0x38]
                  |L6.60|
;;;346        }
;;;347        else {}
;;;348        /* Disable RX overrun interrupt flag */
;;;349        if((u32Mask & USPI_RXOV_INT_MASK) == USPI_RXOV_INT_MASK)
00003c  068a              LSLS     r2,r1,#26
00003e  d503              BPL      |L6.72|
;;;350        {
;;;351            uspi->BUFCTL &= ~USPI_BUFCTL_RXOVIEN_Msk;
000040  6b82              LDR      r2,[r0,#0x38]
000042  f4224280          BIC      r2,r2,#0x4000
000046  6382              STR      r2,[r0,#0x38]
                  |L6.72|
;;;352        }
;;;353        else {}
;;;354        /* Disable TX start interrupt flag */
;;;355        if((u32Mask & USPI_TXST_INT_MASK) == USPI_TXST_INT_MASK)
000048  064a              LSLS     r2,r1,#25
00004a  d503              BPL      |L6.84|
;;;356        {
;;;357            uspi->INTEN &= ~USPI_INTEN_TXSTIEN_Msk;
00004c  6842              LDR      r2,[r0,#4]
00004e  f0220202          BIC      r2,r2,#2
000052  6042              STR      r2,[r0,#4]
                  |L6.84|
;;;358        }
;;;359        else {}
;;;360        /* Disable TX end interrupt flag */
;;;361        if((u32Mask & USPI_TXEND_INT_MASK) == USPI_TXEND_INT_MASK)
000054  060a              LSLS     r2,r1,#24
000056  d503              BPL      |L6.96|
;;;362        {
;;;363            uspi->INTEN &= ~USPI_INTEN_TXENDIEN_Msk;
000058  6842              LDR      r2,[r0,#4]
00005a  f0220204          BIC      r2,r2,#4
00005e  6042              STR      r2,[r0,#4]
                  |L6.96|
;;;364        }
;;;365        else {}
;;;366        /* Disable RX start interrupt flag */
;;;367        if((u32Mask & USPI_RXST_INT_MASK) == USPI_RXST_INT_MASK)
000060  05ca              LSLS     r2,r1,#23
000062  d503              BPL      |L6.108|
;;;368        {
;;;369            uspi->INTEN &= ~USPI_INTEN_RXSTIEN_Msk;
000064  6842              LDR      r2,[r0,#4]
000066  f0220208          BIC      r2,r2,#8
00006a  6042              STR      r2,[r0,#4]
                  |L6.108|
;;;370        }
;;;371        else {}
;;;372        /* Disable RX end interrupt flag */
;;;373        if((u32Mask & USPI_RXEND_INT_MASK) == USPI_RXEND_INT_MASK)
00006c  0589              LSLS     r1,r1,#22
00006e  d503              BPL      |L6.120|
;;;374        {
;;;375            uspi->INTEN &= ~USPI_INTEN_RXENDIEN_Msk;
000070  6841              LDR      r1,[r0,#4]
000072  f0210110          BIC      r1,r1,#0x10
000076  6041              STR      r1,[r0,#4]
                  |L6.120|
;;;376        }
;;;377        else {}
;;;378    }
000078  4770              BX       lr
;;;379    
                          ENDP


                          AREA ||i.USPI_DisableWakeup||, CODE, READONLY, ALIGN=1

                  USPI_DisableWakeup PROC
;;;651      */
;;;652    void USPI_DisableWakeup(USPI_T *uspi)
000000  6d41              LDR      r1,[r0,#0x54]
;;;653    {
;;;654        uspi->WKCTL &= ~USPI_WKCTL_WKEN_Msk;
000002  f0210101          BIC      r1,r1,#1
000006  6541              STR      r1,[r0,#0x54]
;;;655    }
000008  4770              BX       lr
;;;656    
                          ENDP


                          AREA ||i.USPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  USPI_EnableAutoSS PROC
;;;155      */
;;;156    void USPI_EnableAutoSS(USPI_T *uspi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  6ac1              LDR      r1,[r0,#0x2c]
;;;157    {
;;;158        uspi->LINECTL = (uspi->LINECTL & ~USPI_LINECTL_CTLOINV_Msk) | u32ActiveLevel;
000002  f0210180          BIC      r1,r1,#0x80
000006  4311              ORRS     r1,r1,r2
000008  62c1              STR      r1,[r0,#0x2c]
;;;159        uspi->PROTCTL |= USPI_PROTCTL_AUTOSS_Msk;
00000a  6dc1              LDR      r1,[r0,#0x5c]
00000c  f0410108          ORR      r1,r1,#8
000010  65c1              STR      r1,[r0,#0x5c]
;;;160    }
000012  4770              BX       lr
;;;161    
                          ENDP


                          AREA ||i.USPI_EnableInt||, CODE, READONLY, ALIGN=1

                  USPI_EnableInt PROC
;;;232      */
;;;233    void USPI_EnableInt(USPI_T *uspi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;234    {
000002  d003              BEQ      |L9.12|
;;;235        /* Enable slave selection signal inactive interrupt flag */
;;;236        if((u32Mask & USPI_SSINACT_INT_MASK) == USPI_SSINACT_INT_MASK)
;;;237        {
;;;238            uspi->PROTIEN |= USPI_PROTIEN_SSINAIEN_Msk;
000004  6e02              LDR      r2,[r0,#0x60]
000006  f0420201          ORR      r2,r2,#1
00000a  6602              STR      r2,[r0,#0x60]
                  |L9.12|
;;;239        }
;;;240        else {}
;;;241        /* Enable slave selection signal active interrupt flag */
;;;242        if((u32Mask & USPI_SSACT_INT_MASK) == USPI_SSACT_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L9.24|
;;;243        {
;;;244            uspi->PROTIEN |= USPI_PROTIEN_SSACTIEN_Msk;
000010  6e02              LDR      r2,[r0,#0x60]
000012  f0420202          ORR      r2,r2,#2
000016  6602              STR      r2,[r0,#0x60]
                  |L9.24|
;;;245        }
;;;246        else {}
;;;247        /* Enable slave time-out interrupt flag */
;;;248        if((u32Mask & USPI_SLVTO_INT_MASK) == USPI_SLVTO_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L9.36|
;;;249        {
;;;250            uspi->PROTIEN |= USPI_PROTIEN_SLVTOIEN_Msk;
00001c  6e02              LDR      r2,[r0,#0x60]
00001e  f0420204          ORR      r2,r2,#4
000022  6602              STR      r2,[r0,#0x60]
                  |L9.36|
;;;251        }
;;;252        else {}
;;;253    
;;;254        /* Enable slave bit count error interrupt flag */
;;;255        if((u32Mask & USPI_SLVBE_INT_MASK) == USPI_SLVBE_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L9.48|
;;;256        {
;;;257            uspi->PROTIEN |= USPI_PROTIEN_SLVBEIEN_Msk;
000028  6e02              LDR      r2,[r0,#0x60]
00002a  f0420208          ORR      r2,r2,#8
00002e  6602              STR      r2,[r0,#0x60]
                  |L9.48|
;;;258        }
;;;259        else {}
;;;260        /* Enable TX under run interrupt flag */
;;;261        if((u32Mask & USPI_TXUDR_INT_MASK) == USPI_TXUDR_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L9.60|
;;;262        {
;;;263            uspi->BUFCTL |= USPI_BUFCTL_TXUDRIEN_Msk;
000034  6b82              LDR      r2,[r0,#0x38]
000036  f0420240          ORR      r2,r2,#0x40
00003a  6382              STR      r2,[r0,#0x38]
                  |L9.60|
;;;264        }
;;;265        else {}
;;;266        /* Enable RX overrun interrupt flag */
;;;267        if((u32Mask & USPI_RXOV_INT_MASK) == USPI_RXOV_INT_MASK)
00003c  068a              LSLS     r2,r1,#26
00003e  d503              BPL      |L9.72|
;;;268        {
;;;269            uspi->BUFCTL |= USPI_BUFCTL_RXOVIEN_Msk;
000040  6b82              LDR      r2,[r0,#0x38]
000042  f4424280          ORR      r2,r2,#0x4000
000046  6382              STR      r2,[r0,#0x38]
                  |L9.72|
;;;270        }
;;;271        else {}
;;;272        /* Enable TX start interrupt flag */
;;;273        if((u32Mask & USPI_TXST_INT_MASK) == USPI_TXST_INT_MASK)
000048  064a              LSLS     r2,r1,#25
00004a  d503              BPL      |L9.84|
;;;274        {
;;;275            uspi->INTEN |= USPI_INTEN_TXSTIEN_Msk;
00004c  6842              LDR      r2,[r0,#4]
00004e  f0420202          ORR      r2,r2,#2
000052  6042              STR      r2,[r0,#4]
                  |L9.84|
;;;276        }
;;;277        else {}
;;;278        /* Enable TX end interrupt flag */
;;;279        if((u32Mask & USPI_TXEND_INT_MASK) == USPI_TXEND_INT_MASK)
000054  060a              LSLS     r2,r1,#24
000056  d503              BPL      |L9.96|
;;;280        {
;;;281            uspi->INTEN |= USPI_INTEN_TXENDIEN_Msk;
000058  6842              LDR      r2,[r0,#4]
00005a  f0420204          ORR      r2,r2,#4
00005e  6042              STR      r2,[r0,#4]
                  |L9.96|
;;;282        }
;;;283        else {}
;;;284        /* Enable RX start interrupt flag */
;;;285        if((u32Mask & USPI_RXST_INT_MASK) == USPI_RXST_INT_MASK)
000060  05ca              LSLS     r2,r1,#23
000062  d503              BPL      |L9.108|
;;;286        {
;;;287            uspi->INTEN |= USPI_INTEN_RXSTIEN_Msk;
000064  6842              LDR      r2,[r0,#4]
000066  f0420208          ORR      r2,r2,#8
00006a  6042              STR      r2,[r0,#4]
                  |L9.108|
;;;288        }
;;;289        else {}
;;;290        /* Enable RX end interrupt flag */
;;;291        if((u32Mask & USPI_RXEND_INT_MASK) == USPI_RXEND_INT_MASK)
00006c  0589              LSLS     r1,r1,#22
00006e  d503              BPL      |L9.120|
;;;292        {
;;;293            uspi->INTEN |= USPI_INTEN_RXENDIEN_Msk;
000070  6841              LDR      r1,[r0,#4]
000072  f0410110          ORR      r1,r1,#0x10
000076  6041              STR      r1,[r0,#4]
                  |L9.120|
;;;294        }
;;;295        else {}
;;;296    }
000078  4770              BX       lr
;;;297    
                          ENDP


                          AREA ||i.USPI_EnableWakeup||, CODE, READONLY, ALIGN=1

                  USPI_EnableWakeup PROC
;;;641      */
;;;642    void USPI_EnableWakeup(USPI_T *uspi)
000000  6d41              LDR      r1,[r0,#0x54]
;;;643    {
;;;644        uspi->WKCTL |= USPI_WKCTL_WKEN_Msk;
000002  f0410101          ORR      r1,r1,#1
000006  6541              STR      r1,[r0,#0x54]
;;;645    }
000008  4770              BX       lr
;;;646    
                          ENDP


                          AREA ||i.USPI_GetBusClock||, CODE, READONLY, ALIGN=2

                  USPI_GetBusClock PROC
;;;195      */
;;;196    uint32_t USPI_GetBusClock(USPI_T *uspi)
000000  b510              PUSH     {r4,lr}
;;;197    {
;;;198        uint32_t u32BusClk;
;;;199        uint32_t u32ClkDiv;
;;;200    
;;;201        u32ClkDiv = (uspi->BRGEN & USPI_BRGEN_CLKDIV_Msk) >> USPI_BRGEN_CLKDIV_Pos;
000002  6881              LDR      r1,[r0,#8]
000004  f3c14409          UBFX     r4,r1,#16,#10
;;;202    
;;;203        if(uspi == USPI0)
000008  4906              LDR      r1,|L11.36|
00000a  4288              CMP      r0,r1
00000c  d102              BNE      |L11.20|
;;;204        {
;;;205            u32BusClk = (uint32_t)( CLK_GetPCLK0Freq() / ((u32ClkDiv+1ul)<<1) );
00000e  f7fffffe          BL       CLK_GetPCLK0Freq
000012  e001              B        |L11.24|
                  |L11.20|
;;;206        }
;;;207        else
;;;208        {
;;;209            u32BusClk = (uint32_t)( CLK_GetPCLK1Freq() / ((u32ClkDiv+1ul)<<1) );
000014  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L11.24|
000018  0061              LSLS     r1,r4,#1              ;205
00001a  1c89              ADDS     r1,r1,#2              ;205
00001c  fbb0f0f1          UDIV     r0,r0,r1              ;205
;;;210        }
;;;211    
;;;212        return u32BusClk;
;;;213    }
000020  bd10              POP      {r4,pc}
;;;214    
                          ENDP

000022  0000              DCW      0x0000
                  |L11.36|
                          DCD      0x400d0000

                          AREA ||i.USPI_GetIntFlag||, CODE, READONLY, ALIGN=1

                  USPI_GetIntFlag PROC
;;;397      */
;;;398    uint32_t USPI_GetIntFlag(USPI_T *uspi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;399    {
000002  4602              MOV      r2,r0
;;;400        uint32_t u32TmpFlag;
;;;401        uint32_t u32IntFlag = 0ul;
000004  2000              MOVS     r0,#0
;;;402    
;;;403        /* Check slave selection signal inactive interrupt flag */
;;;404        u32TmpFlag = uspi->PROTSTS & USPI_PROTSTS_SSINAIF_Msk;
000006  6e53              LDR      r3,[r2,#0x64]
;;;405        if(((u32Mask & USPI_SSINACT_INT_MASK)==USPI_SSINACT_INT_MASK)  && (u32TmpFlag==USPI_PROTSTS_SSINAIF_Msk) )
000008  07cc              LSLS     r4,r1,#31
00000a  f4037380          AND      r3,r3,#0x100          ;404
00000e  d003              BEQ      |L12.24|
000010  f5b37f80          CMP      r3,#0x100
000014  d100              BNE      |L12.24|
;;;406        {
;;;407            u32IntFlag |= USPI_SSINACT_INT_MASK;
000016  2001              MOVS     r0,#1
                  |L12.24|
;;;408        }
;;;409        else {}
;;;410        /* Check slave selection signal active interrupt flag */
;;;411    
;;;412        u32TmpFlag = uspi->PROTSTS & USPI_PROTSTS_SSACTIF_Msk;
000018  6e53              LDR      r3,[r2,#0x64]
;;;413        if(((u32Mask & USPI_SSACT_INT_MASK)==USPI_SSACT_INT_MASK) && (u32TmpFlag == USPI_PROTSTS_SSACTIF_Msk))
00001a  078c              LSLS     r4,r1,#30
00001c  f4037300          AND      r3,r3,#0x200          ;412
000020  d504              BPL      |L12.44|
000022  f5b37f00          CMP      r3,#0x200
000026  d101              BNE      |L12.44|
;;;414        {
;;;415            u32IntFlag |= USPI_SSACT_INT_MASK;
000028  f0400002          ORR      r0,r0,#2
                  |L12.44|
;;;416        }
;;;417        else {}
;;;418    
;;;419        /* Check slave time-out interrupt flag */
;;;420        u32TmpFlag = uspi->PROTSTS & USPI_PROTSTS_SLVTOIF_Msk;
00002c  6e53              LDR      r3,[r2,#0x64]
;;;421        if(((u32Mask & USPI_SLVTO_INT_MASK)==USPI_SLVTO_INT_MASK) && (u32TmpFlag == USPI_PROTSTS_SLVTOIF_Msk))
00002e  074c              LSLS     r4,r1,#29
000030  f0030320          AND      r3,r3,#0x20           ;420
000034  d503              BPL      |L12.62|
000036  2b20              CMP      r3,#0x20
000038  d101              BNE      |L12.62|
;;;422        {
;;;423            u32IntFlag |= USPI_SLVTO_INT_MASK;
00003a  f0400004          ORR      r0,r0,#4
                  |L12.62|
;;;424        }
;;;425        else {}
;;;426    
;;;427        /* Check slave bit count error interrupt flag */
;;;428        u32TmpFlag = uspi->PROTSTS & USPI_PROTSTS_SLVBEIF_Msk;
00003e  6e53              LDR      r3,[r2,#0x64]
;;;429        if(((u32Mask & USPI_SLVBE_INT_MASK)==USPI_SLVBE_INT_MASK) && (u32TmpFlag == USPI_PROTSTS_SLVBEIF_Msk))
000040  070c              LSLS     r4,r1,#28
000042  f0030340          AND      r3,r3,#0x40           ;428
000046  d503              BPL      |L12.80|
000048  2b40              CMP      r3,#0x40
00004a  d101              BNE      |L12.80|
;;;430        {
;;;431            u32IntFlag |= USPI_SLVBE_INT_MASK;
00004c  f0400008          ORR      r0,r0,#8
                  |L12.80|
;;;432        }
;;;433        else {}
;;;434    
;;;435        /* Check TX under run interrupt flag */
;;;436        u32TmpFlag = uspi->BUFSTS & USPI_BUFSTS_TXUDRIF_Msk;
000050  6bd3              LDR      r3,[r2,#0x3c]
;;;437        if(((u32Mask & USPI_TXUDR_INT_MASK)==USPI_TXUDR_INT_MASK) && (u32TmpFlag == USPI_BUFSTS_TXUDRIF_Msk))
000052  06cc              LSLS     r4,r1,#27
000054  f4036300          AND      r3,r3,#0x800          ;436
000058  d504              BPL      |L12.100|
00005a  f5b36f00          CMP      r3,#0x800
00005e  d101              BNE      |L12.100|
;;;438        {
;;;439            u32IntFlag |= USPI_TXUDR_INT_MASK;
000060  f0400010          ORR      r0,r0,#0x10
                  |L12.100|
;;;440        }
;;;441        else {}
;;;442    
;;;443        /* Check RX overrun interrupt flag */
;;;444        u32TmpFlag = uspi->BUFSTS & USPI_BUFSTS_RXOVIF_Msk;
000064  6bd3              LDR      r3,[r2,#0x3c]
;;;445        if(((u32Mask & USPI_RXOV_INT_MASK)==USPI_RXOV_INT_MASK) && (u32TmpFlag == USPI_BUFSTS_RXOVIF_Msk))
000066  068c              LSLS     r4,r1,#26
000068  f0030308          AND      r3,r3,#8              ;444
00006c  d503              BPL      |L12.118|
00006e  2b08              CMP      r3,#8
000070  d101              BNE      |L12.118|
;;;446        {
;;;447            u32IntFlag |= USPI_RXOV_INT_MASK;
000072  f0400020          ORR      r0,r0,#0x20
                  |L12.118|
;;;448        }
;;;449        else {}
;;;450    
;;;451        /* Check TX start interrupt flag */
;;;452        u32TmpFlag = uspi->PROTSTS & USPI_PROTSTS_TXSTIF_Msk;
000076  6e53              LDR      r3,[r2,#0x64]
;;;453        if(((u32Mask & USPI_TXST_INT_MASK)==USPI_TXST_INT_MASK) && (u32TmpFlag == USPI_PROTSTS_TXSTIF_Msk))
000078  064c              LSLS     r4,r1,#25
00007a  f0030302          AND      r3,r3,#2              ;452
00007e  d503              BPL      |L12.136|
000080  2b02              CMP      r3,#2
000082  d101              BNE      |L12.136|
;;;454        {
;;;455            u32IntFlag |= USPI_TXST_INT_MASK;
000084  f0400040          ORR      r0,r0,#0x40
                  |L12.136|
;;;456        }
;;;457        else {}
;;;458    
;;;459        /* Check TX end interrupt flag */
;;;460        u32TmpFlag = uspi->PROTSTS & USPI_PROTSTS_TXENDIF_Msk;
000088  6e53              LDR      r3,[r2,#0x64]
;;;461        if(((u32Mask & USPI_TXEND_INT_MASK)==USPI_TXEND_INT_MASK) && (u32TmpFlag == USPI_PROTSTS_TXENDIF_Msk))
00008a  060c              LSLS     r4,r1,#24
00008c  f0030304          AND      r3,r3,#4              ;460
000090  d503              BPL      |L12.154|
000092  2b04              CMP      r3,#4
000094  d101              BNE      |L12.154|
;;;462        {
;;;463            u32IntFlag |= USPI_TXEND_INT_MASK;
000096  f0400080          ORR      r0,r0,#0x80
                  |L12.154|
;;;464        }
;;;465        else {}
;;;466    
;;;467        /* Check RX start interrupt flag */
;;;468        u32TmpFlag = uspi->PROTSTS & USPI_PROTSTS_RXSTIF_Msk;
00009a  6e53              LDR      r3,[r2,#0x64]
;;;469        if(((u32Mask & USPI_RXST_INT_MASK)==USPI_RXST_INT_MASK) && (u32TmpFlag == USPI_PROTSTS_RXSTIF_Msk))
00009c  05cc              LSLS     r4,r1,#23
00009e  f0030308          AND      r3,r3,#8              ;468
0000a2  d503              BPL      |L12.172|
0000a4  2b08              CMP      r3,#8
0000a6  d101              BNE      |L12.172|
;;;470        {
;;;471            u32IntFlag |= USPI_RXST_INT_MASK;
0000a8  f4407080          ORR      r0,r0,#0x100
                  |L12.172|
;;;472        }
;;;473        else {}
;;;474    
;;;475        /* Check RX end interrupt flag */
;;;476        u32TmpFlag = uspi->PROTSTS & USPI_PROTSTS_RXENDIF_Msk;
0000ac  6e52              LDR      r2,[r2,#0x64]
;;;477        if(((u32Mask & USPI_RXEND_INT_MASK)==USPI_RXEND_INT_MASK) && (u32TmpFlag == USPI_PROTSTS_RXENDIF_Msk))
0000ae  0589              LSLS     r1,r1,#22
0000b0  f0020210          AND      r2,r2,#0x10           ;476
0000b4  d503              BPL      |L12.190|
0000b6  2a10              CMP      r2,#0x10
0000b8  d101              BNE      |L12.190|
;;;478        {
;;;479            u32IntFlag |= USPI_RXEND_INT_MASK;
0000ba  f4407000          ORR      r0,r0,#0x200
                  |L12.190|
;;;480        }
;;;481        else {}
;;;482        return u32IntFlag;
;;;483    }
0000be  bd10              POP      {r4,pc}
;;;484    
                          ENDP


                          AREA ||i.USPI_GetStatus||, CODE, READONLY, ALIGN=1

                  USPI_GetStatus PROC
;;;581      */
;;;582    uint32_t USPI_GetStatus(USPI_T *uspi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;583    {
000002  4602              MOV      r2,r0
;;;584        uint32_t u32Flag = 0ul;
000004  2000              MOVS     r0,#0
;;;585        uint32_t u32TmpFlag;
;;;586    
;;;587        /* Check busy status */
;;;588        u32TmpFlag = uspi->PROTSTS & USPI_PROTSTS_BUSY_Msk;
000006  6e53              LDR      r3,[r2,#0x64]
;;;589        if(((u32Mask & USPI_BUSY_MASK)==USPI_BUSY_MASK) && (u32TmpFlag & USPI_PROTSTS_BUSY_Msk))
000008  07cc              LSLS     r4,r1,#31
00000a  f4033300          AND      r3,r3,#0x20000        ;588
00000e  d002              BEQ      |L13.22|
000010  039b              LSLS     r3,r3,#14
000012  d500              BPL      |L13.22|
;;;590        {
;;;591            u32Flag |= USPI_BUSY_MASK;
000014  2001              MOVS     r0,#1
                  |L13.22|
;;;592        }
;;;593        else {}
;;;594    
;;;595        /* Check RX empty flag */
;;;596        u32TmpFlag = uspi->BUFSTS & USPI_BUFSTS_RXEMPTY_Msk;
000016  6bd3              LDR      r3,[r2,#0x3c]
;;;597        if(((u32Mask & USPI_RX_EMPTY_MASK)==USPI_RX_EMPTY_MASK) && (u32TmpFlag == USPI_BUFSTS_RXEMPTY_Msk))
000018  078c              LSLS     r4,r1,#30
00001a  f0030301          AND      r3,r3,#1              ;596
00001e  d502              BPL      |L13.38|
000020  b10b              CBZ      r3,|L13.38|
;;;598        {
;;;599            u32Flag |= USPI_RX_EMPTY_MASK;
000022  f0400002          ORR      r0,r0,#2
                  |L13.38|
;;;600        }
;;;601        else {}
;;;602    
;;;603        /* Check RX full flag */
;;;604        u32TmpFlag = uspi->BUFSTS & USPI_BUFSTS_RXFULL_Msk;
000026  6bd3              LDR      r3,[r2,#0x3c]
;;;605        if(((u32Mask & USPI_RX_FULL_MASK)==USPI_RX_FULL_MASK) && (u32TmpFlag == USPI_BUFSTS_RXFULL_Msk))
000028  074c              LSLS     r4,r1,#29
00002a  f0030302          AND      r3,r3,#2              ;604
00002e  d503              BPL      |L13.56|
000030  2b02              CMP      r3,#2
000032  d101              BNE      |L13.56|
;;;606        {
;;;607            u32Flag |= USPI_RX_FULL_MASK;
000034  f0400004          ORR      r0,r0,#4
                  |L13.56|
;;;608        }
;;;609        else {}
;;;610    
;;;611        /* Check TX empty flag */
;;;612        u32TmpFlag = uspi->BUFSTS & USPI_BUFSTS_TXEMPTY_Msk;
000038  6bd3              LDR      r3,[r2,#0x3c]
;;;613        if(((u32Mask & USPI_TX_EMPTY_MASK)==USPI_TX_EMPTY_MASK) && (u32TmpFlag == USPI_BUFSTS_TXEMPTY_Msk))
00003a  070c              LSLS     r4,r1,#28
00003c  f4037380          AND      r3,r3,#0x100          ;612
000040  d504              BPL      |L13.76|
000042  f5b37f80          CMP      r3,#0x100
000046  d101              BNE      |L13.76|
;;;614        {
;;;615            u32Flag |= USPI_TX_EMPTY_MASK;
000048  f0400008          ORR      r0,r0,#8
                  |L13.76|
;;;616        }
;;;617        else {}
;;;618    
;;;619        /* Check TX full flag */
;;;620        u32TmpFlag = uspi->BUFSTS & USPI_BUFSTS_TXFULL_Msk;
00004c  6bd3              LDR      r3,[r2,#0x3c]
;;;621        if(((u32Mask & USPI_TX_FULL_MASK)==USPI_TX_FULL_MASK) && (u32TmpFlag == USPI_BUFSTS_TXFULL_Msk))
00004e  06cc              LSLS     r4,r1,#27
000050  f4037300          AND      r3,r3,#0x200          ;620
000054  d504              BPL      |L13.96|
000056  f5b37f00          CMP      r3,#0x200
00005a  d101              BNE      |L13.96|
;;;622        {
;;;623            u32Flag |= USPI_TX_FULL_MASK;
00005c  f0400010          ORR      r0,r0,#0x10
                  |L13.96|
;;;624        }
;;;625        else {}
;;;626    
;;;627        /* Check USCI_SPI_SS line status */
;;;628        u32TmpFlag = uspi->PROTSTS & USPI_PROTSTS_SSLINE_Msk;
000060  6e52              LDR      r2,[r2,#0x64]
;;;629        if(((u32Mask & USPI_SSLINE_STS_MASK)==USPI_SSLINE_STS_MASK) && (u32TmpFlag & USPI_PROTSTS_SSLINE_Msk))
000062  0689              LSLS     r1,r1,#26
000064  f4023280          AND      r2,r2,#0x10000        ;628
000068  d503              BPL      |L13.114|
00006a  03d1              LSLS     r1,r2,#15
00006c  d501              BPL      |L13.114|
;;;630        {
;;;631            u32Flag |= USPI_SSLINE_STS_MASK;
00006e  f0400020          ORR      r0,r0,#0x20
                  |L13.114|
;;;632        }
;;;633        else {}
;;;634        return u32Flag;
;;;635    }
000072  bd10              POP      {r4,pc}
;;;636    
                          ENDP


                          AREA ||i.USPI_Open||, CODE, READONLY, ALIGN=2

                  USPI_Open PROC
;;;41       */
;;;42     uint32_t USPI_Open(USPI_T *uspi, uint32_t u32MasterSlave, uint32_t u32SPIMode,  uint32_t u32DataWidth, uint32_t u32BusClock)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;43     {
000004  4604              MOV      r4,r0
;;;44         uint32_t u32ClkDiv = 0ul;
000006  2500              MOVS     r5,#0
;;;45         uint32_t u32Pclk;
;;;46         uint32_t u32UspiClk = 0ul;
;;;47     
;;;48         if(uspi == (USPI_T *)USPI0)
000008  482b              LDR      r0,|L14.184|
00000a  9f08              LDR      r7,[sp,#0x20]
00000c  461e              MOV      r6,r3                 ;43
00000e  4692              MOV      r10,r2                ;43
000010  4688              MOV      r8,r1                 ;43
000012  46a9              MOV      r9,r5                 ;46
000014  4284              CMP      r4,r0
000016  d102              BNE      |L14.30|
;;;49         {
;;;50             u32Pclk = CLK_GetPCLK0Freq();
000018  f7fffffe          BL       CLK_GetPCLK0Freq
00001c  e001              B        |L14.34|
                  |L14.30|
;;;51         }
;;;52         else
;;;53         {
;;;54             u32Pclk = CLK_GetPCLK1Freq();
00001e  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L14.34|
;;;55         }
;;;56     
;;;57         if(u32BusClock != 0ul)
000022  b157              CBZ      r7,|L14.58|
;;;58         {
;;;59             u32ClkDiv = (uint32_t) ((((((u32Pclk/2ul)*10ul)/(u32BusClock))+5ul)/10ul)-1ul); /* Compute proper divider for USCI_SPI clock */
000024  0841              LSRS     r1,r0,#1
000026  eb010181          ADD      r1,r1,r1,LSL #2
00002a  0049              LSLS     r1,r1,#1
00002c  fbb1f1f7          UDIV     r1,r1,r7
000030  220a              MOVS     r2,#0xa
000032  1d49              ADDS     r1,r1,#5
000034  fbb1f5f2          UDIV     r5,r1,r2
000038  1e6d              SUBS     r5,r5,#1
                  |L14.58|
;;;60         }
;;;61         else {}
;;;62     
;;;63         /* Enable USCI_SPI protocol */
;;;64         uspi->CTL &= ~USPI_CTL_FUNMODE_Msk;
00003a  6821              LDR      r1,[r4,#0]
00003c  f0210107          BIC      r1,r1,#7
000040  6021              STR      r1,[r4,#0]
;;;65         uspi->CTL = 1ul << USPI_CTL_FUNMODE_Pos;
000042  2101              MOVS     r1,#1
000044  6021              STR      r1,[r4,#0]
;;;66     
;;;67         /* Data format configuration */
;;;68         if(u32DataWidth == 16ul)
000046  2e10              CMP      r6,#0x10
000048  d100              BNE      |L14.76|
;;;69         {
;;;70             u32DataWidth = 0ul;
00004a  2600              MOVS     r6,#0
                  |L14.76|
;;;71         }
;;;72         else {}
;;;73         uspi->LINECTL &= ~USPI_LINECTL_DWIDTH_Msk;
00004c  6ae1              LDR      r1,[r4,#0x2c]
00004e  f4216170          BIC      r1,r1,#0xf00
000052  62e1              STR      r1,[r4,#0x2c]
;;;74         uspi->LINECTL |= (u32DataWidth << USPI_LINECTL_DWIDTH_Pos);
000054  6ae1              LDR      r1,[r4,#0x2c]
000056  ea412106          ORR      r1,r1,r6,LSL #8
00005a  62e1              STR      r1,[r4,#0x2c]
;;;75     
;;;76         /* MSB data format */
;;;77         uspi->LINECTL &= ~USPI_LINECTL_LSB_Msk;
00005c  6ae1              LDR      r1,[r4,#0x2c]
00005e  f0210101          BIC      r1,r1,#1
000062  62e1              STR      r1,[r4,#0x2c]
;;;78     
;;;79         /* Set slave selection signal active low */
;;;80         if(u32MasterSlave == USPI_MASTER)
000064  f1b80f00          CMP      r8,#0
000068  d020              BEQ      |L14.172|
;;;81         {
;;;82             uspi->LINECTL |= USPI_LINECTL_CTLOINV_Msk;
;;;83         }
;;;84         else
;;;85         {
;;;86             uspi->CTLIN0 |= USPI_CTLIN0_ININV_Msk;
00006a  6a21              LDR      r1,[r4,#0x20]
00006c  f0410104          ORR      r1,r1,#4
000070  6221              STR      r1,[r4,#0x20]
                  |L14.114|
;;;87         }
;;;88     
;;;89         /* Set operating mode and transfer timing */
;;;90         uspi->PROTCTL &= ~(USPI_PROTCTL_SCLKMODE_Msk | USPI_PROTCTL_AUTOSS_Msk | USPI_PROTCTL_SLAVE_Msk);
000072  6de1              LDR      r1,[r4,#0x5c]
000074  f02101c9          BIC      r1,r1,#0xc9
000078  65e1              STR      r1,[r4,#0x5c]
;;;91         uspi->PROTCTL |= (u32MasterSlave | u32SPIMode);
00007a  6de2              LDR      r2,[r4,#0x5c]
00007c  ea48010a          ORR      r1,r8,r10
000080  430a              ORRS     r2,r2,r1
000082  65e2              STR      r2,[r4,#0x5c]
;;;92     
;;;93         /* Set USCI_SPI bus clock */
;;;94         uspi->BRGEN &= ~USPI_BRGEN_CLKDIV_Msk;
000084  68a1              LDR      r1,[r4,#8]
000086  4a0d              LDR      r2,|L14.188|
000088  4011              ANDS     r1,r1,r2
00008a  60a1              STR      r1,[r4,#8]
;;;95         uspi->BRGEN |=  (u32ClkDiv << USPI_BRGEN_CLKDIV_Pos);
00008c  68a1              LDR      r1,[r4,#8]
00008e  ea414105          ORR      r1,r1,r5,LSL #16
000092  60a1              STR      r1,[r4,#8]
;;;96         uspi->PROTCTL |=  USPI_PROTCTL_PROTEN_Msk;
000094  6de1              LDR      r1,[r4,#0x5c]
000096  f0414100          ORR      r1,r1,#0x80000000
00009a  65e1              STR      r1,[r4,#0x5c]
;;;97     
;;;98         if(u32BusClock != 0ul)
00009c  b11f              CBZ      r7,|L14.166|
;;;99         {
;;;100            u32UspiClk = (uint32_t)( u32Pclk / ((u32ClkDiv+1ul)<<1) );
00009e  0069              LSLS     r1,r5,#1
0000a0  1c89              ADDS     r1,r1,#2
0000a2  fbb0f9f1          UDIV     r9,r0,r1
                  |L14.166|
;;;101        }
;;;102        else {}
;;;103    
;;;104        return u32UspiClk;
0000a6  4648              MOV      r0,r9
;;;105    }
0000a8  e8bd87f0          POP      {r4-r10,pc}
                  |L14.172|
0000ac  6ae1              LDR      r1,[r4,#0x2c]         ;82
0000ae  f0410180          ORR      r1,r1,#0x80           ;82
0000b2  62e1              STR      r1,[r4,#0x2c]         ;82
0000b4  e7dd              B        |L14.114|
;;;106    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L14.184|
                          DCD      0x400d0000
                  |L14.188|
                          DCD      0xfc00ffff

                          AREA ||i.USPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  USPI_SetBusClock PROC
;;;167      */
;;;168    uint32_t USPI_SetBusClock(USPI_T *uspi, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;169    {
000002  4604              MOV      r4,r0
;;;170        uint32_t u32ClkDiv;
;;;171        uint32_t u32Pclk;
;;;172    
;;;173        if(uspi == USPI0)
000004  480f              LDR      r0,|L15.68|
000006  460d              MOV      r5,r1                 ;169
000008  4284              CMP      r4,r0
00000a  d102              BNE      |L15.18|
;;;174        {
;;;175            u32Pclk = CLK_GetPCLK0Freq();
00000c  f7fffffe          BL       CLK_GetPCLK0Freq
000010  e001              B        |L15.22|
                  |L15.18|
;;;176        }
;;;177        else
;;;178        {
;;;179            u32Pclk = CLK_GetPCLK1Freq();
000012  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L15.22|
;;;180        }
;;;181    
;;;182        u32ClkDiv = (uint32_t) ((((((u32Pclk/2ul)*10ul)/(u32BusClock))+5ul)/10ul)-1ul); /* Compute proper divider for USCI_SPI clock */
000016  0842              LSRS     r2,r0,#1
000018  eb020182          ADD      r1,r2,r2,LSL #2
00001c  0049              LSLS     r1,r1,#1
00001e  fbb1f1f5          UDIV     r1,r1,r5
000022  220a              MOVS     r2,#0xa
000024  1d49              ADDS     r1,r1,#5
000026  fbb1f1f2          UDIV     r1,r1,r2
;;;183    
;;;184        /* Set USCI_SPI bus clock */
;;;185        uspi->BRGEN &= ~USPI_BRGEN_CLKDIV_Msk;
00002a  68a3              LDR      r3,[r4,#8]
00002c  1e4a              SUBS     r2,r1,#1              ;182
00002e  4d06              LDR      r5,|L15.72|
000030  402b              ANDS     r3,r3,r5
000032  60a3              STR      r3,[r4,#8]
;;;186        uspi->BRGEN |=  (u32ClkDiv << USPI_BRGEN_CLKDIV_Pos);
000034  68a3              LDR      r3,[r4,#8]
000036  ea434202          ORR      r2,r3,r2,LSL #16
00003a  60a2              STR      r2,[r4,#8]
;;;187    
;;;188        return ( u32Pclk / ((u32ClkDiv+1ul)<<1) );
;;;189    }
00003c  0049              LSLS     r1,r1,#1
00003e  fbb0f0f1          UDIV     r0,r0,r1              ;188
000042  bd70              POP      {r4-r6,pc}
;;;190    
                          ENDP

                  |L15.68|
                          DCD      0x400d0000
                  |L15.72|
                          DCD      0xfc00ffff

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\usci_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usci_spi_c_91a2fd3d____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_usci_spi_c_91a2fd3d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usci_spi_c_91a2fd3d____REVSH|
#line 402
|__asm___10_usci_spi_c_91a2fd3d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_usci_spi_c_91a2fd3d____RRX|
#line 587
|__asm___10_usci_spi_c_91a2fd3d____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
