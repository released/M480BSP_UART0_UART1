; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\timer_pwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timer_pwm.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 -D__FPU_PRESENT=1 --omf_browse=.\obj\timer_pwm.crf ..\..\..\Library\StdDriver\src\timer_pwm.c]
                          THUMB

                          AREA ||i.TPWM_ClearFaultBrakeIntFlag||, CODE, READONLY, ALIGN=1

                  TPWM_ClearFaultBrakeIntFlag PROC
;;;324      */
;;;325    void TPWM_ClearFaultBrakeIntFlag(TIMER_T *timer, uint32_t u32IntSource)
000000  2203              MOVS     r2,#3
;;;326    {
;;;327        timer->PWMINTSTS1 = (0x3UL << u32IntSource);
000002  408a              LSLS     r2,r2,r1
000004  f8c0208c          STR      r2,[r0,#0x8c]
;;;328    }
000008  4770              BX       lr
;;;329    
                          ENDP


                          AREA ||i.TPWM_ConfigOutputFreqAndDuty||, CODE, READONLY, ALIGN=2

                  TPWM_ConfigOutputFreqAndDuty PROC
;;;53       */
;;;54     uint32_t TPWM_ConfigOutputFreqAndDuty(TIMER_T *timer, uint32_t u32Frequency, uint32_t u32DutyCycle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;55     {
000004  4604              MOV      r4,r0
;;;56         uint32_t u32PWMClockFreq, u32TargetFreq;
;;;57         uint32_t u32Prescaler = 0x1000UL, u32Period, u32CMP;
;;;58     
;;;59         if((timer == TIMER0) || (timer == TIMER1))
000006  481b              LDR      r0,|L2.116|
000008  4615              MOV      r5,r2                 ;55
00000a  460e              MOV      r6,r1                 ;55
00000c  f44f5780          MOV      r7,#0x1000            ;57
000010  4284              CMP      r4,r0
000012  d002              BEQ      |L2.26|
000014  4818              LDR      r0,|L2.120|
000016  4284              CMP      r4,r0
000018  d102              BNE      |L2.32|
                  |L2.26|
;;;60         {
;;;61             u32PWMClockFreq = CLK_GetPCLK0Freq();
00001a  f7fffffe          BL       CLK_GetPCLK0Freq
00001e  e001              B        |L2.36|
                  |L2.32|
;;;62         }
;;;63         else
;;;64         {
;;;65             u32PWMClockFreq = CLK_GetPCLK1Freq();
000020  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L2.36|
000024  4602              MOV      r2,r0
;;;66         }
;;;67     
;;;68         /* Calculate u16PERIOD and u16PSC */
;;;69         for(u32Prescaler = 1UL; u32Prescaler <= 0x1000UL; u32Prescaler++)
000026  2001              MOVS     r0,#1
;;;70         {
;;;71             u32Period = (u32PWMClockFreq / u32Prescaler) / u32Frequency;
;;;72     
;;;73             /* If target u32Period is larger than 0x10000, need to use a larger prescaler */
;;;74             if(u32Period <= 0x10000UL)
000028  0403              LSLS     r3,r0,#16
                  |L2.42|
00002a  fbb2f1f0          UDIV     r1,r2,r0              ;71
00002e  fbb1f1f6          UDIV     r1,r1,r6              ;71
000032  4299              CMP      r1,r3
000034  d902              BLS      |L2.60|
000036  1c40              ADDS     r0,r0,#1
000038  42b8              CMP      r0,r7                 ;69
00003a  d9f6              BLS      |L2.42|
                  |L2.60|
;;;75             {
;;;76                 break;
;;;77             }
;;;78         }
;;;79         /* Store return value here 'cos we're gonna change u32Prescaler & u32Period to the real value to fill into register */
;;;80         u32TargetFreq = (u32PWMClockFreq / u32Prescaler) / u32Period;
00003c  fbb2f2f0          UDIV     r2,r2,r0
000040  fbb2f2f1          UDIV     r2,r2,r1
;;;81     
;;;82         /* Set PWM to up count type */
;;;83         timer->PWMCTL = (timer->PWMCTL & ~TIMER_PWMCTL_CNTTYPE_Msk) | (TPWM_UP_COUNT << TIMER_PWMCTL_CNTTYPE_Pos);
000044  6c23              LDR      r3,[r4,#0x40]
000046  f0230306          BIC      r3,r3,#6
00004a  6423              STR      r3,[r4,#0x40]
;;;84     
;;;85         /* Set PWM to auto-reload mode */
;;;86         timer->PWMCTL = (timer->PWMCTL & ~TIMER_PWMCTL_CNTMODE_Msk) | TPWM_AUTO_RELOAD_MODE;
00004c  6c23              LDR      r3,[r4,#0x40]
00004e  f0230308          BIC      r3,r3,#8
000052  6423              STR      r3,[r4,#0x40]
000054  1e40              SUBS     r0,r0,#1
;;;87     
;;;88         /* Convert to real register value */
;;;89         TPWM_SET_PRESCALER(timer, (u32Prescaler - 1UL));
000056  64a0              STR      r0,[r4,#0x48]
;;;90     
;;;91         TPWM_SET_PERIOD(timer, (u32Period - 1UL));
000058  1e48              SUBS     r0,r1,#1
00005a  6520              STR      r0,[r4,#0x50]
;;;92         if(u32DutyCycle)
00005c  b125              CBZ      r5,|L2.104|
;;;93         {
;;;94             u32CMP = (u32DutyCycle * u32Period) / 100UL;
00005e  434d              MULS     r5,r1,r5
000060  2064              MOVS     r0,#0x64
000062  fbb5f0f0          UDIV     r0,r5,r0
000066  e000              B        |L2.106|
                  |L2.104|
;;;95         }
;;;96         else
;;;97         {
;;;98             u32CMP = 0UL;
000068  2000              MOVS     r0,#0
                  |L2.106|
;;;99         }
;;;100    
;;;101        TPWM_SET_CMPDAT(timer, u32CMP);
00006a  6560              STR      r0,[r4,#0x54]
;;;102    
;;;103        return (u32TargetFreq);
00006c  4610              MOV      r0,r2
;;;104    }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;105    
                          ENDP

000072  0000              DCW      0x0000
                  |L2.116|
                          DCD      0x40050000
                  |L2.120|
                          DCD      0x40050100

                          AREA ||i.TPWM_DisableBrakePinDebounce||, CODE, READONLY, ALIGN=1

                  TPWM_DisableBrakePinDebounce PROC
;;;390      */
;;;391    void TPWM_DisableBrakePinDebounce(TIMER_T *timer)
000000  6e81              LDR      r1,[r0,#0x68]
;;;392    {
;;;393        timer->PWMBNF &= ~TIMER_PWMBNF_BRKNFEN_Msk;
000002  f0210101          BIC      r1,r1,#1
000006  6681              STR      r1,[r0,#0x68]
;;;394    }
000008  4770              BX       lr
;;;395    
                          ENDP


                          AREA ||i.TPWM_DisableBrakePinInverse||, CODE, READONLY, ALIGN=1

                  TPWM_DisableBrakePinInverse PROC
;;;413      */
;;;414    void TPWM_DisableBrakePinInverse(TIMER_T *timer)
000000  6e81              LDR      r1,[r0,#0x68]
;;;415    {
;;;416        timer->PWMBNF &= ~TIMER_PWMBNF_BRKPINV_Msk;
000002  f0210180          BIC      r1,r1,#0x80
000006  6681              STR      r1,[r0,#0x68]
;;;417    }
000008  4770              BX       lr
;;;418    
                          ENDP


                          AREA ||i.TPWM_DisableCounter||, CODE, READONLY, ALIGN=1

                  TPWM_DisableCounter PROC
;;;175      */
;;;176    void TPWM_DisableCounter(TIMER_T *timer)
000000  6c01              LDR      r1,[r0,#0x40]
;;;177    {
;;;178        timer->PWMCTL &= ~TIMER_PWMCTL_CNTEN_Msk;
000002  f0210101          BIC      r1,r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;179    }
000008  4770              BX       lr
;;;180    
                          ENDP


                          AREA ||i.TPWM_DisableDeadTime||, CODE, READONLY, ALIGN=1

                  TPWM_DisableDeadTime PROC
;;;147      */
;;;148    void TPWM_DisableDeadTime(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;149    {
;;;150        timer->PWMDTCTL = 0x0UL;
000002  6581              STR      r1,[r0,#0x58]
;;;151    }
000004  4770              BX       lr
;;;152    
                          ENDP


                          AREA ||i.TPWM_DisableFaultBrakeInt||, CODE, READONLY, ALIGN=1

                  TPWM_DisableFaultBrakeInt PROC
;;;287      */
;;;288    void TPWM_DisableFaultBrakeInt(TIMER_T *timer, uint32_t u32IntSource)
000000  f8502f84          LDR      r2,[r0,#0x84]!
;;;289    {
;;;290        timer->PWMINTEN1 &= ~u32IntSource;
000004  438a              BICS     r2,r2,r1
000006  6002              STR      r2,[r0,#0]
;;;291    }
000008  4770              BX       lr
;;;292    
                          ENDP


                          AREA ||i.TPWM_DisableTriggerADC||, CODE, READONLY, ALIGN=1

                  TPWM_DisableTriggerADC PROC
;;;209      */
;;;210    void TPWM_DisableTriggerADC(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;211    {
;;;212        timer->PWMEADCTS = 0x0UL;
000002  f8c01090          STR      r1,[r0,#0x90]
;;;213    }
000006  4770              BX       lr
;;;214    
                          ENDP


                          AREA ||i.TPWM_EnableBrakePinDebounce||, CODE, READONLY, ALIGN=2

                  TPWM_EnableBrakePinDebounce PROC
;;;373      */
;;;374    void TPWM_EnableBrakePinDebounce(TIMER_T *timer, uint32_t u32BrakePinSrc, uint32_t u32DebounceCnt, uint32_t u32ClkSrcSel)
000000  b530              PUSH     {r4,r5,lr}
;;;375    {
;;;376        timer->PWMBNF = (timer->PWMBNF & ~(TIMER_PWMBNF_BKPINSRC_Msk | TIMER_PWMBNF_BRKFCNT_Msk | TIMER_PWMBNF_BRKNFSEL_Msk)) |
000002  6e84              LDR      r4,[r0,#0x68]
000004  4d05              LDR      r5,|L9.28|
000006  402c              ANDS     r4,r4,r5
000008  ea444101          ORR      r1,r4,r1,LSL #16
00000c  ea411102          ORR      r1,r1,r2,LSL #4
000010  ea410143          ORR      r1,r1,r3,LSL #1
000014  f0410101          ORR      r1,r1,#1
000018  6681              STR      r1,[r0,#0x68]
;;;377                        (u32BrakePinSrc << TIMER_PWMBNF_BKPINSRC_Pos) |
;;;378                        (u32DebounceCnt << TIMER_PWMBNF_BRKFCNT_Pos) |
;;;379                        (u32ClkSrcSel << TIMER_PWMBNF_BRKNFSEL_Pos) | TIMER_PWMBNF_BRKNFEN_Msk;
;;;380    }
00001a  bd30              POP      {r4,r5,pc}
;;;381    
                          ENDP

                  |L9.28|
                          DCD      0xfffcff81

                          AREA ||i.TPWM_EnableBrakePinInverse||, CODE, READONLY, ALIGN=1

                  TPWM_EnableBrakePinInverse PROC
;;;402      */
;;;403    void TPWM_EnableBrakePinInverse(TIMER_T *timer)
000000  6e81              LDR      r1,[r0,#0x68]
;;;404    {
;;;405        timer->PWMBNF |= TIMER_PWMBNF_BRKPINV_Msk;
000002  f0410180          ORR      r1,r1,#0x80
000006  6681              STR      r1,[r0,#0x68]
;;;406    }
000008  4770              BX       lr
;;;407    
                          ENDP


                          AREA ||i.TPWM_EnableCounter||, CODE, READONLY, ALIGN=1

                  TPWM_EnableCounter PROC
;;;161      */
;;;162    void TPWM_EnableCounter(TIMER_T *timer)
000000  6c01              LDR      r1,[r0,#0x40]
;;;163    {
;;;164        timer->PWMCTL |= TIMER_PWMCTL_CNTEN_Msk;
000002  f0410101          ORR      r1,r1,#1
000006  6401              STR      r1,[r0,#0x40]
;;;165    }
000008  4770              BX       lr
;;;166    
                          ENDP


                          AREA ||i.TPWM_EnableDeadTime||, CODE, READONLY, ALIGN=1

                  TPWM_EnableDeadTime PROC
;;;116      */
;;;117    void TPWM_EnableDeadTime(TIMER_T *timer, uint32_t u32DTCount)
000000  f4413180          ORR      r1,r1,#0x10000
;;;118    {
;;;119        timer->PWMDTCTL = TIMER_PWMDTCTL_DTEN_Msk | u32DTCount;
000004  6581              STR      r1,[r0,#0x58]
;;;120    }
000006  4770              BX       lr
;;;121    
                          ENDP


                          AREA ||i.TPWM_EnableDeadTimeWithPrescale||, CODE, READONLY, ALIGN=2

                  TPWM_EnableDeadTimeWithPrescale PROC
;;;132      */
;;;133    void TPWM_EnableDeadTimeWithPrescale(TIMER_T *timer, uint32_t u32DTCount)
000000  4a01              LDR      r2,|L13.8|
;;;134    {
;;;135        timer->PWMDTCTL = TIMER_PWMDTCTL_DTCKSEL_Msk | TIMER_PWMDTCTL_DTEN_Msk | u32DTCount;
000002  4311              ORRS     r1,r1,r2
000004  6581              STR      r1,[r0,#0x58]
;;;136    }
000006  4770              BX       lr
;;;137    
                          ENDP

                  |L13.8|
                          DCD      0x01010000

                          AREA ||i.TPWM_EnableFaultBrake||, CODE, READONLY, ALIGN=1

                  TPWM_EnableFaultBrake PROC
;;;249      */
;;;250    void TPWM_EnableFaultBrake(TIMER_T *timer, uint32_t u32CH0Level, uint32_t u32CH1Level, uint32_t u32BrakeSource)
000000  b530              PUSH     {r4,r5,lr}
;;;251    {
;;;252        timer->PWMFAILBRK |= ((u32BrakeSource >> 16) & 0xFUL);
000002  6ec4              LDR      r4,[r0,#0x6c]
000004  f3c34503          UBFX     r5,r3,#16,#4
000008  432c              ORRS     r4,r4,r5
00000a  66c4              STR      r4,[r0,#0x6c]
;;;253        timer->PWMBRKCTL = (timer->PWMBRKCTL & ~(TIMER_PWMBRKCTL_BRKAEVEN_Msk | TIMER_PWMBRKCTL_BRKAODD_Msk)) |
00000c  6f04              LDR      r4,[r0,#0x70]
00000e  b29b              UXTH     r3,r3
000010  f4242470          BIC      r4,r4,#0xf0000
000014  431c              ORRS     r4,r4,r3
000016  ea444101          ORR      r1,r4,r1,LSL #16
00001a  ea414182          ORR      r1,r1,r2,LSL #18
00001e  6701              STR      r1,[r0,#0x70]
;;;254                           (u32BrakeSource & 0xFFFFUL) | (u32CH0Level << TIMER_PWMBRKCTL_BRKAEVEN_Pos) | (u32CH1Level << TIMER_PWMBRKCTL_BRKAODD_Pos);
;;;255    }
000020  bd30              POP      {r4,r5,pc}
;;;256    
                          ENDP


                          AREA ||i.TPWM_EnableFaultBrakeInt||, CODE, READONLY, ALIGN=1

                  TPWM_EnableFaultBrakeInt PROC
;;;269      */
;;;270    void TPWM_EnableFaultBrakeInt(TIMER_T *timer, uint32_t u32IntSource)
000000  f8502f84          LDR      r2,[r0,#0x84]!
;;;271    {
;;;272        timer->PWMINTEN1 |= u32IntSource;
000004  430a              ORRS     r2,r2,r1
000006  6002              STR      r2,[r0,#0]
;;;273    }
000008  4770              BX       lr
;;;274    
                          ENDP


                          AREA ||i.TPWM_EnableTriggerADC||, CODE, READONLY, ALIGN=1

                  TPWM_EnableTriggerADC PROC
;;;195      */
;;;196    void TPWM_EnableTriggerADC(TIMER_T *timer, uint32_t u32Condition)
000000  f0410180          ORR      r1,r1,#0x80
;;;197    {
;;;198        timer->PWMEADCTS = TIMER_PWMEADCTS_TRGEN_Msk | u32Condition;
000004  f8c01090          STR      r1,[r0,#0x90]
;;;199    }
000008  4770              BX       lr
;;;200    
                          ENDP


                          AREA ||i.TPWM_GetFaultBrakeIntFlag||, CODE, READONLY, ALIGN=1

                  TPWM_GetFaultBrakeIntFlag PROC
;;;306      */
;;;307    uint32_t TPWM_GetFaultBrakeIntFlag(TIMER_T *timer, uint32_t u32IntSource)
000000  f8d0008c          LDR      r0,[r0,#0x8c]
;;;308    {
;;;309        return ((timer->PWMINTSTS1 & (0x3UL << u32IntSource))? 1UL : 0UL);
000004  2203              MOVS     r2,#3
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L17.14|
00000c  2001              MOVS     r0,#1
                  |L17.14|
;;;310    }
00000e  4770              BX       lr
;;;311    
                          ENDP


                          AREA ||i.TPWM_SetBrakePinSource||, CODE, READONLY, ALIGN=1

                  TPWM_SetBrakePinSource PROC
;;;429      */
;;;430    void TPWM_SetBrakePinSource(TIMER_T *timer, uint32_t u32BrakePinNum)
000000  6e82              LDR      r2,[r0,#0x68]
;;;431    {
;;;432        timer->PWMBNF = (((timer)->PWMBNF & ~TIMER_PWMBNF_BKPINSRC_Msk) | (u32BrakePinNum << TIMER_PWMBNF_BKPINSRC_Pos));
000002  f4223240          BIC      r2,r2,#0x30000
000006  ea424101          ORR      r1,r2,r1,LSL #16
00000a  6681              STR      r1,[r0,#0x68]
;;;433    }
00000c  4770              BX       lr
;;;434    
                          ENDP


                          AREA ||i.TPWM_SetCounterClockSource||, CODE, READONLY, ALIGN=1

                  TPWM_SetCounterClockSource PROC
;;;36       */
;;;37     void TPWM_SetCounterClockSource(TIMER_T *timer, uint32_t u32CntClkSrc)
000000  6c42              LDR      r2,[r0,#0x44]
;;;38     {
;;;39         (timer)->PWMCLKSRC = ((timer)->PWMCLKSRC & ~TIMER_PWMCLKSRC_CLKSRC_Msk) | u32CntClkSrc;
000002  f0220207          BIC      r2,r2,#7
000006  430a              ORRS     r2,r2,r1
000008  6442              STR      r2,[r0,#0x44]
;;;40     }
00000a  4770              BX       lr
;;;41     
                          ENDP


                          AREA ||i.TPWM_SetLoadMode||, CODE, READONLY, ALIGN=1

                  TPWM_SetLoadMode PROC
;;;343      */
;;;344    void TPWM_SetLoadMode(TIMER_T *timer, uint32_t u32LoadMode)
000000  6c02              LDR      r2,[r0,#0x40]
;;;345    {
;;;346        timer->PWMCTL = (timer->PWMCTL & ~(TIMER_PWMCTL_IMMLDEN_Msk | TIMER_PWMCTL_CTRLD_Msk)) | u32LoadMode;
000002  f4227240          BIC      r2,r2,#0x300
000006  430a              ORRS     r2,r2,r1
000008  6402              STR      r2,[r0,#0x40]
;;;347    }
00000a  4770              BX       lr
;;;348    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\timer_pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_timer_pwm_c_eec32a9c____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_timer_pwm_c_eec32a9c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_timer_pwm_c_eec32a9c____REVSH|
#line 402
|__asm___11_timer_pwm_c_eec32a9c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_timer_pwm_c_eec32a9c____RRX|
#line 587
|__asm___11_timer_pwm_c_eec32a9c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
